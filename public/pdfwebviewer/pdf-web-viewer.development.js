(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PdfTools"] = factory();
	else
		root["PdfTools"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@pdf-tools/four-heights-pdf-viewing/es6/PdfViewing.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@pdf-tools/four-heights-pdf-viewing/es6/PdfViewing.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PdfViewing": () => (/* binding */ PdfViewing)
/* harmony export */ });
/* Begin of block that initializes the WASM code */
if (window.PdfToolsPromise === undefined) {
    window.Module = {};
    Module['locateFile'] = (path, prefix) => {
        const pdfviewingBaseUrl = window.PDFTOOLS_FOURHEIGHTS_PDFVIEWING_BASEURL;
        return pdfviewingBaseUrl ?
            pdfviewingBaseUrl + (pdfviewingBaseUrl.endsWith('/') ? '' : '/') + path :
            path;
    };
    window.PdfToolsPromise = new Promise((resolve, reject) => {
        window.Module['onRuntimeInitialized'] = () => {
            if (typeof Module.ViewingInitialize !== 'function') {
                const errorMsg = `**************************************
Could not find method Module.ViewingInitialize

%cYou may be using a mismatched version of the 4-Heights® PDF Viewing SDK. Please make sure you have updated all files to the same version.
%c**************************************`;
                console.error(errorMsg, 'color: orange', 'color: gray', 'color: red');
                reject(errorMsg);
            }
            Module.ViewingInitialize();
            resolve();
        };
        const scriptElm = document.createElement('script');
        const scriptSrc = window.Module.locateFile('PdfViewing_Main.js');
        scriptElm.onerror = function (err) {
            console.error(`**************************************
Failed to load PdfViewing_Main.js 

%cThe 4-Heights® PDF Viewing SDK failed to load a required script resource. Either the "Base URL" (PDFTOOLS_FOURHEIGHTS_PDFVIEWING_BASEURL) is not configured correctly or the static assets have not been copied to the configured location. For more information please consult the documentation.

%cwindow.PDFTOOLS_FOURHEIGHTS_PDFVIEWING_BASEURL=>${window.PDFTOOLS_FOURHEIGHTS_PDFVIEWING_BASEURL}
%c**************************************`, 'color: orange', 'color: gray', 'color: red');
            reject('failed to load PdfViewing_Main.js');
        };
        scriptElm.src = scriptSrc;
        document.head.appendChild(scriptElm);
    });
}
var PdfViewing;
(function (PdfViewing) {
    var _a;
    let Internal;
    (function (Internal) {
        class NativeBase {
            /** @internal */
            static throwLastError(allowSuccess = true) {
                let exception = this.createLastError(this.lastErrorCode, this.lastErrorMessage, allowSuccess);
                if (exception === null)
                    return;
                else
                    throw exception;
            }
            /** @internal */
            static createLastError(errorCode, errorMessage, allowSuccess = true) {
                switch (errorCode) {
                    case 0:
                        if (allowSuccess)
                            return null;
                        else
                            return new PdfViewing.PdfViewingError("An unexpected error occurred");
                    case 10:
                        return new PdfViewing.GenericError(errorMessage);
                    case 11:
                        return new PdfViewing.FatalError(errorMessage);
                    case 12:
                        return new PdfViewing.LicenseError(errorMessage);
                    case 15:
                        return new PdfViewing.UnknownFormatError(errorMessage);
                    case 16:
                        return new PdfViewing.CorruptError(errorMessage);
                    case 17:
                        return new PdfViewing.PasswordError(errorMessage);
                    case 18:
                        return new PdfViewing.ConformanceError(errorMessage);
                    case 19:
                        return new PdfViewing.UnsupportedFeatureError(errorMessage);
                    case 20:
                        return new PdfViewing.InfrastructureError(errorMessage);
                    case 21:
                        return new PdfViewing.ProcessingError(errorMessage);
                    case 22:
                        return new PdfViewing.ExistsError(errorMessage);
                    case 23:
                        return new PdfViewing.UpdateFailedError(errorMessage);
                    case 1:
                        return new PdfViewing.NotSupportedError(errorMessage);
                    case 2:
                        return new PdfViewing.InvalidOperationError(errorMessage);
                    case 3:
                        return new PdfViewing.ArgumentError(errorMessage);
                    case 5:
                        return new PdfViewing.NotFoundError(errorMessage);
                    case 4:
                        return new PdfViewing.IOError(errorMessage);
                    default:
                        return null;
                }
            }
            /** @internal */
            static get lastErrorMessage() {
                return Module.ViewingGetLastErrorMessage();
            }
            /** @internal */
            static get lastErrorCode() {
                return Module.ViewingGetLastError();
            }
        }
        Internal.NativeBase = NativeBase;
        class NativeObject extends NativeBase {
            /** @internal */
            constructor(handle) {
                super();
                this._handle = handle;
            }
            /** @internal */
            get handle() {
                if (this._handle === 0) {
                    throw new Error("NULL Pointer");
                }
                return this._handle;
            }
            /** @internal */
            set handle(handle) {
                this._handle = handle;
            }
            equals(obj) {
                if (obj instanceof NativeObject) {
                    if (this._handle === 0 || obj._handle === 0)
                        return false;
                    return Module.ViewingEquals(this._handle, obj._handle);
                }
                return false;
            }
            getHashCode() {
                return this._handle === 0 ? 0 : Module.ViewingGetHashCode(this._handle);
            }
            /** @internal */
            static checkReturnHandleErrorCode(handle) {
                if (handle === 0) {
                    NativeBase.throwLastError(false);
                }
                return handle;
            }
        }
        Internal.NativeObject = NativeObject;
    })(Internal = PdfViewing.Internal || (PdfViewing.Internal = {}));
    class PdfViewingError extends Error {
        constructor(message) {
            super(message);
            const actualProto = new.target.prototype;
            Object.setPrototypeOf(this, actualProto);
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(this, actualProto);
            }
            else {
                this.__proto__ = actualProto;
            }
        }
    }
    PdfViewing.PdfViewingError = PdfViewingError;
    /**
     *
     * Specifies functional features which can be supported by the ViewingSDK.
     * A given license key can permit or prohibit any of these features.
     */
    let LicenseFeature;
    (function (LicenseFeature) {
        /**
         *
         * Viewer may create and edit annotations.
         */
        LicenseFeature[LicenseFeature["Annotate"] = 1] = "Annotate";
        /**
         *
         * Viewer may fill out form fields.
         */
        LicenseFeature[LicenseFeature["FillFormFields"] = 2] = "FillFormFields";
        /**
         *
         * Viewer may rotate individual pages.
         */
        LicenseFeature[LicenseFeature["PageRotation"] = 4] = "PageRotation";
    })(LicenseFeature = PdfViewing.LicenseFeature || (PdfViewing.LicenseFeature = {}));
    /**
     *
     */
    class ViewerController extends Internal.NativeObject {
        /**
         *
         *
         * @throws {@link PdfViewing.LicenseError} The license is not valid.
         */
        constructor() {
            if (arguments[0] && typeof arguments[0].__handle === `number`)
                super(arguments[0].__handle);
            else {
                super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingNewViewerController()));
            }
            this.eventListeners = new Map();
        }
        /**
         * @event
         */
        addEventListener(type, listener) {
            if (typeof listener !== 'function')
                throw new PdfViewing.ArgumentError("Argument 'listener' must be a function.");
            var eventObj;
            if (this.eventListeners.has(type)) {
                if (!this.eventListeners.get(type).has(listener)) {
                    if (type === "busyChanged") {
                        eventObj = new BusyChangedNativeClass(listener);
                        let context = Module.ViewingViewerControllerAddBusyChangedHandler(this.handle, eventObj);
                        if (context == 0)
                            Internal.NativeBase.throwLastError();
                        else
                            eventObj.context = context;
                        this.eventListeners.get(type).set(listener, eventObj);
                    }
                }
                if (!this.eventListeners.get(type).has(listener)) {
                    if (type === "errorOccured") {
                        eventObj = new ErrorOccuredNativeClass(listener);
                        let context = Module.ViewingViewerControllerAddErrorOccuredHandler(this.handle, eventObj);
                        if (context == 0)
                            Internal.NativeBase.throwLastError();
                        else
                            eventObj.context = context;
                        this.eventListeners.get(type).set(listener, eventObj);
                    }
                }
            }
            else {
                if (type === "busyChanged") {
                    eventObj = new BusyChangedNativeClass(listener);
                    let context = Module.ViewingViewerControllerAddBusyChangedHandler(this.handle, eventObj);
                    if (context == 0)
                        Internal.NativeBase.throwLastError();
                    else
                        eventObj.context = context;
                    let mapItem = new Map();
                    mapItem.set(listener, eventObj);
                    this.eventListeners.set(type, mapItem);
                }
                if (type === "errorOccured") {
                    eventObj = new ErrorOccuredNativeClass(listener);
                    let context = Module.ViewingViewerControllerAddErrorOccuredHandler(this.handle, eventObj);
                    if (context == 0)
                        Internal.NativeBase.throwLastError();
                    else
                        eventObj.context = context;
                    let mapItem = new Map();
                    mapItem.set(listener, eventObj);
                    this.eventListeners.set(type, mapItem);
                }
            }
        }
        removeEventListener(type, listener) {
            if (this.eventListeners.has(type)) {
                if (type === "busyChanged") {
                    let listeners = this.eventListeners.get(type);
                    if (listeners.has(listener)) {
                        let eventObj = listeners.get(listener);
                        try {
                            if (!Module.ViewingViewerControllerRemoveBusyChangedHandler(this.handle, eventObj === null || eventObj === void 0 ? void 0 : eventObj.context))
                                Internal.NativeBase.throwLastError();
                        }
                        catch (err) {
                            if (err instanceof NotFoundError)
                                throw err;
                        }
                        listeners.delete(listener);
                        if (listeners.size === 0)
                            this.eventListeners.delete("busyChanged");
                    }
                }
                if (type === "errorOccured") {
                    let listeners = this.eventListeners.get(type);
                    if (listeners.has(listener)) {
                        let eventObj = listeners.get(listener);
                        try {
                            if (!Module.ViewingViewerControllerRemoveErrorOccuredHandler(this.handle, eventObj === null || eventObj === void 0 ? void 0 : eventObj.context))
                                Internal.NativeBase.throwLastError();
                        }
                        catch (err) {
                            if (err instanceof NotFoundError)
                                throw err;
                        }
                        listeners.delete(listener);
                        if (listeners.size === 0)
                            this.eventListeners.delete("errorOccured");
                    }
                }
            }
        }
        /** @internal */
        static createDynamicObject(handle) {
            return new ViewerController({ __handle: handle });
        }
        /**
         * Close the object
         *
         * Release all native resources associated with the object.
         */
        close() {
            if (!Module.ViewingViewerControllerClose(this.handle))
                Internal.NativeBase.throwLastError();
        }
        /**
         *
         * Open a PDF and optionally one or more associated FDFs.
         * @param pdfFile
         * The PDF file to be opened.
         * @param fdfFiles
         * A list of FDF or XFDF files that are opened jointly with the {@link PdfViewing.ViewerController.open pdfFile}.
         * @param password
         * The password used for opening the {@link PdfViewing.ViewerController.open pdfFile}.
         * Set `null` if unencrypted.
         * @returns
         * The document that has been opened.
         *
         * @throws {@link PdfViewing.PasswordError} The file from {@link PdfViewing.ViewerController.open pdfFile} is encrypted and the password is not valid.
         * @throws {@link PdfViewing.IOError} Error reading from a stream.
         * @throws {@link PdfViewing.CorruptError} The file from {@link PdfViewing.ViewerController.open pdfFile} is corrupt or not a PDF.
         * @throws {@link PdfViewing.NotFoundError} The file from {@link PdfViewing.ViewerController.open pdfFile} is missing.
         * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed.
         */
        open(pdfFile, fdfFiles = null, password = null) {
            if (!(pdfFile instanceof PdfViewing.IO.InputDocument))
                throw new PdfViewing.ArgumentError("Argument 'pdfFile' must be of type PdfViewing.IO.InputDocument and must not be null or undefined.");
            if (fdfFiles !== null && fdfFiles !== undefined && !(fdfFiles instanceof PdfViewing.IO.InputDocumentList))
                throw new PdfViewing.ArgumentError("Argument 'fdfFiles' must be of type PdfViewing.IO.InputDocumentList or can be null or undefined.");
            if (password !== null && password !== undefined && (typeof password !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'password' must be of type string or can be null or undefined.");
            var thisHandle = this;
            return new Promise(function (resolved, rejected) {
                if (!Module.ViewingViewerControllerOpen(thisHandle.handle, { thisHandle, resolved, rejected }, pdfFile.handle, (fdfFiles !== null && fdfFiles !== undefined) ? fdfFiles.handle : 0, password))
                    rejected(Module.ViewingGetLastErrorMessage());
            });
        }
        openCallback(context, retVal, errorCode, errorMessage) {
            let error = null;
            if (retVal === 0)
                error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
            if (error === null) {
                context.resolved(PdfViewing.Pdf.Document.createDynamicObject(retVal));
            }
            else
                context.rejected(error);
        }
        /**
         *
         * @param pdf
         * @param fdf
         * @param password
         * the password to open the PDF document
         * @returns
         * The document that has been opened.
         *
         * @throws {@link PdfViewing.PasswordError} The file is encrypted and the password is not valid.
         * @throws {@link PdfViewing.CorruptError} The file is corrupt or not a PDF.
         * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
         *
         * @deprecated Deprecated in Version 3.11. Use Open method instead.
         */
        openMem(pdf, fdf, password) {
            if (!(pdf instanceof Uint8Array))
                throw new PdfViewing.ArgumentError("Argument 'pdf' must be of type Uint8Array and must not be null or undefined.");
            if (fdf !== null && fdf !== undefined && !(fdf instanceof Uint8Array))
                throw new PdfViewing.ArgumentError("Argument 'fdf' must be of type Uint8Array or can be null or undefined.");
            if (password !== null && password !== undefined && (typeof password !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'password' must be of type string or can be null or undefined.");
            var thisHandle = this;
            return new Promise(function (resolved, rejected) {
                if (!Module.ViewingViewerControllerOpenMem(thisHandle.handle, { thisHandle, resolved, rejected }, pdf, fdf, password))
                    rejected(Module.ViewingGetLastErrorMessage());
            });
        }
        openMemCallback(context, retVal, errorCode, errorMessage) {
            let error = null;
            if (retVal === 0)
                error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
            if (error === null) {
                context.resolved(PdfViewing.Pdf.Document.createDynamicObject(retVal));
            }
            else
                context.rejected(error);
        }
        /**
         *
         * @param pdfUri
         * @param fdfUri
         * @param password
         * the password to open the PDF document
         * @param pdfAuthorization
         * @param fdfAuthorization
         * @returns
         * The document that has been opened.
         *
         * @throws {@link PdfViewing.PasswordError} The file is encrypted and the password is not valid.
         * @throws {@link PdfViewing.CorruptError} The file is corrupt or not a PDF.
         * @throws {@link PdfViewing.NotFoundError} The file from {@link PdfViewing.ViewerController.openUri pdfUri} or {@link PdfViewing.ViewerController.openUri fdfUri} is missing.
         * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
         *
         * @deprecated Deprecated in Version 3.11. Use Open method instead.
         */
        openUri(pdfUri, fdfUri, password, pdfAuthorization, fdfAuthorization) {
            if (typeof pdfUri !== 'string')
                throw new PdfViewing.ArgumentError("Argument 'pdfUri' must be of type string and must not be null or undefined.");
            if (fdfUri !== null && fdfUri !== undefined && (typeof fdfUri !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'fdfUri' must be of type string or can be null or undefined.");
            if (password !== null && password !== undefined && (typeof password !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'password' must be of type string or can be null or undefined.");
            if (pdfAuthorization !== null && pdfAuthorization !== undefined && (typeof pdfAuthorization !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'pdfAuthorization' must be of type string or can be null or undefined.");
            if (fdfAuthorization !== null && fdfAuthorization !== undefined && (typeof fdfAuthorization !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'fdfAuthorization' must be of type string or can be null or undefined.");
            var thisHandle = this;
            return new Promise(function (resolved, rejected) {
                if (!Module.ViewingViewerControllerOpenUri(thisHandle.handle, { thisHandle, resolved, rejected }, pdfUri, fdfUri, password, pdfAuthorization, fdfAuthorization))
                    rejected(Module.ViewingGetLastErrorMessage());
            });
        }
        openUriCallback(context, retVal, errorCode, errorMessage) {
            let error = null;
            if (retVal === 0)
                error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
            if (error === null) {
                context.resolved(PdfViewing.Pdf.Document.createDynamicObject(retVal));
            }
            else
                context.rejected(error);
        }
        /**
         *
         * Merge two input documents into one document.
         * @param first
         * The first PDF document. This document is the parent document. It's metadata and viewing properties will be used.
         * @param second
         * The second PDF document. It's pages will be appended to {@link PdfViewing.ViewerController.merge first}
         * @param firstDocumentPassword
         * The password for the first PDF document.
         * @param secondDocumentPassword
         * The password for the second PDF document.
         * @param mergeOptions
         * Document merge options.
         * @returns
         * Binary buffer containing the new document.
         *
         * @throws {@link PdfViewing.PasswordError} Either {@link PdfViewing.ViewerController.merge first} or {@link PdfViewing.ViewerController.merge second} is encrypted and the password is not valid.
         * @throws {@link PdfViewing.IOError} Error reading from a stream.
         * @throws {@link PdfViewing.CorruptError} Either {@link PdfViewing.ViewerController.merge first} or {@link PdfViewing.ViewerController.merge second} is corrupt or not a PDF.
         * @throws {@link PdfViewing.NotFoundError} Either {@link PdfViewing.ViewerController.merge first} or {@link PdfViewing.ViewerController.merge second} is missing.
         * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed.
         */
        merge(first, second, firstDocumentPassword = null, secondDocumentPassword = null, mergeOptions = null) {
            if (!(first instanceof PdfViewing.IO.InputDocument))
                throw new PdfViewing.ArgumentError("Argument 'first' must be of type PdfViewing.IO.InputDocument and must not be null or undefined.");
            if (!(second instanceof PdfViewing.IO.InputDocument))
                throw new PdfViewing.ArgumentError("Argument 'second' must be of type PdfViewing.IO.InputDocument and must not be null or undefined.");
            if (firstDocumentPassword !== null && firstDocumentPassword !== undefined && (typeof firstDocumentPassword !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'firstDocumentPassword' must be of type string or can be null or undefined.");
            if (secondDocumentPassword !== null && secondDocumentPassword !== undefined && (typeof secondDocumentPassword !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'secondDocumentPassword' must be of type string or can be null or undefined.");
            if (mergeOptions !== null && mergeOptions !== undefined && !(mergeOptions instanceof PdfViewing.IO.MergeOptions))
                throw new PdfViewing.ArgumentError("Argument 'mergeOptions' must be of type PdfViewing.IO.MergeOptions or can be null or undefined.");
            var thisHandle = this;
            return new Promise(function (resolved, rejected) {
                if (!Module.ViewingViewerControllerMerge(thisHandle.handle, { thisHandle, resolved, rejected }, first.handle, second.handle, firstDocumentPassword, secondDocumentPassword, (mergeOptions !== null && mergeOptions !== undefined) ? mergeOptions.handle : 0))
                    rejected(Module.ViewingGetLastErrorMessage());
            });
        }
        mergeCallback(context, retVal, errorCode, errorMessage) {
            let error = null;
            if (retVal === 0)
                error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
            if (error === null) {
                context.resolved(PdfViewing.Pdf.Content.BinaryBuffer.createDynamicObject(retVal));
            }
            else
                context.rejected(error);
        }
        /**
        * True if viewer is currently still processing any the latest inputs and some updates to the viewport are incoming.
        *
        * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
        */
        get isBusy() {
            let retVal = Module.ViewingViewerControllerGetIsBusy(this.handle);
            if (!retVal)
                Internal.NativeBase.throwLastError();
            return retVal;
        }
        /**
        * Set how formfields highlights are colored.
        * Use a fully transparent color to disable highlighting.
        *
        * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
        */
        set formsHighlightColor(formsHighlightColor) {
            if (typeof formsHighlightColor !== 'object')
                throw new PdfViewing.ArgumentError("Argument 'formsHighlightColor' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
            let retVal = Module.ViewingViewerControllerSetFormsHighlightColor(this.handle, formsHighlightColor);
            if (!retVal)
                Internal.NativeBase.throwLastError(false);
        }
        /**
        * Set how required formfields highlights are colored.
        * Use a fully transparent color to disable highlighting.
        *
        * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
        */
        set formsHighlightRequiredColor(formsHighlightRequiredColor) {
            if (typeof formsHighlightRequiredColor !== 'object')
                throw new PdfViewing.ArgumentError("Argument 'formsHighlightRequiredColor' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
            let retVal = Module.ViewingViewerControllerSetFormsHighlightRequiredColor(this.handle, formsHighlightRequiredColor);
            if (!retVal)
                Internal.NativeBase.throwLastError(false);
        }
    }
    PdfViewing.ViewerController = ViewerController;
    class EventViewerControllerNativeBase {
        constructor(listener) {
            this.listener = listener;
        }
    }
    class BusyChangedNativeClass extends EventViewerControllerNativeBase {
        constructor(listener) {
            super(listener);
        }
        dispatchEventBusyChanged(busy) {
            this.listener(busy);
        }
    }
    class ErrorOccuredNativeClass extends EventViewerControllerNativeBase {
        constructor(listener) {
            super(listener);
        }
        dispatchEventErrorOccured() {
            this.listener(undefined);
        }
    }
    /**
     *
     */
    class Sdk extends Internal.NativeObject {
        /** @internal */
        constructor(handle) {
            super(handle);
        }
        /** @internal */
        static createDynamicObject(handle) {
            return new Sdk(handle);
        }
        /**
         *
         * @param license
         * Pass the license key to activate the product.
         * An empty string may be passed to use a default license which will watermark all pages.
         * @param producerSuffix
         *
         * @throws {@link PdfViewing.UnknownFormatError} if the format (version) of the {@link PdfViewing.Sdk.initialize license} argument is unknown
         * @throws {@link PdfViewing.CorruptError} if the {@link PdfViewing.Sdk.initialize license} argument is not a correct license key
         * @throws {@link PdfViewing.LicenseError} if the {@link PdfViewing.Sdk.initialize license} argument can be read but the license check failed
         */
        static initialize(license, producerSuffix) {
            if (typeof license !== 'string')
                throw new PdfViewing.ArgumentError("Argument 'license' must be of type string and must not be null or undefined.");
            if (producerSuffix !== null && producerSuffix !== undefined && (typeof producerSuffix !== 'string'))
                throw new PdfViewing.ArgumentError("Argument 'producerSuffix' must be of type string or can be null or undefined.");
            let retVal = Module.ViewingSdkInitialize(license, producerSuffix);
            if (!retVal)
                Internal.NativeBase.throwLastError(false);
        }
        /**
        *
        */
        static get version() {
            let retVal = Module.ViewingSdkGetVersion();
            if (retVal === null)
                Internal.NativeBase.throwLastError(false);
            return retVal;
        }
        /**
        *
        */
        static get producerFullName() {
            let retVal = Module.ViewingSdkGetProducerFullName();
            if (retVal === null)
                Internal.NativeBase.throwLastError(false);
            return retVal;
        }
        /**
        * Returns a bitfield describing which features are supported with the currently set license
        */
        static get supportedFeatures() {
            let retVal = Module.ViewingSdkGetSupportedFeatures();
            if (retVal === 0)
                Internal.NativeBase.throwLastError();
            return retVal;
        }
    }
    PdfViewing.Sdk = Sdk;
    /**
     *
     */
    class IntegerSet extends Internal.NativeObject {
        /** @internal */
        constructor(handle) {
            super(handle);
        }
        /** @internal */
        static createDynamicObject(handle) {
            return new IntegerSet(handle);
        }
        nativeGet(value) {
            let it = Module.ViewingIntegerSetGet(this.handle, value);
            if (it === -1 && Module.ViewingGetLastError() !== 5)
                Internal.NativeBase.throwLastError(false);
            return it;
        }
        [Symbol.iterator]() {
            return new IntegerSetIterator(this);
        }
        clear() {
            if (!Module.ViewingIntegerSetClear(this.handle))
                Internal.NativeBase.throwLastError(false);
        }
        delete(value) {
            if (typeof value !== 'number')
                throw new PdfViewing.ArgumentError("Argument 'value' must be of type number and must not be null or undefined.");
            let it = this.nativeGet(value);
            if (it == -1)
                return false;
            var retVal = Module.ViewingIntegerSetRemove(this.handle, this.nativeGet(value));
            if (!retVal)
                Internal.NativeBase.throwLastError(false);
            return retVal;
        }
        forEach(callbackfn, thisArg) {
            for (const value of this.entries()) {
                callbackfn(value[1], value[0], this);
            }
        }
        has(value) {
            if (typeof value !== 'number')
                throw new PdfViewing.ArgumentError("Argument 'value' must be of type number and must not be null or undefined.");
            return this.nativeGet(value) !== -1;
        }
        add(value) {
            if (typeof value !== 'number')
                throw new PdfViewing.ArgumentError("Argument 'value' must be of type number and must not be null or undefined.");
            if (!Module.ViewingIntegerSetAdd(this.handle, value))
                Internal.NativeBase.throwLastError(false);
            return this;
        }
        get size() {
            let size = Module.ViewingIntegerSetGetSize(this.handle);
            if (size < 0)
                Internal.NativeBase.throwLastError(false);
            return size;
        }
        entries() {
            return new IntegerSetEntryIterator(this);
        }
        keys() {
            return new IntegerSetIterator(this);
        }
        values() {
            return new IntegerSetIterator(this);
        }
    }
    Symbol.toStringTag;
    PdfViewing.IntegerSet = IntegerSet;
    class IntegerSetIteratorBase {
        /** @internal */
        constructor(set) {
            this.set = set;
            this.index = Module.ViewingIntegerSetGetBegin(set.handle);
            if (this.index === -1)
                Internal.NativeBase.throwLastError(false);
            this.end = Module.ViewingIntegerSetGetEnd(set.handle);
            if (this.end === -1)
                Internal.NativeBase.throwLastError(false);
        }
        /** @internal */
        getNextIndex() {
            let nextIndex = Module.ViewingIntegerSetGetNext(this.set.handle, this.index);
            if (nextIndex === -1)
                Internal.NativeBase.throwLastError(false);
            return nextIndex;
        }
        /** @internal */
        getValueFromIndex(index) {
            let retVal = Module.ViewingIntegerSetGetValue(this.set.handle, index);
            if (retVal === 0)
                Internal.NativeBase.throwLastError();
            return retVal;
        }
    }
    class IntegerSetEntryIterator extends IntegerSetIteratorBase {
        constructor(set) {
            super(set);
        }
        next() {
            if (this.index === this.end)
                return { done: true, value: null };
            let element = this.getValueFromIndex(this.index);
            this.index = this.getNextIndex();
            return { done: false, value: [element, element] };
        }
        [Symbol.iterator]() {
            return new IntegerSetEntryIterator(this.set);
        }
    }
    class IntegerSetIterator extends IntegerSetIteratorBase {
        constructor(set) {
            super(set);
        }
        next() {
            if (this.index === this.end)
                return { done: true, value: null };
            let element = this.getValueFromIndex(this.index);
            this.index = this.getNextIndex();
            return { done: false, value: element };
        }
        [Symbol.iterator]() {
            return new IntegerSetIterator(this.set);
        }
    }
    /**
     *
     * A list of strings
     */
    class StringList extends Internal.NativeObject {
        /** @internal */
        constructor(handle) {
            super(handle);
        }
        /** @internal */
        static createDynamicObject(handle) {
            return new StringList(handle);
        }
        remove(element) {
            throw new Error("Method not implemented.");
        }
        add(element) {
            throw new Error("Method not implemented.");
        }
        addRange(inputList) {
            throw new Error("Method not implemented.");
        }
        set(index, element) {
            throw new Error("Method not implemented.");
        }
        clear() {
            throw new Error("Method not implemented.");
        }
        get(index) {
            let retVal = Module.ViewingStringListGet(this.handle, index);
            if (retVal === null)
                Internal.NativeBase.throwLastError(false);
            return retVal;
        }
        getRange(index, count) {
            throw new Error("Method not implemented.");
        }
        get size() {
            let retVal = Module.ViewingStringListGetCount(this.handle);
            if (retVal === -1)
                Internal.NativeBase.throwLastError(false);
            return retVal;
        }
        [Symbol.iterator]() {
            return new ListIterator(this);
        }
    }
    PdfViewing.StringList = StringList;
    /**
     *
     * A map that maps strings to strings.
     */
    class StringMap extends Internal.NativeObject {
        /** @internal */
        constructor(handle) {
            super(handle);
            this[_a] = 'StringMap';
        }
        /** @internal */
        static createDynamicObject(handle) {
            return new StringMap(handle);
        }
        nativeGet(key) {
            let it = Module.ViewingStringMapGet(this.handle, key);
            if (it === -1 && Module.ViewingGetLastError() !== 5)
                Internal.NativeBase.throwLastError();
            return it;
        }
        [Symbol.iterator]() {
            return new StringMapKeyValueIterator(this);
        }
        clear() {
            if (!Module.ViewingStringMapClear(this.handle))
                Internal.NativeBase.throwLastError(false);
        }
        delete(key) {
            if (typeof key !== 'string')
                throw new PdfViewing.ArgumentError("Argument 'key' must be of type string and must not be null or undefined.");
            let it = this.nativeGet(key);
            if (it == -1)
                return false;
            var retVal = Module.ViewingStringMapRemove(this.handle, it);
            if (!retVal)
                Internal.NativeBase.throwLastError(false);
            return true;
        }
        forEach(callbackfn, thisArg) {
            for (const keyValue of this.entries()) {
                callbackfn(keyValue[1], keyValue[0], this);
            }
        }
        get(key) {
            if (typeof key !== 'string')
                throw new PdfViewing.ArgumentError("Argument 'key' must be of type string and must not be null or undefined.");
            let it = Module.ViewingStringMapGet(this.handle, key);
            if (it === -1)
                Internal.NativeBase.throwLastError(false);
            let retVal = Module.ViewingStringMapGetValue(this.handle, it);
            if (retVal === null)
                Internal.NativeBase.throwLastError(false);
            return retVal;
        }
        has(key) {
            if (typeof key !== 'string')
                throw new PdfViewing.ArgumentError("Argument 'key' must be of type string and must not be null or undefined.");
            return this.nativeGet(key) !== -1;
        }
        set(key, value) {
            if (typeof key !== 'string')
                throw new PdfViewing.ArgumentError("Argument 'key' must be of type string and must not be null or undefined.");
            if (typeof value !== 'string')
                throw new PdfViewing.ArgumentError("Argument 'value' must be of type string and must not be null or undefined.");
            if (!Module.ViewingStringMapSet(this.handle, key, value))
                Internal.NativeBase.throwLastError(false);
            return this;
        }
        get size() {
            let size = Module.ViewingStringMapGetSize(this.handle);
            if (size < 0)
                Internal.NativeBase.throwLastError(false);
            return size;
        }
        entries() {
            return new StringMapKeyValueIterator(this);
        }
        keys() {
            return new StringMapKeyIterator(this);
        }
        values() {
            return new StringMapValueIterator(this);
        }
    }
    _a = Symbol.toStringTag;
    PdfViewing.StringMap = StringMap;
    class StringMapIteratorBase extends Internal.NativeBase {
        /** @internal */
        constructor(map) {
            super();
            this.map = map;
            this.index = Module.ViewingStringMapGetBegin(map.handle);
            if (this.index === -1)
                Internal.NativeBase.throwLastError(false);
            this.end = Module.ViewingStringMapGetEnd(map.handle);
            if (this.end === -1)
                Internal.NativeBase.throwLastError(false);
        }
        /** @internal */
        getNextIndex() {
            let nextIndex = Module.ViewingStringMapGetNext(this.map.handle, this.index);
            if (nextIndex === -1)
                Internal.NativeBase.throwLastError(false);
            return nextIndex;
        }
        /** @internal */
        getKeyFromIndex(index) {
            let key = Module.ViewingStringMapGetKey(this.map.handle, index);
            if (key === null)
                Internal.NativeBase.throwLastError(false);
            return key;
        }
        /** @internal */
        getValueFromIndex(index) {
            let retVal = Module.ViewingStringMapGetValue(this.map.handle, index);
            if (retVal === null)
                Internal.NativeBase.throwLastError(false);
            return retVal;
        }
    }
    class StringMapKeyValueIterator extends StringMapIteratorBase {
        constructor(map) {
            super(map);
        }
        next() {
            if (this.index === this.end)
                return { done: true, value: null };
            let key = this.getKeyFromIndex(this.index);
            let element = this.getValueFromIndex(this.index);
            this.index = this.getNextIndex();
            return { done: false, value: [key, element] };
        }
        [Symbol.iterator]() {
            return new StringMapKeyValueIterator(this.map);
        }
    }
    class StringMapKeyIterator extends StringMapIteratorBase {
        constructor(map) {
            super(map);
        }
        next() {
            if (this.index === this.end)
                return { done: true, value: null };
            let key = this.getKeyFromIndex(this.index);
            this.index = this.getNextIndex();
            return { done: false, value: key };
        }
        [Symbol.iterator]() {
            return new StringMapKeyIterator(this.map);
        }
    }
    class StringMapValueIterator extends StringMapIteratorBase {
        constructor(map) {
            super(map);
        }
        next() {
            if (this.index === this.end)
                return { done: true, value: null };
            let element = this.getValueFromIndex(this.index);
            this.index = this.getNextIndex();
            return { done: false, value: element };
        }
        [Symbol.iterator]() {
            return new StringMapValueIterator(this.map);
        }
    }
    let IO;
    (function (IO) {
        /**
         *
         * Describes the type of the file.
         */
        let FileType;
        (function (FileType) {
            /**
             *
             * A PDF file contains all content.
             */
            FileType[FileType["Pdf"] = 0] = "Pdf";
            /**
             *
             * A FDF file may only contain annotations and form fields.
             */
            FileType[FileType["Fdf"] = 1] = "Fdf";
        })(FileType = IO.FileType || (IO.FileType = {}));
        /**
         *
         * A PDF, FDF or XFDF File
         */
        class InputDocument extends Internal.NativeObject {
            /** @internal */
            constructor(handle) {
                super(handle);
            }
            /** @internal */
            static createDynamicObject(handle) {
                let type = Module.ViewingIOInputDocumentGetType(handle);
                switch (type) {
                    case 0:
                        return new InputDocument(handle);
                    case 1:
                        return PdfViewing.IO.InputUri.createDynamicObject(handle);
                    case 2:
                        return PdfViewing.IO.InputFile.createDynamicObject(handle);
                    default:
                        return new InputDocument(handle);
                }
            }
            /**
            * Tag that identifies annotations coming from present document (PDF, FDF or XFDF).
            * The tag for an annotation can be retrieved by {@link PdfViewing.Pdf.Annotations.Annotation.sourceTag }.
            */
            get sourceTag() {
                let retVal = Module.ViewingIOInputDocumentGetSourceTag(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
        }
        IO.InputDocument = InputDocument;
        /**
         *
         * A file that can be opened on a text-uri.
         */
        class InputUri extends PdfViewing.IO.InputDocument {
            /**
             *
             * @param uri
             * The uri where the file can be loaded from.
             * @param httpOptions
             * Contains custom settings that one wants to apply to the HTTP request.
             * @param sourceTag
             * Tag that identifies annotations coming from present document (PDF, FDF or XFDF).
             * The tag for an annotation can be retrieved by {@link PdfViewing.Pdf.Annotations.Annotation.sourceTag }.
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the file is an encrypted FDF or XFDF.
             */
            constructor(uri, httpOptions = null, sourceTag = null) {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    if (typeof uri !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'uri' must be of type string and must not be null or undefined.");
                    if (httpOptions !== null && httpOptions !== undefined && !(httpOptions instanceof PdfViewing.IO.HttpOptions))
                        throw new PdfViewing.ArgumentError("Argument 'httpOptions' must be of type PdfViewing.IO.HttpOptions or can be null or undefined.");
                    if (sourceTag !== null && sourceTag !== undefined && (typeof sourceTag !== 'string'))
                        throw new PdfViewing.ArgumentError("Argument 'sourceTag' must be of type string or can be null or undefined.");
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingIONewInputUri(uri, (httpOptions !== null && httpOptions !== undefined) ? httpOptions.handle : 0, sourceTag)));
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new InputUri({ __handle: handle });
            }
            /**
            * Get uri where this file is loaded from.
            */
            get uri() {
                let retVal = Module.ViewingIOInputUriGetUri(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return retVal;
            }
        }
        IO.InputUri = InputUri;
        /**
         *
         */
        class InputFile extends PdfViewing.IO.InputDocument {
            /**
             *
             * @param data
             * The byte array containing the file in memory.
             * @param sourceTag
             * Tag that identifies annotations coming from present document (PDF, FDF or XFDF).
             * The tag for an annotation can be retrieved by {@link PdfViewing.Pdf.Annotations.Annotation.sourceTag }.
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the file is an encrypted FDF or XFDF.
             */
            constructor(data, sourceTag = null) {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    if (!(data instanceof Uint8Array))
                        throw new PdfViewing.ArgumentError("Argument 'data' must be of type Uint8Array and must not be null or undefined.");
                    if (sourceTag !== null && sourceTag !== undefined && (typeof sourceTag !== 'string'))
                        throw new PdfViewing.ArgumentError("Argument 'sourceTag' must be of type string or can be null or undefined.");
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingIONewInputFile(data, sourceTag)));
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new InputFile({ __handle: handle });
            }
            /**
            * Get byte array containing the file in memory.
            */
            get data() {
                let retVal = Module.ViewingIOInputFileGetData(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new Uint8Array(retVal);
            }
        }
        IO.InputFile = InputFile;
        /**
         *
         * A list of files
         */
        class InputDocumentList extends Internal.NativeObject {
            /**
             *
             */
            constructor() {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingIONewInputDocumentList()));
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new InputDocumentList({ __handle: handle });
            }
            /** @internal */
            indexOf(element) {
                for (var i = 0; i < this.size; i++) {
                    if (element.equals(this.get(i)))
                        return i;
                }
                return -1;
            }
            remove(element) {
                if (!(element instanceof PdfViewing.IO.InputDocument))
                    throw new PdfViewing.ArgumentError("Argument 'element' must be of type PdfViewing.IO.InputDocument and must not be null or undefined.");
                let index = this.indexOf(element);
                if (index == -1)
                    return false;
                let retVal = Module.ViewingIOInputDocumentListRemove(this.handle, index);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
                return true;
            }
            add(element) {
                if (!(element instanceof PdfViewing.IO.InputDocument))
                    throw new PdfViewing.ArgumentError("Argument 'element' must be of type PdfViewing.IO.InputDocument and must not be null or undefined.");
                let retVal = Module.ViewingIOInputDocumentListAdd(this.handle, element.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
                return true;
            }
            addRange(inputList) {
                throw new Error("Method not implemented.");
            }
            set(index, element) {
                if (!(element instanceof PdfViewing.IO.InputDocument))
                    throw new PdfViewing.ArgumentError("Argument 'element' must be of type PdfViewing.IO.InputDocument and must not be null or undefined.");
                let retVal = Module.ViewingIOInputDocumentListSet(this.handle, index, element.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            clear() {
                let retVal = Module.ViewingIOInputDocumentListClear(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            get(index) {
                let retVal = Module.ViewingIOInputDocumentListGet(this.handle, index);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.IO.InputDocument.createDynamicObject(retVal);
            }
            getRange(index, count) {
                throw new Error("Method not implemented.");
            }
            get size() {
                let retVal = Module.ViewingIOInputDocumentListGetCount(this.handle);
                if (retVal === -1)
                    Internal.NativeBase.throwLastError(false);
                return retVal;
            }
            [Symbol.iterator]() {
                return new ListIterator(this);
            }
        }
        IO.InputDocumentList = InputDocumentList;
        /**
         *
         * Contains options that are applied to a HTTP request.
         */
        class HttpOptions extends Internal.NativeObject {
            /**
             *
             */
            constructor() {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingIONewHttpOptions()));
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new HttpOptions({ __handle: handle });
            }
            /**
            * The mode for the request, possible values among others:
            *   - "cors"
            *   - "no-cors"
            *   - "same-origin"
            */
            get mode() {
                let retVal = Module.ViewingIOHttpOptionsGetMode(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The mode for the request, possible values among others:
            *   - "cors"
            *   - "no-cors"
            *   - "same-origin"
            */
            set mode(mode) {
                if (mode !== null && mode !== undefined && (typeof mode !== 'string'))
                    throw new PdfViewing.ArgumentError("Argument 'mode' must be of type string or can be null or undefined.");
                let retVal = Module.ViewingIOHttpOptionsSetMode(this.handle, mode);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * A string indicating how the request will interact with the browser's HTTP cache.
            * The possible values are:
            *   - "default"
            *   - "no-store"
            *   - "reload"
            *   - "no-cache"
            *   - "force-cache"
            *   - "only-if-cached"
            */
            get cache() {
                let retVal = Module.ViewingIOHttpOptionsGetCache(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * A string indicating how the request will interact with the browser's HTTP cache.
            * The possible values are:
            *   - "default"
            *   - "no-store"
            *   - "reload"
            *   - "no-cache"
            *   - "force-cache"
            *   - "only-if-cached"
            */
            set cache(cache) {
                if (cache !== null && cache !== undefined && (typeof cache !== 'string'))
                    throw new PdfViewing.ArgumentError("Argument 'cache' must be of type string or can be null or undefined.");
                let retVal = Module.ViewingIOHttpOptionsSetCache(this.handle, cache);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Controls what browsers do with credentials (i.e. cookies, HTTP authentication entries, and TLS client certificates).
            * Default value is "same-origin".
            * Must be one of the following strings:
            *   - "omit": Tells browsers to exclude credentials from the request, and ignore any credentials sent back in the response (e.g., any Set-Cookie header).
            *   - "same-origin": Tells browsers to include credentials with requests to same-origin URLs, and use any credentials sent back in responses from same-origin URLs.
            *   - "include": Tells browsers to include credentials in both same- and cross-origin requests, and always use any credentials sent back in responses.
            */
            get credentials() {
                let retVal = Module.ViewingIOHttpOptionsGetCredentials(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Controls what browsers do with credentials (i.e. cookies, HTTP authentication entries, and TLS client certificates).
            * Default value is "same-origin".
            * Must be one of the following strings:
            *   - "omit": Tells browsers to exclude credentials from the request, and ignore any credentials sent back in the response (e.g., any Set-Cookie header).
            *   - "same-origin": Tells browsers to include credentials with requests to same-origin URLs, and use any credentials sent back in responses from same-origin URLs.
            *   - "include": Tells browsers to include credentials in both same- and cross-origin requests, and always use any credentials sent back in responses.
            */
            set credentials(credentials) {
                if (credentials !== null && credentials !== undefined && (typeof credentials !== 'string'))
                    throw new PdfViewing.ArgumentError("Argument 'credentials' must be of type string or can be null or undefined.");
                let retVal = Module.ViewingIOHttpOptionsSetCredentials(this.handle, credentials);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Specify how to handle the response.
            * Default value is "follow".
            * Possible values are:
            *   - "follow": Automatically follow redirects.
            *   - "error": Abort with an error if a redirect occurs.
            *   - "manual": Caller intends to process the response in another context.
            */
            get redirect() {
                let retVal = Module.ViewingIOHttpOptionsGetRedirect(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Specify how to handle the response.
            * Default value is "follow".
            * Possible values are:
            *   - "follow": Automatically follow redirects.
            *   - "error": Abort with an error if a redirect occurs.
            *   - "manual": Caller intends to process the response in another context.
            */
            set redirect(redirect) {
                if (redirect !== null && redirect !== undefined && (typeof redirect !== 'string'))
                    throw new PdfViewing.ArgumentError("Argument 'redirect' must be of type string or can be null or undefined.");
                let retVal = Module.ViewingIOHttpOptionsSetRedirect(this.handle, redirect);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Specifies the referrer policy to use for the request.
            * Possible values are:
            *   - "no-referrer"
            *   - "no-referrer-when-downgrade"
            *   - "same-origin"
            *   - "origin"
            *   - "strict-origin"
            *   - "origin-when-cross-origin"
            *   - "strict-origin-when-cross-origin"
            *   - "unsafe-url"
            */
            get referrerPolicy() {
                let retVal = Module.ViewingIOHttpOptionsGetReferrerPolicy(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Specifies the referrer policy to use for the request.
            * Possible values are:
            *   - "no-referrer"
            *   - "no-referrer-when-downgrade"
            *   - "same-origin"
            *   - "origin"
            *   - "strict-origin"
            *   - "origin-when-cross-origin"
            *   - "strict-origin-when-cross-origin"
            *   - "unsafe-url"
            */
            set referrerPolicy(referrerPolicy) {
                if (referrerPolicy !== null && referrerPolicy !== undefined && (typeof referrerPolicy !== 'string'))
                    throw new PdfViewing.ArgumentError("Argument 'referrerPolicy' must be of type string or can be null or undefined.");
                let retVal = Module.ViewingIOHttpOptionsSetReferrerPolicy(this.handle, referrerPolicy);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Headers to be added to the request.
            */
            get headers() {
                let retVal = Module.ViewingIOHttpOptionsGetHeaders(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.StringMap.createDynamicObject(retVal);
            }
        }
        IO.HttpOptions = HttpOptions;
        /**
         *
         * Contains options for merging two PDF documents into one.
         */
        class MergeOptions extends Internal.NativeObject {
            /**
             *
             */
            constructor() {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingIONewMergeOptions()));
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new MergeOptions({ __handle: handle });
            }
            /**
            * Copy links (document internal and external links).
            */
            get copyLinks() {
                let retVal = Module.ViewingIOMergeOptionsGetCopyLinks(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Copy links (document internal and external links).
            */
            set copyLinks(copyLinks) {
                if (typeof copyLinks !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'copyLinks' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingIOMergeOptionsSetCopyLinks(this.handle, copyLinks);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Copy interactive annotations such as sticky notes or highlight annotations.
            */
            get copyAnnotations() {
                let retVal = Module.ViewingIOMergeOptionsGetCopyAnnotations(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Copy interactive annotations such as sticky notes or highlight annotations.
            */
            set copyAnnotations(copyAnnotations) {
                if (typeof copyAnnotations !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'copyAnnotations' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingIOMergeOptionsSetCopyAnnotations(this.handle, copyAnnotations);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Copy interactive form fields.
            */
            get copyFormFields() {
                let retVal = Module.ViewingIOMergeOptionsGetCopyFormFields(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Copy interactive form fields.
            */
            set copyFormFields(copyFormFields) {
                if (typeof copyFormFields !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'copyFormFields' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingIOMergeOptionsSetCopyFormFields(this.handle, copyFormFields);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Copy outlines (also called bookmarks).
            */
            get copyOutlines() {
                let retVal = Module.ViewingIOMergeOptionsGetCopyOutlines(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Copy outlines (also called bookmarks).
            */
            set copyOutlines(copyOutlines) {
                if (typeof copyOutlines !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'copyOutlines' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingIOMergeOptionsSetCopyOutlines(this.handle, copyOutlines);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Copy logical structure and tagging information.
            */
            get copyLogicalStructure() {
                let retVal = Module.ViewingIOMergeOptionsGetCopyLogicalStructure(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Copy logical structure and tagging information.
            */
            set copyLogicalStructure(copyLogicalStructure) {
                if (typeof copyLogicalStructure !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'copyLogicalStructure' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingIOMergeOptionsSetCopyLogicalStructure(this.handle, copyLogicalStructure);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Copy named destinations.
            */
            get copyNamedDestinations() {
                let retVal = Module.ViewingIOMergeOptionsGetCopyNamedDestinations(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Copy named destinations.
            */
            set copyNamedDestinations(copyNamedDestinations) {
                if (typeof copyNamedDestinations !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'copyNamedDestinations' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingIOMergeOptionsSetCopyNamedDestinations(this.handle, copyNamedDestinations);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Copy unsigned signature fields.
            */
            get copyUnsignedSignatures() {
                let retVal = Module.ViewingIOMergeOptionsGetCopyUnsignedSignatures(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Copy unsigned signature fields.
            */
            set copyUnsignedSignatures(copyUnsignedSignatures) {
                if (typeof copyUnsignedSignatures !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'copyUnsignedSignatures' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingIOMergeOptionsSetCopyUnsignedSignatures(this.handle, copyUnsignedSignatures);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
        }
        IO.MergeOptions = MergeOptions;
    })(IO = PdfViewing.IO || (PdfViewing.IO = {}));
    let Pdf;
    (function (Pdf) {
        /**
         *
         * Declares which kind of changes were done in the document since opening or last save action.
         */
        let DocumentChange;
        (function (DocumentChange) {
            /**
             *
             * Nothing has been changed.
             */
            DocumentChange[DocumentChange["NoChange"] = 0] = "NoChange";
            /**
             *
             * Some annotations have been created, edited or deleted and the containing files need to be saved.
             */
            DocumentChange[DocumentChange["Annotation"] = 1] = "Annotation";
            /**
             *
             * Some content has been edited and the PDF needs to be saved.
             */
            DocumentChange[DocumentChange["Content"] = 2] = "Content";
        })(DocumentChange = Pdf.DocumentChange || (Pdf.DocumentChange = {}));
        /**
         *
         * The claimed standard compliance of the PDF document.
         */
        let Compliance;
        (function (Compliance) {
            /**
             *
             * Unkown claimed compliance
             */
            Compliance[Compliance["Unknown"] = 0] = "Unknown";
            /**
             *
             * PDF 1.0
             */
            Compliance[Compliance["Pdf10"] = 1] = "Pdf10";
            /**
             *
             * PDF 1.1
             */
            Compliance[Compliance["Pdf11"] = 2] = "Pdf11";
            /**
             *
             * PDF 1.2
             */
            Compliance[Compliance["Pdf12"] = 3] = "Pdf12";
            /**
             *
             * PDF 1.3
             */
            Compliance[Compliance["Pdf13"] = 4] = "Pdf13";
            /**
             *
             * PDF 1.4
             */
            Compliance[Compliance["Pdf14"] = 5] = "Pdf14";
            /**
             *
             * PDF 1.5
             */
            Compliance[Compliance["Pdf15"] = 6] = "Pdf15";
            /**
             *
             * PDF 1.6
             */
            Compliance[Compliance["Pdf16"] = 7] = "Pdf16";
            /**
             *
             * PDF 1.7
             */
            Compliance[Compliance["Pdf17"] = 8] = "Pdf17";
            /**
             *
             * PDF 2.0
             */
            Compliance[Compliance["Pdf20"] = 9] = "Pdf20";
            /**
             *
             * PDF/A-1
             */
            Compliance[Compliance["PdfA1b"] = 10] = "PdfA1b";
            /**
             *
             * PDF/A-1a
             */
            Compliance[Compliance["PdfA1a"] = 11] = "PdfA1a";
            /**
             *
             * PDF/A-2b
             */
            Compliance[Compliance["PdfA2b"] = 12] = "PdfA2b";
            /**
             *
             * PDF/A-2u
             */
            Compliance[Compliance["PdfA2u"] = 13] = "PdfA2u";
            /**
             *
             * PDF/A-2a
             */
            Compliance[Compliance["PdfA2a"] = 14] = "PdfA2a";
            /**
             *
             * PDF/A-3b
             */
            Compliance[Compliance["PdfA3b"] = 15] = "PdfA3b";
            /**
             *
             * PDF/A-3u
             */
            Compliance[Compliance["PdfA3u"] = 16] = "PdfA3u";
            /**
             *
             * PDF/A-3a
             */
            Compliance[Compliance["PdfA3a"] = 17] = "PdfA3a";
        })(Compliance = Pdf.Compliance || (Pdf.Compliance = {}));
        /**
         *
         * The intended target for rendering.
         */
        let OutputMedium;
        (function (OutputMedium) {
            /**
             *
             * Show rendered output on a display.
             */
            OutputMedium[OutputMedium["Display"] = 0] = "Display";
            /**
             *
             * Print rendered output onto paper.
             */
            OutputMedium[OutputMedium["Print"] = 1] = "Print";
        })(OutputMedium = Pdf.OutputMedium || (Pdf.OutputMedium = {}));
        /**
         *
         * Options used for rendering pages.
         */
        class RenderOptions extends Internal.NativeObject {
            /**
             *
             */
            constructor() {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNewRenderOptions()));
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new RenderOptions({ __handle: handle });
            }
            /**
            * Color of form field highlights.
            * By default a light blue color is used.
            * Use a fully transparent color to disable highlighting.
            */
            get formFieldHighlightColor() {
                let retVal = Module.ViewingPdfRenderOptionsGetFormFieldHighlightColor(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
            }
            /**
            * Color of form field highlights.
            * By default a light blue color is used.
            * Use a fully transparent color to disable highlighting.
            */
            set formFieldHighlightColor(formFieldHighlightColor) {
                if (typeof formFieldHighlightColor !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'formFieldHighlightColor' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                let retVal = Module.ViewingPdfRenderOptionsSetFormFieldHighlightColor(this.handle, formFieldHighlightColor);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Color of form field highlights for required fields.
            * By default a red color is used.
            * Use a fully transparent color to disable highlighting of required fields.
            */
            get formFieldRequiredHighlightColor() {
                let retVal = Module.ViewingPdfRenderOptionsGetFormFieldRequiredHighlightColor(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
            }
            /**
            * Color of form field highlights for required fields.
            * By default a red color is used.
            * Use a fully transparent color to disable highlighting of required fields.
            */
            set formFieldRequiredHighlightColor(formFieldRequiredHighlightColor) {
                if (typeof formFieldRequiredHighlightColor !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'formFieldRequiredHighlightColor' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                let retVal = Module.ViewingPdfRenderOptionsSetFormFieldRequiredHighlightColor(this.handle, formFieldRequiredHighlightColor);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Filter that decides which annotations get rendered.
            * Set `null` to render all Annotations.
            * Default value is `null`.
            */
            set annotationFilter(annotationFilter) {
                if (annotationFilter !== null && annotationFilter !== undefined && (typeof annotationFilter !== 'function'))
                    throw new PdfViewing.ArgumentError("Argument 'annotationFilter' must be of type PdfViewing.Pdf.Annotations.AnnotationFilter or can be null or undefined.");
                let retVal = Module.ViewingPdfRenderOptionsSetAnnotationFilter(this.handle, (annotationFilter !== null && annotationFilter !== undefined) ? new AnnotationFilterWrapper(annotationFilter) : null);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Set what ouput medium you want to use the rendered images for.
            * Default is "display".
            */
            get outputMedium() {
                let retVal = Module.ViewingPdfRenderOptionsGetOutputMedium(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Set what ouput medium you want to use the rendered images for.
            * Default is "display".
            */
            set outputMedium(outputMedium) {
                if (typeof outputMedium !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'outputMedium' must be of type PdfViewing.Pdf.OutputMedium and must not be null or undefined.");
                let retVal = Module.ViewingPdfRenderOptionsSetOutputMedium(this.handle, outputMedium);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
        }
        Pdf.RenderOptions = RenderOptions;
        /**
         *
         * Additional settings to configure the initial view
         */
        class ViewOptions extends Internal.NativeObject {
            /**
             *
             */
            constructor() {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNewViewOptions()));
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new ViewOptions({ __handle: handle });
            }
            /**
            * Destination that the view should initially navigate to.
            */
            get initialDestination() {
                let retVal = Module.ViewingPdfViewOptionsGetInitialDestination(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal !== 0 ? PdfViewing.Pdf.Navigation.Destination.createDynamicObject(retVal) : null;
            }
            /**
            * Destination that the view should initially navigate to.
            */
            set initialDestination(initialDestination) {
                if (initialDestination !== null && initialDestination !== undefined && !(initialDestination instanceof PdfViewing.Pdf.Navigation.Destination))
                    throw new PdfViewing.ArgumentError("Argument 'initialDestination' must be of type PdfViewing.Pdf.Navigation.Destination or can be null or undefined.");
                let retVal = Module.ViewingPdfViewOptionsSetInitialDestination(this.handle, (initialDestination !== null && initialDestination !== undefined) ? initialDestination.handle : 0);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * This will override any fitting operation in the given {@link PdfViewing.Pdf.ViewOptions.initialDestination },
            * but preserve the navigation to the target of said destination.
            */
            get initialFitMode() {
                let retVal = Module.ViewingPdfViewOptionsGetInitialFitMode(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * This will override any fitting operation in the given {@link PdfViewing.Pdf.ViewOptions.initialDestination },
            * but preserve the navigation to the target of said destination.
            */
            set initialFitMode(initialFitMode) {
                if (initialFitMode !== null && initialFitMode !== undefined && (typeof initialFitMode !== 'number'))
                    throw new PdfViewing.ArgumentError("Argument 'initialFitMode' must be of type PdfViewing.Pdf.Navigation.FitMode or can be null or undefined.");
                let retVal = Module.ViewingPdfViewOptionsSetInitialFitMode(this.handle, initialFitMode);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Set a initial page-layout mode.
            */
            get initialPageLayoutMode() {
                let retVal = Module.ViewingPdfViewOptionsGetInitialPageLayoutMode(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Set a initial page-layout mode.
            */
            set initialPageLayoutMode(initialPageLayoutMode) {
                if (initialPageLayoutMode !== null && initialPageLayoutMode !== undefined && (typeof initialPageLayoutMode !== 'number'))
                    throw new PdfViewing.ArgumentError("Argument 'initialPageLayoutMode' must be of type PdfViewing.Pdf.Navigation.PageLayoutMode or can be null or undefined.");
                let retVal = Module.ViewingPdfViewOptionsSetInitialPageLayoutMode(this.handle, initialPageLayoutMode);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Set an initial viewport size in pixel.
            * Default: 720 (height) and 480 (width).
            */
            get viewportSize() {
                let retVal = Module.ViewingPdfViewOptionsGetViewportSize(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Integer.Size(retVal.width, retVal.height);
            }
            /**
            * Set an initial viewport size in pixel.
            * Default: 720 (height) and 480 (width).
            */
            set viewportSize(viewportSize) {
                if (typeof viewportSize !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'viewportSize' must be of type PdfViewing.Pdf.Geometry.Integer.Size and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewOptionsSetViewportSize(this.handle, viewportSize);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * Set an initial resolution in DPI (dots per inch) for this view.
            * Default: 96.0.
            */
            get viewDPI() {
                let retVal = Module.ViewingPdfViewOptionsGetViewDPI(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Set an initial resolution in DPI (dots per inch) for this view.
            * Default: 96.0.
            */
            set viewDPI(viewDPI) {
                if (typeof viewDPI !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'viewDPI' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewOptionsSetViewDPI(this.handle, viewDPI);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
        }
        Pdf.ViewOptions = ViewOptions;
        /**
         *
         * Options used for saving {@link PdfViewing.Pdf.Document }s.
         */
        class SaveOptions extends Internal.NativeObject {
            /**
             *
             */
            constructor() {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNewSaveOptions()));
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new SaveOptions({ __handle: handle });
            }
            /**
            * Choose whether the outputfile should be a PDF or an FDF document.
            * Default is {@link PdfViewing.IO.FileType.Pdf }.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get fileType() {
                let retVal = Module.ViewingPdfSaveOptionsGetFileType(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Choose whether the outputfile should be a PDF or an FDF document.
            * Default is {@link PdfViewing.IO.FileType.Pdf }.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set fileType(fileType) {
                if (typeof fileType !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'fileType' must be of type PdfViewing.IO.FileType and must not be null or undefined.");
                let retVal = Module.ViewingPdfSaveOptionsSetFileType(this.handle, fileType);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * A callback to be called for each annotation in the document when saving.
            * The result of the callback determines whether the annotation is included in the output.
            * Pass `null` to save all annotations.
            * Default is `null`.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set annotationFilter(annotationFilter) {
                if (annotationFilter !== null && annotationFilter !== undefined && (typeof annotationFilter !== 'function'))
                    throw new PdfViewing.ArgumentError("Argument 'annotationFilter' must be of type PdfViewing.Pdf.Annotations.AnnotationFilter or can be null or undefined.");
                let retVal = Module.ViewingPdfSaveOptionsSetAnnotationFilter(this.handle, (annotationFilter !== null && annotationFilter !== undefined) ? new AnnotationFilterWrapper(annotationFilter) : null);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
        }
        Pdf.SaveOptions = SaveOptions;
        /**
         *
         */
        class Page extends Internal.NativeObject {
            /** @internal */
            constructor(handle) {
                super(handle);
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new Page(handle);
            }
            /**
             * Close the object
             *
             * Release all native resources associated with the object.
             */
            close() {
                if (!Module.ViewingPdfPageClose(this.handle))
                    Internal.NativeBase.throwLastError();
            }
            /**
             *
             * Rotate this page by the specified number of degrees.
             * @param rotateBy
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.LicenseError} The license is not valid for the editing feature.
             */
            rotatePage(rotateBy) {
                if (typeof rotateBy !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'rotateBy' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                let retVal = Module.ViewingPdfPageRotatePage(this.handle, rotateBy);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
        }
        Pdf.Page = Page;
        /**
         *
         */
        class PageList extends Internal.NativeObject {
            /** @internal */
            constructor(handle) {
                super(handle);
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new PageList(handle);
            }
            /**
             * Close the object
             *
             * Release all native resources associated with the object.
             */
            close() {
                if (!Module.ViewingPdfPageListClose(this.handle))
                    Internal.NativeBase.throwLastError();
            }
            remove(element) {
                throw new Error("Method not implemented.");
            }
            add(element) {
                throw new Error("Method not implemented.");
            }
            addRange(inputList) {
                throw new Error("Method not implemented.");
            }
            set(index, element) {
                throw new Error("Method not implemented.");
            }
            clear() {
                throw new Error("Method not implemented.");
            }
            get(index) {
                let retVal = Module.ViewingPdfPageListGet(this.handle, index);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.Page.createDynamicObject(retVal);
            }
            getRange(index, count) {
                throw new Error("Method not implemented.");
            }
            get size() {
                let retVal = Module.ViewingPdfPageListGetCount(this.handle);
                if (retVal === -1)
                    Internal.NativeBase.throwLastError(false);
                return retVal;
            }
            [Symbol.iterator]() {
                return new ListIterator(this);
            }
        }
        Pdf.PageList = PageList;
        /**
         *
         * Allows Interacting with an opened document
         */
        class Document extends Internal.NativeObject {
            /** @internal */
            constructor(handle) {
                super(handle);
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new Document(handle);
            }
            /**
             * Close the object
             *
             * Release all native resources associated with the object.
             */
            close() {
                if (!Module.ViewingPdfDocumentClose(this.handle))
                    Internal.NativeBase.throwLastError();
            }
            /**
             *
             * Return the opened PDF as binary data,
             * to be used, e.g., to save the file to disk.
             * @param asFdf
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.LicenseError} The license is not valid for this feature.
             *
             * @deprecated Deprecated in Version 3.10. Use method Save instead.
             */
            saveFile(asFdf) {
                if (typeof asFdf !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'asFdf' must be of type boolean and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentSaveFile(thisHandle.handle, { thisHandle, resolved, rejected }, asFdf))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            saveFileCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved(PdfViewing.Pdf.Content.BinaryBuffer.createDynamicObject(retVal));
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Return the opened PDF or FDF as binary data,
             * to be used, e.g., to save the file to disk.
             * @param saveOptions
             * Options used for saving the document.
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.NotSupportedError} if trying to save an annotation type to FDF which is currently not supported.
             *         Unsupported are: {@link PdfViewing.Pdf.Annotations.FileAttachment }
             *         and all derivatives of {@link PdfViewing.Pdf.Annotations.Link } and {@link PdfViewing.Pdf.Forms.Widget }.
             * @throws {@link PdfViewing.LicenseError} The license is not valid for the editing feature.
             */
            save(saveOptions = null) {
                if (saveOptions !== null && saveOptions !== undefined && !(saveOptions instanceof PdfViewing.Pdf.SaveOptions))
                    throw new PdfViewing.ArgumentError("Argument 'saveOptions' must be of type PdfViewing.Pdf.SaveOptions or can be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentSave(thisHandle.handle, { thisHandle, resolved, rejected }, (saveOptions !== null && saveOptions !== undefined) ? saveOptions.handle : 0))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            saveCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved(PdfViewing.Pdf.Content.BinaryBuffer.createDynamicObject(retVal));
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Start a new textsearch.
             * All results for the same textsearch can be iterated over using the returned {@link PdfViewing.Pdf.Content.TextSearchIterator }.
             * @param text
             * The text to look for.
             * @param startPage
             * The page on which to start the search.
             * @param isCaseSensitive
             * Set to `true` to ignore whether a letter is uppercase or lowercase.
             * @param isWrappingEnabled
             * Enable continuing search at the other end of the document if one end is reached.
             * @param isRegex
             * Interpret {@link PdfViewing.Pdf.Document.searchText text} as a regular expression according to ECMAScript Regular Expression grammar.
             * @returns
             * The returned {@link PdfViewing.Pdf.Content.TextSearchIterator } is starting the search at the top of the given page.
             *
             * @throws {@link PdfViewing.ArgumentError} if an empty string is given as a search term
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            searchText(text, startPage, isCaseSensitive, isWrappingEnabled, isRegex) {
                if (typeof text !== 'string')
                    throw new PdfViewing.ArgumentError("Argument 'text' must be of type string and must not be null or undefined.");
                if (typeof startPage !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'startPage' must be of type number and must not be null or undefined.");
                if (typeof isCaseSensitive !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'isCaseSensitive' must be of type boolean and must not be null or undefined.");
                if (typeof isWrappingEnabled !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'isWrappingEnabled' must be of type boolean and must not be null or undefined.");
                if (typeof isRegex !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'isRegex' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingPdfDocumentSearchText(this.handle, text, startPage, isCaseSensitive, isWrappingEnabled, isRegex);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.Content.TextSearchIterator.createDynamicObject(retVal);
            }
            /**
             *
             * Create a new {@link PdfViewing.Pdf.Annotations.Annotation } and add it to the page
             * specified in the given {@link PdfViewing.Pdf.Document.createAnnotation annotation}.
             * @param annotation
             * @returns newly created promise for further asynchronous processing.
             *
             * @throws {@link PdfViewing.UpdateFailedError} The PDF file could not be updated.
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.LicenseError} The license is not valid for the editing feature.
             * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Document.createAnnotation annotation} argument is `null`
             * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Document.createAnnotation annotation} is not placed on a page
             * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Document.createAnnotation annotation} is added twice to the document
             */
            createAnnotation(annotation) {
                if (!(annotation instanceof PdfViewing.Pdf.Annotations.Annotation))
                    throw new PdfViewing.ArgumentError("Argument 'annotation' must be of type PdfViewing.Pdf.Annotations.Annotation and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentCreateAnnotation(thisHandle.handle, { thisHandle, resolved, rejected }, annotation.handle))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            createAnnotationCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (!retVal)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved();
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Delete an existing {@link PdfViewing.Pdf.Annotations.Annotation } from the document.
             * @param annotation
             * @returns newly created promise for further asynchronous processing.
             *
             * @throws {@link PdfViewing.UpdateFailedError} The PDF file could not be updated
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.LicenseError} The license is not valid for the editing feature.
             * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Document.deleteAnnotation annotation} argument is `null`
             * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Document.deleteAnnotation annotation} had already been deleted
             */
            deleteAnnotation(annotation) {
                if (!(annotation instanceof PdfViewing.Pdf.Annotations.Annotation))
                    throw new PdfViewing.ArgumentError("Argument 'annotation' must be of type PdfViewing.Pdf.Annotations.Annotation and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentDeleteAnnotation(thisHandle.handle, { thisHandle, resolved, rejected }, annotation.handle))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            deleteAnnotationCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (!retVal)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved();
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Edit an existing {@link PdfViewing.Pdf.Annotations.Annotation } that is attached to the document.
             * @param annotation
             * @returns newly created promise for further asynchronous processing.
             *
             * @throws {@link PdfViewing.UpdateFailedError} The PDF file could not be updated
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.LicenseError} The license is not valid for the editing feature.
             * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Document.editAnnotation annotation} argument is `null`
             * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Document.editAnnotation annotation} was moved to illegal page
             * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Document.editAnnotation annotation} has been deleted from page
             */
            editAnnotation(annotation) {
                if (!(annotation instanceof PdfViewing.Pdf.Annotations.Annotation))
                    throw new PdfViewing.ArgumentError("Argument 'annotation' must be of type PdfViewing.Pdf.Annotations.Annotation and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentEditAnnotation(thisHandle.handle, { thisHandle, resolved, rejected }, annotation.handle))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            editAnnotationCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (!retVal)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved();
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Get a list of {@link PdfViewing.Pdf.Annotations.Annotation }s associated with the document
             * and placed on page {@link PdfViewing.Pdf.Document.getAnnotations pageNumber}.
             * This list is only updated after the asynchronous operations that modify annotations
             * ({@link PdfViewing.Pdf.Document.createAnnotation }, {@link PdfViewing.Pdf.Document.deleteAnnotation } and {@link PdfViewing.Pdf.Document.editAnnotation })
             * have finished.
             * @param pageNumber
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getAnnotations(pageNumber) {
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentGetAnnotations(thisHandle.handle, { thisHandle, resolved, rejected }, pageNumber))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            getAnnotationsCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved(PdfViewing.Pdf.Annotations.AnnotationList.createDynamicObject(retVal));
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Get a list of {@link PdfViewing.Pdf.Content.TextFragment }s that are placed on page {@link PdfViewing.Pdf.Document.getTextFragments pageNumber}.
             * @param pageNumber
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getTextFragments(pageNumber) {
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentGetTextFragments(thisHandle.handle, { thisHandle, resolved, rejected }, pageNumber))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            getTextFragmentsCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved(PdfViewing.Pdf.Content.TextFragmentList.createDynamicObject(retVal));
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Copy the page of another {@link PdfViewing.Pdf.Document } to this document.
             * This copy is not yet visible anywhere but can be used to create a {@link PdfViewing.Pdf.Annotations.CustomImageStamp } using {@link PdfViewing.Pdf.Annotations.CustomImageStamp.create } , which will add said page as an annotation.
             * @param otherDocument
             * The document where the page is copied from
             * @param pageNumber
             * The number of the page to be copied
             * @returns
             * An identifier which can be used to create annotations on this document using {@link PdfViewing.Pdf.Annotations.CustomImageStamp.create }
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            registerPdfPage(otherDocument, pageNumber) {
                if (!(otherDocument instanceof PdfViewing.Pdf.Document))
                    throw new PdfViewing.ArgumentError("Argument 'otherDocument' must be of type PdfViewing.Pdf.Document and must not be null or undefined.");
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentRegisterPdfPage(thisHandle.handle, { thisHandle, resolved, rejected }, otherDocument.handle, pageNumber))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            registerPdfPageCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage);
                if (error === null) {
                    context.resolved(retVal);
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Get a List of {@link PdfViewing.Pdf.Navigation.OutlineItem }s attached to the document.
             * @param parentOutline
             * Insert `null` to get top level outline item of document.
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getOutlines(parentOutline) {
                if (parentOutline !== null && parentOutline !== undefined && !(parentOutline instanceof PdfViewing.Pdf.Navigation.OutlineItem))
                    throw new PdfViewing.ArgumentError("Argument 'parentOutline' must be of type PdfViewing.Pdf.Navigation.OutlineItem or can be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentGetOutlines(thisHandle.handle, { thisHandle, resolved, rejected }, (parentOutline !== null && parentOutline !== undefined) ? parentOutline.handle : 0))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            getOutlinesCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved(PdfViewing.Pdf.Navigation.OutlineItemList.createDynamicObject(retVal));
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Render page {@link PdfViewing.Pdf.Document.renderPage pageNumber} with a specific rotation into a rectangle of a specific size.
             * The returned image will always use the exact dimensions passed by parameters {@link PdfViewing.Pdf.Document.renderPage width} and {@link PdfViewing.Pdf.Document.renderPage height} even if the aspect ratio differs from the rendred page.
             * @param pageNumber
             * @param width
             * @param height
             * @param rotate
             * Rotate page in degrees.
             * @param renderOptions
             * Options used for rendering the page, set `null` to use default options
             * @returns
             *
             * @throws {@link PdfViewing.ArgumentError} if the provided page does not exist
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            renderPage(pageNumber, width, height, rotate, renderOptions = null) {
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                if (typeof width !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'width' must be of type number and must not be null or undefined.");
                if (typeof height !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'height' must be of type number and must not be null or undefined.");
                if (typeof rotate !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'rotate' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                if (renderOptions !== null && renderOptions !== undefined && !(renderOptions instanceof PdfViewing.Pdf.RenderOptions))
                    throw new PdfViewing.ArgumentError("Argument 'renderOptions' must be of type PdfViewing.Pdf.RenderOptions or can be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentRenderPage(thisHandle.handle, { thisHandle, resolved, rejected }, pageNumber, width, height, rotate, (renderOptions !== null && renderOptions !== undefined) ? renderOptions.handle : 0))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            renderPageCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved(PdfViewing.Pdf.Content.Image.createDynamicObject(retVal));
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Get Size of a pdf page.
             * If the page is not loaded yet the returned value is just a guess based on the already loaded pages
             * or `null` depending on the value of {@link PdfViewing.Pdf.Document.getPageSize guess}.
             * @param page
             * @param guess
             * Configure to get a best guess if the size has not been loaded yet
             * @returns
             */
            getPageSize(page, guess) {
                if (typeof page !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'page' must be of type number and must not be null or undefined.");
                if (typeof guess !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'guess' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingPdfDocumentGetPageSize(this.handle, page, guess);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal !== null ? new PdfViewing.Pdf.Geometry.Real.Size(retVal.width, retVal.height) : null;
            }
            /**
             *
             * Get the size in Pdf Coordinates of page {@link PdfViewing.Pdf.Document.getPagePdfSize pageNumber}
             * @param pageNumber
             * @returns
             *
             * @throws {@link PdfViewing.ArgumentError} if the provided page does not exist
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getPagePdfSize(pageNumber) {
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentGetPagePdfSize(thisHandle.handle, { thisHandle, resolved, rejected }, pageNumber))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            getPagePdfSizeCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === null)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved(new PdfViewing.Pdf.Geometry.Real.Size(retVal.width, retVal.height));
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Get the aspect ratio (width divided by height) of a given {@link PdfViewing.Pdf.Document.getTextStampAspectRatio stampText}.
             * This value can be used as preparation step to compute the exact bounding box
             * for creating a {@link PdfViewing.Pdf.Annotations.CustomTextStamp }.
             * @param stampText
             * The text that will be used for creating a {@link PdfViewing.Pdf.Annotations.CustomTextStamp }
             * @returns
             * The ratio of height divided by width of the given text.
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getTextStampAspectRatio(stampText) {
                if (typeof stampText !== 'string')
                    throw new PdfViewing.ArgumentError("Argument 'stampText' must be of type string and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentGetTextStampAspectRatio(thisHandle.handle, { thisHandle, resolved, rejected }, stampText))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            getTextStampAspectRatioCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage);
                if (error === null) {
                    context.resolved(retVal);
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Register an image in the document as a resource. This resource can then later be used to add e.g. an {@link PdfViewing.Pdf.Annotations.CustomImageStamp }.
             * @param image
             * @returns
             * ID of the registered image.
             * This ID is needed by {@link PdfViewing.Pdf.Annotations.CustomImageStamp.create } to link the image resource to the stamp annotation.
             *
             * @throws {@link PdfViewing.ArgumentError} if the provided {@link PdfViewing.Pdf.Document.registerImage image} is invalid or the format is not supported
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            registerImage(image) {
                if (!(image instanceof Uint8Array))
                    throw new PdfViewing.ArgumentError("Argument 'image' must be of type Uint8Array and must not be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentRegisterImage(thisHandle.handle, { thisHandle, resolved, rejected }, image))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            registerImageCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage);
                if (error === null) {
                    context.resolved(retVal);
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Register an image in the document as a resource.
             * This resource can then later be used,
             * e.g. to add an {@link PdfViewing.Pdf.Annotations.CustomImageStamp }.
             * @param imageUri
             * @param authorization
             * @returns
             * ID of the registered image.
             * This ID is needed by {@link PdfViewing.Pdf.Annotations.CustomImageStamp.create } to link the image resource to the stamp annotation.
             *
             * @throws {@link PdfViewing.ArgumentError} if the provided {@link PdfViewing.Pdf.Document.registerImageUri imageUri} is invalid or the format is not supported
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            registerImageUri(imageUri, authorization) {
                if (typeof imageUri !== 'string')
                    throw new PdfViewing.ArgumentError("Argument 'imageUri' must be of type string and must not be null or undefined.");
                if (authorization !== null && authorization !== undefined && (typeof authorization !== 'string'))
                    throw new PdfViewing.ArgumentError("Argument 'authorization' must be of type string or can be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentRegisterImageUri(thisHandle.handle, { thisHandle, resolved, rejected }, imageUri, authorization))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            registerImageUriCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage);
                if (error === null) {
                    context.resolved(retVal);
                }
                else
                    context.rejected(error);
            }
            /**
             *
             * Create a new document by merging this document to the input document.
             * Pages, optional content, embedded files, and outlines are appended.
             * Viewing options and metadata from the current document are used.
             * @param other
             * Other document.
             * @param mergeOptions
             * Document merge options.
             * @returns
             * A binary buffer containing the new document.
             *
             * @throws {@link PdfViewing.ArgumentError} if the provided document {@link PdfViewing.Pdf.Document.mergeWith other} is invalid
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            mergeWith(other, mergeOptions = null) {
                if (!(other instanceof PdfViewing.Pdf.Document))
                    throw new PdfViewing.ArgumentError("Argument 'other' must be of type PdfViewing.Pdf.Document and must not be null or undefined.");
                if (mergeOptions !== null && mergeOptions !== undefined && !(mergeOptions instanceof PdfViewing.IO.MergeOptions))
                    throw new PdfViewing.ArgumentError("Argument 'mergeOptions' must be of type PdfViewing.IO.MergeOptions or can be null or undefined.");
                var thisHandle = this;
                return new Promise(function (resolved, rejected) {
                    if (!Module.ViewingPdfDocumentMergeWith(thisHandle.handle, { thisHandle, resolved, rejected }, other.handle, (mergeOptions !== null && mergeOptions !== undefined) ? mergeOptions.handle : 0))
                        rejected(Module.ViewingGetLastErrorMessage());
                });
            }
            mergeWithCallback(context, retVal, errorCode, errorMessage) {
                let error = null;
                if (retVal === 0)
                    error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                if (error === null) {
                    context.resolved(PdfViewing.Pdf.Content.BinaryBuffer.createDynamicObject(retVal));
                }
                else
                    context.rejected(error);
            }
            /**
            * The destination that the creator of the PDF recommends to use when opening a view of the PDF.
            * This destination can be passed in a {@link PdfViewing.Pdf.ViewOptions } object to {@link PdfViewing.Pdf.View.create } for initializing the view,
            * thus respecting the creator's recommendation.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get initialDestination() {
                let retVal = Module.ViewingPdfDocumentGetInitialDestination(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal !== 0 ? PdfViewing.Pdf.Navigation.Destination.createDynamicObject(retVal) : null;
            }
            /**
            * Tells whether any modifications have been made that would be lost without saving, such as editing annotations or rotating pages.
            * Value is 0 after opening and will reset to 0 when saving the document.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get hasChanges() {
                let retVal = Module.ViewingPdfDocumentGetHasChanges(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Return the number of pages in the document.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get pageCount() {
                let retVal = Module.ViewingPdfDocumentGetPageCount(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The pagelayoutmode that the creator of the PDF has suggested to use when opening a view of the PDF.
            * Can be passed in a {@link PdfViewing.Pdf.ViewOptions } object to method {@link PdfViewing.Pdf.View.create } for initializing the view.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get initialPageLayoutMode() {
                let retVal = Module.ViewingPdfDocumentGetInitialPageLayoutMode(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            *
            * Return the claimed document compliance.
            *
            * Note: Claimed compliance does not guarantee conformance to the standard.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get compliance() {
                let retVal = Module.ViewingPdfDocumentGetCompliance(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            *
            */
            get pages() {
                let retVal = Module.ViewingPdfDocumentGetPages(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.PageList.createDynamicObject(retVal);
            }
        }
        Pdf.Document = Document;
        /**
         *
         * Describes the current view of the viewport on part of the document.
         * All properties and methods are consistent with what is actually visible, i.e. text fragments on a point can only be detected if said text is currently visible.
         */
        class View extends Internal.NativeObject {
            /**
             *
             * @param document
             * The document this view is displaying.
             * @param ignoreEmbeddedPreferences
             * When set ignore any opening preferences or actions that are embedded in the PDF.
             *
             * @deprecated Deprecated in Version 3.10. Use static method View.Create instead.
             */
            constructor(document, ignoreEmbeddedPreferences) {
                if (arguments[0] && typeof arguments[0].__handle === `number`)
                    super(arguments[0].__handle);
                else {
                    if (!(document instanceof PdfViewing.Pdf.Document))
                        throw new PdfViewing.ArgumentError("Argument 'document' must be of type PdfViewing.Pdf.Document and must not be null or undefined.");
                    if (typeof ignoreEmbeddedPreferences !== 'boolean')
                        throw new PdfViewing.ArgumentError("Argument 'ignoreEmbeddedPreferences' must be of type boolean and must not be null or undefined.");
                    super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNewView(document.handle, ignoreEmbeddedPreferences)));
                }
                this.eventListeners = new Map();
            }
            /**
             * @event
             */
            addEventListener(type, listener) {
                if (typeof listener !== 'function')
                    throw new PdfViewing.ArgumentError("Argument 'listener' must be a function.");
                var eventObj;
                if (this.eventListeners.has(type)) {
                    if (!this.eventListeners.get(type).has(listener)) {
                        if (type === "viewUpdated") {
                            eventObj = new ViewUpdatedNativeClass(listener);
                            let context = Module.ViewingPdfViewAddViewUpdatedHandler(this.handle, eventObj);
                            if (context == 0)
                                Internal.NativeBase.throwLastError();
                            else
                                eventObj.context = context;
                            this.eventListeners.get(type).set(listener, eventObj);
                        }
                    }
                    if (!this.eventListeners.get(type).has(listener)) {
                        if (type === "imageCreated") {
                            eventObj = new ImageCreatedNativeClass(listener);
                            let context = Module.ViewingPdfViewAddImageCreatedHandler(this.handle, eventObj);
                            if (context == 0)
                                Internal.NativeBase.throwLastError();
                            else
                                eventObj.context = context;
                            this.eventListeners.get(type).set(listener, eventObj);
                        }
                    }
                    if (!this.eventListeners.get(type).has(listener)) {
                        if (type === "imageRemovedFromCache") {
                            eventObj = new ImageRemovedFromCacheNativeClass(listener);
                            let context = Module.ViewingPdfViewAddImageRemovedFromCacheHandler(this.handle, eventObj);
                            if (context == 0)
                                Internal.NativeBase.throwLastError();
                            else
                                eventObj.context = context;
                            this.eventListeners.get(type).set(listener, eventObj);
                        }
                    }
                }
                else {
                    if (type === "viewUpdated") {
                        eventObj = new ViewUpdatedNativeClass(listener);
                        let context = Module.ViewingPdfViewAddViewUpdatedHandler(this.handle, eventObj);
                        if (context == 0)
                            Internal.NativeBase.throwLastError();
                        else
                            eventObj.context = context;
                        let mapItem = new Map();
                        mapItem.set(listener, eventObj);
                        this.eventListeners.set(type, mapItem);
                    }
                    if (type === "imageCreated") {
                        eventObj = new ImageCreatedNativeClass(listener);
                        let context = Module.ViewingPdfViewAddImageCreatedHandler(this.handle, eventObj);
                        if (context == 0)
                            Internal.NativeBase.throwLastError();
                        else
                            eventObj.context = context;
                        let mapItem = new Map();
                        mapItem.set(listener, eventObj);
                        this.eventListeners.set(type, mapItem);
                    }
                    if (type === "imageRemovedFromCache") {
                        eventObj = new ImageRemovedFromCacheNativeClass(listener);
                        let context = Module.ViewingPdfViewAddImageRemovedFromCacheHandler(this.handle, eventObj);
                        if (context == 0)
                            Internal.NativeBase.throwLastError();
                        else
                            eventObj.context = context;
                        let mapItem = new Map();
                        mapItem.set(listener, eventObj);
                        this.eventListeners.set(type, mapItem);
                    }
                }
            }
            removeEventListener(type, listener) {
                if (this.eventListeners.has(type)) {
                    if (type === "viewUpdated") {
                        let listeners = this.eventListeners.get(type);
                        if (listeners.has(listener)) {
                            let eventObj = listeners.get(listener);
                            try {
                                if (!Module.ViewingPdfViewRemoveViewUpdatedHandler(this.handle, eventObj === null || eventObj === void 0 ? void 0 : eventObj.context))
                                    Internal.NativeBase.throwLastError();
                            }
                            catch (err) {
                                if (err instanceof NotFoundError)
                                    throw err;
                            }
                            listeners.delete(listener);
                            if (listeners.size === 0)
                                this.eventListeners.delete("viewUpdated");
                        }
                    }
                    if (type === "imageCreated") {
                        let listeners = this.eventListeners.get(type);
                        if (listeners.has(listener)) {
                            let eventObj = listeners.get(listener);
                            try {
                                if (!Module.ViewingPdfViewRemoveImageCreatedHandler(this.handle, eventObj === null || eventObj === void 0 ? void 0 : eventObj.context))
                                    Internal.NativeBase.throwLastError();
                            }
                            catch (err) {
                                if (err instanceof NotFoundError)
                                    throw err;
                            }
                            listeners.delete(listener);
                            if (listeners.size === 0)
                                this.eventListeners.delete("imageCreated");
                        }
                    }
                    if (type === "imageRemovedFromCache") {
                        let listeners = this.eventListeners.get(type);
                        if (listeners.has(listener)) {
                            let eventObj = listeners.get(listener);
                            try {
                                if (!Module.ViewingPdfViewRemoveImageRemovedFromCacheHandler(this.handle, eventObj === null || eventObj === void 0 ? void 0 : eventObj.context))
                                    Internal.NativeBase.throwLastError();
                            }
                            catch (err) {
                                if (err instanceof NotFoundError)
                                    throw err;
                            }
                            listeners.delete(listener);
                            if (listeners.size === 0)
                                this.eventListeners.delete("imageRemovedFromCache");
                        }
                    }
                }
            }
            /** @internal */
            static createDynamicObject(handle) {
                return new View({ __handle: handle });
            }
            /**
             * Close the object
             *
             * Release all native resources associated with the object.
             */
            close() {
                if (!Module.ViewingPdfViewClose(this.handle))
                    Internal.NativeBase.throwLastError();
            }
            /**
             *
             * @param document
             * The document this view is displaying.
             * @param renderOptions
             * Options used for rendering the page, set `null` to use default options.
             * @param viewOptions
             * Options used for the view, set `null` to use default options.
             * @returns
             */
            static create(document, renderOptions, viewOptions) {
                if (!(document instanceof PdfViewing.Pdf.Document))
                    throw new PdfViewing.ArgumentError("Argument 'document' must be of type PdfViewing.Pdf.Document and must not be null or undefined.");
                if (renderOptions !== null && renderOptions !== undefined && !(renderOptions instanceof PdfViewing.Pdf.RenderOptions))
                    throw new PdfViewing.ArgumentError("Argument 'renderOptions' must be of type PdfViewing.Pdf.RenderOptions or can be null or undefined.");
                if (viewOptions !== null && viewOptions !== undefined && !(viewOptions instanceof PdfViewing.Pdf.ViewOptions))
                    throw new PdfViewing.ArgumentError("Argument 'viewOptions' must be of type PdfViewing.Pdf.ViewOptions or can be null or undefined.");
                let retVal = Module.ViewingPdfViewCreate(document.handle, (renderOptions !== null && renderOptions !== undefined) ? renderOptions.handle : 0, (viewOptions !== null && viewOptions !== undefined) ? viewOptions.handle : 0);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.View.createDynamicObject(retVal);
            }
            /**
             *
             * Stops sending `ViewUpdated` events.
             * Internally user interactions and rendering is still performed normally.
             * Resume using {@link PdfViewing.Pdf.View.resumeDrawing }.
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            suspendDrawing() {
                let retVal = Module.ViewingPdfViewSuspendDrawing(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
             *
             * Resume sending `ViewUpdated` events.
             * Will always trigger a single `ViewUpdated` event, containing all updates since suspending.
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            resumeDrawing() {
                let retVal = Module.ViewingPdfViewResumeDrawing(this.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
             *
             * Navigate the viewport to the given destination.
             * @param destination
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.ArgumentError} if the provided {@link PdfViewing.Pdf.View.goToDestination destination} is invalid
             */
            goToDestination(destination) {
                if (!(destination instanceof PdfViewing.Pdf.Navigation.Destination))
                    throw new PdfViewing.ArgumentError("Argument 'destination' must be of type PdfViewing.Pdf.Navigation.Destination and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGoToDestination(this.handle, destination.handle);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
             *
             * Navigate the viewport to show the given rectangle by scrolling and zooming as little as possible.
             * @param rectangle
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.ArgumentError} if the provided {@link PdfViewing.Pdf.View.goToRectangle rectangle} is invalid
             */
            goToRectangle(rectangle) {
                if (typeof rectangle !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'rectangle' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGoToRectangle(this.handle, rectangle);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
             *
             * Returns a list of {@link PdfViewing.Pdf.Content.TextFragment } at point.
             * @param point
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.NotFoundError} The given {@link PdfViewing.Pdf.View.getTextFragmentsOnPoint point} is on no page.
             * @throws {@link PdfViewing.FatalError} The page is not in cache.
             */
            getTextFragmentsOnPoint(point) {
                if (typeof point !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'point' must be of type PdfViewing.Pdf.Geometry.Integer.Point and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGetTextFragmentsOnPoint(this.handle, point);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.Content.TextFragmentList.createDynamicObject(retVal);
            }
            /**
             *
             * Returns a list of all {@link PdfViewing.Pdf.Content.TextFragment }s on a given page.
             * @param pageNumber
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.FatalError} The page is not in cache.
             */
            getTextFragments(pageNumber) {
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGetTextFragments(this.handle, pageNumber);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.Content.TextFragmentList.createDynamicObject(retVal);
            }
            /**
             *
             * Returns a textselection of all text within a rectangle.
             * Only text that is already loaded (and thus rendered) is selected.
             * Only the text on the rectangle's `PageNumber` field page is selected, even if extending the rectangle beyond the page boundaries.
             * The rectangle is defined by two corner points which may be on different pages.
             * @param startPoint
             * @param endPoint
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getRectangularTextSelection(startPoint, endPoint) {
                if (typeof startPoint !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'startPoint' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                if (typeof endPoint !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'endPoint' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGetRectangularTextSelection(this.handle, startPoint, endPoint);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.Content.TextSelection.createDynamicObject(retVal);
            }
            /**
             *
             * Returns a textselection in between `startPoint` and `endPoint`.
             * Only text that is already loaded (and thus rendered) is selected.
             * @param startPoint
             * @param endPoint
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getTextSelection(startPoint, endPoint) {
                if (typeof startPoint !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'startPoint' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                if (typeof endPoint !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'endPoint' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGetTextSelection(this.handle, startPoint, endPoint);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal !== 0 ? PdfViewing.Pdf.Content.TextSelection.createDynamicObject(retVal) : null;
            }
            /**
             *
             * Returns a {@link PdfViewing.Pdf.Content.TextSelection? } of the word at the given location.
             * If multiple word are at this location, the smallest one is returned.
             * @param point
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.NotFoundError} if there are no words at {@link PdfViewing.Pdf.View.getWordOnPoint point}
             */
            getWordOnPoint(point) {
                if (typeof point !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'point' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGetWordOnPoint(this.handle, point);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal !== 0 ? PdfViewing.Pdf.Content.TextSelection.createDynamicObject(retVal) : null;
            }
            /**
             *
             * Returns a list of {@link PdfViewing.Pdf.Annotations.Annotation }s at point.
             * Returns annotations in ascending z-order, thus the most visible annotation is the last element of the returned list.
             * @param point
             * @param onlySelectable
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getAnnotationsOnPoint(point, onlySelectable) {
                if (typeof point !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'point' must be of type PdfViewing.Pdf.Geometry.Integer.Point and must not be null or undefined.");
                if (typeof onlySelectable !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'onlySelectable' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGetAnnotationsOnPoint(this.handle, point, onlySelectable);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.Annotations.AnnotationList.createDynamicObject(retVal);
            }
            /**
             *
             * Get the rendering information to display the currently visible viewport.
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getRenderedResults() {
                let retVal = Module.ViewingPdfViewGetRenderedResults(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError(false);
                return PdfViewing.Pdf.Content.RenderResults.createDynamicObject(retVal);
            }
            /**
             *
             * Transform a point from viewport coordinates (top-left origin in pixels on viewport) to on-page coordinates (bottom-left origin in dots on a page).
             * If the given point is not on any page, then the closest page will be used as a reference for the returned point.
             * @param pointOnViewport
             * @param snapToPage
             * If the transformed point is not on any page, snap it to the border of the closest page.
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            transformPointFromViewportToPage(pointOnViewport, snapToPage) {
                if (typeof pointOnViewport !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'pointOnViewport' must be of type PdfViewing.Pdf.Geometry.Integer.Point and must not be null or undefined.");
                if (typeof snapToPage !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'snapToPage' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewTransformPointFromViewportToPage(this.handle, pointOnViewport, snapToPage);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Real.PointOnPage(retVal.pageNumber, retVal.x, retVal.y);
            }
            /**
             *
             * Transform a point from viewport coordinates (top-left origin in pixels on viewport) to on-page coordinates (bottom-left origin in dots on a page).
             * If the given point is not on any page, then the closest page will be used as a reference for the returned point.
             * @param pointOnViewport
             * @param pageNumber
             * @param snapToPage
             * If the transformed point is not on any page, snap it to the border of the closest page.
             * @returns
             * Return the point in relation to the specified page.
             *
             * @throws {@link PdfViewing.ArgumentError} if the provided {@link PdfViewing.Pdf.View.transformPointFromViewportToSpecificPage pageNumber} does not exist
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            transformPointFromViewportToSpecificPage(pointOnViewport, pageNumber, snapToPage) {
                if (typeof pointOnViewport !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'pointOnViewport' must be of type PdfViewing.Pdf.Geometry.Integer.Point and must not be null or undefined.");
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                if (typeof snapToPage !== 'boolean')
                    throw new PdfViewing.ArgumentError("Argument 'snapToPage' must be of type boolean and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewTransformPointFromViewportToSpecificPage(this.handle, pointOnViewport, pageNumber, snapToPage);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Real.PointOnPage(retVal.pageNumber, retVal.x, retVal.y);
            }
            /**
             *
             * Transform a rectangle from viewport coordinates (top-left origin in pixels on viewport) to on-page coordinates (bottom-left origin in dots on a page) on a specific page.
             * @param rectangleOnViewport
             * @param pageNumber
             * @returns
             *
             * @throws {@link PdfViewing.ArgumentError} if the provided {@link PdfViewing.Pdf.View.transformRectangleFromViewportToSpecificPage pageNumber} does not exist
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            transformRectangleFromViewportToSpecificPage(rectangleOnViewport, pageNumber) {
                if (typeof rectangleOnViewport !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'rectangleOnViewport' must be of type PdfViewing.Pdf.Geometry.Integer.Rectangle and must not be null or undefined.");
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewTransformRectangleFromViewportToSpecificPage(this.handle, rectangleOnViewport, pageNumber);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Real.RectangleOnPage(retVal.pageNumber, retVal.x, retVal.y, retVal.width, retVal.height);
            }
            /**
             *
             * Transform a point from on-page coordinates (bottom-left origin in dots on a page) to viewport coordinates (top-left origin in pixels on viewport).
             * @param pointOnPage
             * @returns
             *
             * @throws {@link PdfViewing.ArgumentError} if {@link PdfViewing.Pdf.View.transformPointFromPageToViewport pointOnPage} is not on any page
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            transformPointFromPageToViewport(pointOnPage) {
                if (typeof pointOnPage !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'pointOnPage' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewTransformPointFromPageToViewport(this.handle, pointOnPage);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Integer.Point(retVal.x, retVal.y);
            }
            /**
             *
             * Transform a rectangle from on-page coordinates (bottom-left origin in dots on a page) to viewport coordinates (top-left origin in pixels on viewport).
             * @param rectangleOnPage
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             * @throws {@link PdfViewing.ArgumentError} if {@link PdfViewing.Pdf.View.transformRectangleFromPageToViewport rectangleOnPage} is not on any page
             */
            transformRectangleFromPageToViewport(rectangleOnPage) {
                if (typeof rectangleOnPage !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'rectangleOnPage' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewTransformRectangleFromPageToViewport(this.handle, rectangleOnPage);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Integer.Rectangle(retVal.x, retVal.y, retVal.width, retVal.height);
            }
            /**
             *
             * Get the rectangle of a page in viewport coordinates (top-left origin in pixels on viewport).
             * If the document is newly opened this rectangle might be a guess, any updates to the loaded pagerectangles is reported in the `ViewUpdated` event with parameter `pageSizeUpdated`.
             * @param pageNumber
             * @returns
             *
             * @throws {@link PdfViewing.ArgumentError} if page with {@link PdfViewing.Pdf.View.getPageRectangleOnViewport pageNumber} is not on viewport
             * @throws {@link PdfViewing.ArgumentError} if the provided {@link PdfViewing.Pdf.View.getPageRectangleOnViewport pageNumber} does not exist
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            getPageRectangleOnViewport(pageNumber) {
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewGetPageRectangleOnViewport(this.handle, pageNumber);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Integer.Rectangle(retVal.x, retVal.y, retVal.width, retVal.height);
            }
            /**
             *
             * Transform a length from on-page coordinates (dots) to viewport coordinates (pixels).
             * @param pdfLength
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            transformPdfLengthToViewportLength(pdfLength) {
                if (typeof pdfLength !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pdfLength' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewTransformPdfLengthToViewportLength(this.handle, pdfLength);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
             *
             * Transform a length from viewport coordinates (pixels) to on-page coordinates (dots).
             * @param screenLength
             * @returns
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            transformViewportLengthToPdfLength(screenLength) {
                if (typeof screenLength !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'screenLength' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewTransformViewportLengthToPdfLength(this.handle, screenLength);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
             *
             * Set a new zoomfactor, keeping point {@link PdfViewing.Pdf.View.zoomOnLocation location} at a constant location on viewport.
             * @param zoom
             * @param location
             *
             * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
             */
            zoomOnLocation(zoom, location) {
                if (typeof zoom !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'zoom' must be of type number and must not be null or undefined.");
                if (typeof location !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'location' must be of type PdfViewing.Pdf.Geometry.Integer.Point and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewZoomOnLocation(this.handle, zoom, location);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            *
            * The currently most visible page.
            *
            * When getting, returns the page which covers most area on the view port.
            * If multiple pages cover the same amount of space,
            * the one with smaller page number is returned.
            *
            * When setting this property,
            * the view port moves to make this page the most visible page,
            * trying to align it to the top of the view port.
            *
            * Note: There are some cases in which a page cannot be made most visible.
            * Therefore setting this property to a certain value does not guarantee that the same value is returned when getting.
            * (Most notable cases are PageLayoutModes
            * {@link PdfViewing.Pdf.Navigation.PageLayoutMode.TwoColumnLeft },
            * {@link PdfViewing.Pdf.Navigation.PageLayoutMode.TwoColumnRight },
            * {@link PdfViewing.Pdf.Navigation.PageLayoutMode.TwoPageLeft },
            * {@link PdfViewing.Pdf.Navigation.PageLayoutMode.TwoPageRight },
            * and whenever viewing the end of a document with low {@link PdfViewing.Pdf.View.zoom }).
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get pageNumber() {
                let retVal = Module.ViewingPdfViewGetPageNumber(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            *
            * The currently most visible page.
            *
            * When getting, returns the page which covers most area on the view port.
            * If multiple pages cover the same amount of space,
            * the one with smaller page number is returned.
            *
            * When setting this property,
            * the view port moves to make this page the most visible page,
            * trying to align it to the top of the view port.
            *
            * Note: There are some cases in which a page cannot be made most visible.
            * Therefore setting this property to a certain value does not guarantee that the same value is returned when getting.
            * (Most notable cases are PageLayoutModes
            * {@link PdfViewing.Pdf.Navigation.PageLayoutMode.TwoColumnLeft },
            * {@link PdfViewing.Pdf.Navigation.PageLayoutMode.TwoColumnRight },
            * {@link PdfViewing.Pdf.Navigation.PageLayoutMode.TwoPageLeft },
            * {@link PdfViewing.Pdf.Navigation.PageLayoutMode.TwoPageRight },
            * and whenever viewing the end of a document with low {@link PdfViewing.Pdf.View.zoom }).
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            * @throws {@link PdfViewing.ArgumentError} if the provided page number does not exist
            */
            set pageNumber(pageNumber) {
                if (typeof pageNumber !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetPageNumber(this.handle, pageNumber);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The first currently visible page.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get firstVisiblePage() {
                let retVal = Module.ViewingPdfViewGetFirstVisiblePage(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The last currently visible page.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get lastVisiblePage() {
                let retVal = Module.ViewingPdfViewGetLastVisiblePage(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The current zoom factor.
            * Default is 1.0.
            * Excessive zoom factors (below 0.1 or above 10.0) are not recommended.
            * Using {@link PdfViewing.Pdf.View.zoomOnLocation } can be used to get finer control on what the viewport is focused on during zooming.
            * If setting zoom directly, top-left of the viewport is used as a focus point.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get zoom() {
                let retVal = Module.ViewingPdfViewGetZoom(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The current zoom factor.
            * Default is 1.0.
            * Excessive zoom factors (below 0.1 or above 10.0) are not recommended.
            * Using {@link PdfViewing.Pdf.View.zoomOnLocation } can be used to get finer control on what the viewport is focused on during zooming.
            * If setting zoom directly, top-left of the viewport is used as a focus point.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set zoom(zoom) {
                if (typeof zoom !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'zoom' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetZoom(this.handle, zoom);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The current x/y coordinates at which the viewport is located.
            * Determines scrollbar location in relation to scrollbar length,
            * which is given by {@link PdfViewing.Pdf.View.scrollMaxPosition }.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get scrollPosition() {
                let retVal = Module.ViewingPdfViewGetScrollPosition(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Integer.ScrollPosition(retVal.x, retVal.y);
            }
            /**
            * The current x/y coordinates at which the viewport is located.
            * Determines scrollbar location in relation to scrollbar length,
            * which is given by {@link PdfViewing.Pdf.View.scrollMaxPosition }.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set scrollPosition(scrollPosition) {
                if (typeof scrollPosition !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'scrollPosition' must be of type PdfViewing.Pdf.Geometry.Integer.ScrollPosition and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetScrollPosition(this.handle, scrollPosition);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The maximum x/y coordinates that can be scrolled to.
            * Determines scrollbar ranges.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get scrollMaxPosition() {
                let retVal = Module.ViewingPdfViewGetScrollMaxPosition(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Integer.ScrollPosition(retVal.x, retVal.y);
            }
            /**
            * Rotate all pages to a specific orientation.
            * Default is {@link PdfViewing.Pdf.Geometry.Rotation.NoRotation }
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get viewRotation() {
                let retVal = Module.ViewingPdfViewGetViewRotation(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * Rotate all pages to a specific orientation.
            * Default is {@link PdfViewing.Pdf.Geometry.Rotation.NoRotation }
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set viewRotation(viewRotation) {
                if (typeof viewRotation !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'viewRotation' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetViewRotation(this.handle, viewRotation);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The {@link PdfViewing.Pdf.Navigation.FitMode } used to fit the viewport onto the document.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get fitMode() {
                let retVal = Module.ViewingPdfViewGetFitMode(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The {@link PdfViewing.Pdf.Navigation.FitMode } used to fit the viewport onto the document.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set fitMode(fitMode) {
                if (typeof fitMode !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'fitMode' must be of type PdfViewing.Pdf.Navigation.FitMode and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetFitMode(this.handle, fitMode);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The {@link PdfViewing.Pdf.Navigation.PageLayoutMode } used to arrange pages on the viewport.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get pageLayoutMode() {
                let retVal = Module.ViewingPdfViewGetPageLayoutMode(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The {@link PdfViewing.Pdf.Navigation.PageLayoutMode } used to arrange pages on the viewport.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set pageLayoutMode(pageLayoutMode) {
                if (typeof pageLayoutMode !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'pageLayoutMode' must be of type PdfViewing.Pdf.Navigation.PageLayoutMode and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetPageLayoutMode(this.handle, pageLayoutMode);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The size of the border in pixels in between pages when rendered on viewport. Default: 10px.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get borderSize() {
                let retVal = Module.ViewingPdfViewGetBorderSize(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The size of the border in pixels in between pages when rendered on viewport. Default: 10px.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            * @throws {@link PdfViewing.ArgumentError} If the given value was smaller than 0
            */
            set borderSize(borderSize) {
                if (typeof borderSize !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'borderSize' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetBorderSize(this.handle, borderSize);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The size of the margin in pixels around the canvas. Default: 5px in all directions.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get canvasMargin() {
                let retVal = Module.ViewingPdfViewGetCanvasMargin(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Integer.Padding(retVal.left, retVal.right, retVal.top, retVal.bottom);
            }
            /**
            * The size of the margin in pixels around the canvas. Default: 5px in all directions.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            * @throws {@link PdfViewing.ArgumentError} If the given value was smaller than 0
            */
            set canvasMargin(canvasMargin) {
                if (typeof canvasMargin !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'canvasMargin' must be of type PdfViewing.Pdf.Geometry.Integer.Padding and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetCanvasMargin(this.handle, canvasMargin);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The Dots Per Inch of the used screen. Default `96.0`.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get screenDPI() {
                let retVal = Module.ViewingPdfViewGetScreenDPI(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The Dots Per Inch of the used screen. Default `96.0`.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set screenDPI(screenDPI) {
                if (typeof screenDPI !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'screenDPI' must be of type number and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetScreenDPI(this.handle, screenDPI);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The {@link PdfViewing.Pdf.Content.Byteorder } used for rendered images.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get byteorder() {
                let retVal = Module.ViewingPdfViewGetByteorder(this.handle);
                if (retVal === 0)
                    Internal.NativeBase.throwLastError();
                return retVal;
            }
            /**
            * The {@link PdfViewing.Pdf.Content.Byteorder } used for rendered images.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set byteorder(byteorder) {
                if (typeof byteorder !== 'number')
                    throw new PdfViewing.ArgumentError("Argument 'byteorder' must be of type PdfViewing.Pdf.Content.Byteorder and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetByteorder(this.handle, byteorder);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
            /**
            * The size of the viewport for this view.
            * Default: 720 x 480 pixels.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            get viewportSize() {
                let retVal = Module.ViewingPdfViewGetViewportSize(this.handle);
                if (retVal === null)
                    Internal.NativeBase.throwLastError(false);
                return new PdfViewing.Pdf.Geometry.Integer.Size(retVal.width, retVal.height);
            }
            /**
            * The size of the viewport for this view.
            * Default: 720 x 480 pixels.
            *
            * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
            */
            set viewportSize(viewportSize) {
                if (typeof viewportSize !== 'object')
                    throw new PdfViewing.ArgumentError("Argument 'viewportSize' must be of type PdfViewing.Pdf.Geometry.Integer.Size and must not be null or undefined.");
                let retVal = Module.ViewingPdfViewSetViewportSize(this.handle, viewportSize);
                if (!retVal)
                    Internal.NativeBase.throwLastError(false);
            }
        }
        Pdf.View = View;
        class EventViewNativeBase {
            constructor(listener) {
                this.listener = listener;
            }
        }
        class ViewUpdatedNativeClass extends EventViewNativeBase {
            constructor(listener) {
                super(listener);
            }
            dispatchEventViewUpdated(visisblePageRangeChanged, pageNumberChanged, zoomChanged, fitmodeChanged, pageLayoutModeChanged, viewRotationChanged, scrollMaxPositionChanged, pageSizeUpdated, bitmapsUpdated) {
                this.listener({ visisblePageRangeChanged, pageNumberChanged, zoomChanged, fitmodeChanged, pageLayoutModeChanged, viewRotationChanged, scrollMaxPositionChanged, pageSizeUpdated, bitmapsUpdated });
            }
        }
        class ImageCreatedNativeClass extends EventViewNativeBase {
            constructor(listener) {
                super(listener);
            }
            dispatchEventImageCreated(image) {
                this.listener(PdfViewing.Pdf.Content.Image.createDynamicObject(image));
            }
        }
        class ImageRemovedFromCacheNativeClass extends EventViewNativeBase {
            constructor(listener) {
                super(listener);
            }
            dispatchEventImageRemovedFromCache(Id) {
                this.listener(Id);
            }
        }
        let Annotations;
        (function (Annotations) {
            /**
             *
             */
            class Color extends Internal.NativeBase {
                constructor(red, green, blue, alpha) {
                    super();
                    if (typeof red !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'red' must be of type number and must not be null or undefined.");
                    if (typeof green !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'green' must be of type number and must not be null or undefined.");
                    if (typeof blue !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'blue' must be of type number and must not be null or undefined.");
                    if (typeof alpha !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'alpha' must be of type number and must not be null or undefined.");
                    this.red = red;
                    this.green = green;
                    this.blue = blue;
                    this.alpha = alpha;
                }
                equals(obj) {
                    if (obj === null)
                        return false;
                    if (this.red !== obj.red)
                        return false;
                    if (this.green !== obj.green)
                        return false;
                    if (this.blue !== obj.blue)
                        return false;
                    if (this.alpha !== obj.alpha)
                        return false;
                    return true;
                }
            }
            Annotations.Color = Color;
            /**
             *
             * Specifies the text displayed for predefined {@link PdfViewing.Pdf.Annotations.TextStamp }s.
             */
            let TextStampType;
            (function (TextStampType) {
                /**
                 *
                 */
                TextStampType[TextStampType["Approved"] = 0] = "Approved";
                /**
                 *
                 */
                TextStampType[TextStampType["Experimental"] = 1] = "Experimental";
                /**
                 *
                 */
                TextStampType[TextStampType["NotApproved"] = 2] = "NotApproved";
                /**
                 *
                 */
                TextStampType[TextStampType["AsIs"] = 3] = "AsIs";
                /**
                 *
                 */
                TextStampType[TextStampType["Expired"] = 4] = "Expired";
                /**
                 *
                 */
                TextStampType[TextStampType["NotForPublicRelease"] = 5] = "NotForPublicRelease";
                /**
                 *
                 */
                TextStampType[TextStampType["Confidential"] = 6] = "Confidential";
                /**
                 *
                 */
                TextStampType[TextStampType["Final"] = 7] = "Final";
                /**
                 *
                 */
                TextStampType[TextStampType["Sold"] = 8] = "Sold";
                /**
                 *
                 */
                TextStampType[TextStampType["Departmental"] = 9] = "Departmental";
                /**
                 *
                 */
                TextStampType[TextStampType["ForComment"] = 10] = "ForComment";
                /**
                 *
                 */
                TextStampType[TextStampType["TopSecret"] = 11] = "TopSecret";
                /**
                 *
                 */
                TextStampType[TextStampType["Draft"] = 12] = "Draft";
                /**
                 *
                 */
                TextStampType[TextStampType["ForPublicRelease"] = 13] = "ForPublicRelease";
            })(TextStampType = Annotations.TextStampType || (Annotations.TextStampType = {}));
            /**
             *
             * Stamp color used for the appearance generation of {@link PdfViewing.Pdf.Annotations.CustomTextStamp }.
             */
            let StampColor;
            (function (StampColor) {
                /**
                 *
                 */
                StampColor[StampColor["Green"] = 0] = "Green";
                /**
                 *
                 */
                StampColor[StampColor["Red"] = 1] = "Red";
                /**
                 *
                 */
                StampColor[StampColor["Blue"] = 2] = "Blue";
            })(StampColor = Annotations.StampColor || (Annotations.StampColor = {}));
            /**
             *
             * Specifies the type of icon displayed on a page for a {@link PdfViewing.Pdf.Annotations.FileAttachment }.
             */
            let FileAttachmentIcon;
            (function (FileAttachmentIcon) {
                /**
                 *
                 */
                FileAttachmentIcon[FileAttachmentIcon["Graph"] = 0] = "Graph";
                /**
                 *
                 */
                FileAttachmentIcon[FileAttachmentIcon["PushPin"] = 1] = "PushPin";
                /**
                 *
                 */
                FileAttachmentIcon[FileAttachmentIcon["Paperclip"] = 2] = "Paperclip";
                /**
                 *
                 */
                FileAttachmentIcon[FileAttachmentIcon["Tag"] = 3] = "Tag";
                /**
                 *
                 */
                FileAttachmentIcon[FileAttachmentIcon["CustomIcon"] = 127] = "CustomIcon";
            })(FileAttachmentIcon = Annotations.FileAttachmentIcon || (Annotations.FileAttachmentIcon = {}));
            /**
             *
             * Specifies the type of styling used for the border of the annotation.
             */
            let BorderStyleType;
            (function (BorderStyleType) {
                /**
                 *
                 */
                BorderStyleType[BorderStyleType["Lined"] = 0] = "Lined";
                /**
                 *
                 */
                BorderStyleType[BorderStyleType["Beveled"] = 1] = "Beveled";
                /**
                 *
                 */
                BorderStyleType[BorderStyleType["Inset"] = 2] = "Inset";
                /**
                 *
                 */
                BorderStyleType[BorderStyleType["Underline"] = 3] = "Underline";
            })(BorderStyleType = Annotations.BorderStyleType || (Annotations.BorderStyleType = {}));
            /**
             *
             * Specifies the type of line termination for line and poly-line annotations.
             */
            let LineEnding;
            (function (LineEnding) {
                /**
                 *
                 */
                LineEnding[LineEnding["None"] = 0] = "None";
                /**
                 *
                 */
                LineEnding[LineEnding["OpenArrow"] = 1] = "OpenArrow";
                /**
                 *
                 */
                LineEnding[LineEnding["ClosedArrow"] = 2] = "ClosedArrow";
                /**
                 *
                 */
                LineEnding[LineEnding["rectangle"] = 3] = "rectangle";
                /**
                 *
                 */
                LineEnding[LineEnding["Circle"] = 4] = "Circle";
                /**
                 *
                 */
                LineEnding[LineEnding["Diamond"] = 5] = "Diamond";
                /**
                 *
                 */
                LineEnding[LineEnding["Butt"] = 6] = "Butt";
                /**
                 *
                 */
                LineEnding[LineEnding["ReversedOpenArrow"] = 7] = "ReversedOpenArrow";
                /**
                 *
                 */
                LineEnding[LineEnding["ReversedClosedArrow"] = 8] = "ReversedClosedArrow";
                /**
                 *
                 */
                LineEnding[LineEnding["Slash"] = 9] = "Slash";
            })(LineEnding = Annotations.LineEnding || (Annotations.LineEnding = {}));
            /**
             * A page annotation
             *
             */
            class Annotation extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfAnnotsAnnotationGetType(handle);
                    switch (type) {
                        case 0:
                            return new Annotation(handle);
                        case 1:
                            return PdfViewing.Pdf.Annotations.MarkupAnnotation.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Annotations.StickyNote.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Annotations.FileAttachment.createDynamicObject(handle);
                        case 4:
                            return PdfViewing.Pdf.Annotations.Stamp.createDynamicObject(handle);
                        case 5:
                            return PdfViewing.Pdf.Annotations.TextStamp.createDynamicObject(handle);
                        case 6:
                            return PdfViewing.Pdf.Annotations.CustomTextStamp.createDynamicObject(handle);
                        case 7:
                            return PdfViewing.Pdf.Annotations.CustomImageStamp.createDynamicObject(handle);
                        case 8:
                            return PdfViewing.Pdf.Annotations.FreeText.createDynamicObject(handle);
                        case 9:
                            return PdfViewing.Pdf.Annotations.DrawingAnnotation.createDynamicObject(handle);
                        case 10:
                            return PdfViewing.Pdf.Annotations.LineAnnotation.createDynamicObject(handle);
                        case 11:
                            return PdfViewing.Pdf.Annotations.InkAnnotation.createDynamicObject(handle);
                        case 12:
                            return PdfViewing.Pdf.Annotations.PolyLineAnnotation.createDynamicObject(handle);
                        case 13:
                            return PdfViewing.Pdf.Annotations.PolygonAnnotation.createDynamicObject(handle);
                        case 14:
                            return PdfViewing.Pdf.Annotations.RectangleAnnotation.createDynamicObject(handle);
                        case 15:
                            return PdfViewing.Pdf.Annotations.EllipseAnnotation.createDynamicObject(handle);
                        case 16:
                            return PdfViewing.Pdf.Annotations.TextMarkup.createDynamicObject(handle);
                        case 17:
                            return PdfViewing.Pdf.Annotations.Highlight.createDynamicObject(handle);
                        case 18:
                            return PdfViewing.Pdf.Annotations.Underline.createDynamicObject(handle);
                        case 19:
                            return PdfViewing.Pdf.Annotations.StrikeThrough.createDynamicObject(handle);
                        case 20:
                            return PdfViewing.Pdf.Annotations.Squiggly.createDynamicObject(handle);
                        case 21:
                            return PdfViewing.Pdf.Annotations.TextInsert.createDynamicObject(handle);
                        case 22:
                            return PdfViewing.Pdf.Annotations.Link.createDynamicObject(handle);
                        case 23:
                            return PdfViewing.Pdf.Annotations.InternalLink.createDynamicObject(handle);
                        case 24:
                            return PdfViewing.Pdf.Annotations.WebLink.createDynamicObject(handle);
                        case 25:
                            return PdfViewing.Pdf.Annotations.EmbeddedPdfLink.createDynamicObject(handle);
                        case 26:
                            return PdfViewing.Pdf.Forms.Widget.createDynamicObject(handle);
                        case 27:
                            return PdfViewing.Pdf.Forms.CheckBox.createDynamicObject(handle);
                        case 28:
                            return PdfViewing.Pdf.Forms.RadioButton.createDynamicObject(handle);
                        case 29:
                            return PdfViewing.Pdf.Forms.TextBox.createDynamicObject(handle);
                        case 30:
                            return PdfViewing.Pdf.Forms.ListBox.createDynamicObject(handle);
                        case 31:
                            return PdfViewing.Pdf.Forms.ComboBox.createDynamicObject(handle);
                        default:
                            return new Annotation(handle);
                    }
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfAnnotsAnnotationClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * The location on the page (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get boundingBox() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationGetBoundingBox(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Real.RectangleOnPage(retVal.pageNumber, retVal.x, retVal.y, retVal.width, retVal.height);
                }
                /**
                * The location on the page (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set boundingBox(boundingBox) {
                    if (typeof boundingBox !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'boundingBox' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsAnnotationSetBoundingBox(this.handle, boundingBox);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The annotation's visibility (Getter)
                *
                * If `true` then the annotation is present, but is invisible and not available for user interaction.
                * Depending on the {@link PdfViewing.Pdf.Annotations.Annotation.noPrint } property it will, however, still be visible when printing.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get hidden() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationGetHidden(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The annotation's visibility (Setter)
                *
                * If `true` then the annotation is present, but is invisible and not available for user interaction.
                * Depending on the {@link PdfViewing.Pdf.Annotations.Annotation.noPrint } property it will, however, still be visible when printing.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set hidden(hidden) {
                    if (typeof hidden !== 'boolean')
                        throw new PdfViewing.ArgumentError("Argument 'hidden' must be of type boolean and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsAnnotationSetHidden(this.handle, hidden);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The annotation's visibility when printing (Getter)
                *
                * If `true` then the annotation is not present in a print output of the document.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get noPrint() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationGetNoPrint(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The annotation's visibility when printing (Setter)
                *
                * If `true` then the annotation is not present in a print output of the document.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set noPrint(noPrint) {
                    if (typeof noPrint !== 'boolean')
                        throw new PdfViewing.ArgumentError("Argument 'noPrint' must be of type boolean and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsAnnotationSetNoPrint(this.handle, noPrint);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The annotation's scaling behavior (Getter)
                *
                * If `true` then the annotation's visual appearance does not scale with the zoom factor of a PDF viewer.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get noZoom() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationGetNoZoom(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The annotation's rotation behavior (Getter)
                *
                * If `true` then the annotation's visual appearance does not rotate with the rotation set in a PDF viewer.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get noRotate() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationGetNoRotate(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The annotation's rotation behavior (Setter)
                *
                * If `true` then the annotation's visual appearance does not rotate with the rotation set in a PDF viewer.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set noRotate(noRotate) {
                    if (typeof noRotate !== 'boolean')
                        throw new PdfViewing.ArgumentError("Argument 'noRotate' must be of type boolean and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsAnnotationSetNoRotate(this.handle, noRotate);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The name by which the annotation is referred to.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get name() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationGetName(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * Private, do not use.
                */
                get privateData() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationGetPrivateData(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * Private, do not use.
                */
                set privateData(privateData) {
                    if (typeof privateData !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'privateData' must be of type string and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsAnnotationSetPrivateData(this.handle, privateData);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * Tag that identifies the source the annotation is coming from.
                * If the source is an input PDF or an input FDF, the tag comes from {@link PdfViewing.IO.InputDocument.sourceTag }.
                * Newly created annotations always return `null`.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get sourceTag() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationGetSourceTag(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Annotations.Annotation = Annotation;
            /**
             * Information for a markup annotation
             *
             * Holds information contained in a markup annotation or in a reply to a markup annotation.
             */
            class MarkupInfo extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new MarkupInfo(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfAnnotsMarkupInfoClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * The date of creation (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get creationDate() {
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoGetCreationDate(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The date of last modification (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get modificationDate() {
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoGetModificationDate(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Whether the content can be modified (Getter)
                *
                * This does not restrict the modification of other aspects of the annotation or its deletion.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get locked() {
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoGetLocked(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Whether the content can be modified (Setter)
                *
                * This does not restrict the modification of other aspects of the annotation or its deletion.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set locked(locked) {
                    if (typeof locked !== 'boolean')
                        throw new PdfViewing.ArgumentError("Argument 'locked' must be of type boolean and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoSetLocked(this.handle, locked);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The author (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get author() {
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoGetAuthor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * The author (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set author(author) {
                    if (typeof author !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'author' must be of type string and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoSetAuthor(this.handle, author);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The subject (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get subject() {
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoGetSubject(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * The subject (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set subject(subject) {
                    if (typeof subject !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'subject' must be of type string and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoSetSubject(this.handle, subject);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The information content (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get content() {
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoGetContent(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * The information content (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set content(content) {
                    if (typeof content !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'content' must be of type string and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoSetContent(this.handle, content);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.MarkupInfo = MarkupInfo;
            /**
             *
             */
            class MarkupInfoList extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new MarkupInfoList(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfAnnotsMarkupInfoListClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                remove(element) {
                    throw new Error("Method not implemented.");
                }
                add(element) {
                    throw new Error("Method not implemented.");
                }
                addRange(inputList) {
                    throw new Error("Method not implemented.");
                }
                set(index, element) {
                    throw new Error("Method not implemented.");
                }
                clear() {
                    throw new Error("Method not implemented.");
                }
                get(index) {
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoListGet(this.handle, index);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.MarkupInfo.createDynamicObject(retVal);
                }
                getRange(index, count) {
                    throw new Error("Method not implemented.");
                }
                get size() {
                    let retVal = Module.ViewingPdfAnnotsMarkupInfoListGetCount(this.handle);
                    if (retVal === -1)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                [Symbol.iterator]() {
                    return new ListIterator(this);
                }
            }
            Annotations.MarkupInfoList = MarkupInfoList;
            /**
             * A pop-up for a markup annotation
             *
             */
            class Popup extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new Popup(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfAnnotsPopupClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * The pop-up's visibility state (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get isOpen() {
                    let retVal = Module.ViewingPdfAnnotsPopupGetIsOpen(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The pop-up's visibility state (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set isOpen(isOpen) {
                    if (typeof isOpen !== 'boolean')
                        throw new PdfViewing.ArgumentError("Argument 'isOpen' must be of type boolean and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsPopupSetIsOpen(this.handle, isOpen);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The pop-up location (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get boundingBox() {
                    let retVal = Module.ViewingPdfAnnotsPopupGetBoundingBox(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Real.RectangleOnPage(retVal.pageNumber, retVal.x, retVal.y, retVal.width, retVal.height);
                }
                /**
                * The pop-up location (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set boundingBox(boundingBox) {
                    if (typeof boundingBox !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'boundingBox' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsPopupSetBoundingBox(this.handle, boundingBox);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.Popup = Popup;
            /**
             * A markup annotation
             *
             */
            class MarkupAnnotation extends PdfViewing.Pdf.Annotations.Annotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfAnnotsMarkupAnnotationGetType(handle);
                    switch (type) {
                        case 0:
                            return new MarkupAnnotation(handle);
                        case 1:
                            return PdfViewing.Pdf.Annotations.StickyNote.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Annotations.FileAttachment.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Annotations.Stamp.createDynamicObject(handle);
                        case 4:
                            return PdfViewing.Pdf.Annotations.TextStamp.createDynamicObject(handle);
                        case 5:
                            return PdfViewing.Pdf.Annotations.CustomTextStamp.createDynamicObject(handle);
                        case 6:
                            return PdfViewing.Pdf.Annotations.CustomImageStamp.createDynamicObject(handle);
                        case 7:
                            return PdfViewing.Pdf.Annotations.FreeText.createDynamicObject(handle);
                        case 8:
                            return PdfViewing.Pdf.Annotations.DrawingAnnotation.createDynamicObject(handle);
                        case 9:
                            return PdfViewing.Pdf.Annotations.LineAnnotation.createDynamicObject(handle);
                        case 10:
                            return PdfViewing.Pdf.Annotations.InkAnnotation.createDynamicObject(handle);
                        case 11:
                            return PdfViewing.Pdf.Annotations.PolyLineAnnotation.createDynamicObject(handle);
                        case 12:
                            return PdfViewing.Pdf.Annotations.PolygonAnnotation.createDynamicObject(handle);
                        case 13:
                            return PdfViewing.Pdf.Annotations.RectangleAnnotation.createDynamicObject(handle);
                        case 14:
                            return PdfViewing.Pdf.Annotations.EllipseAnnotation.createDynamicObject(handle);
                        case 15:
                            return PdfViewing.Pdf.Annotations.TextMarkup.createDynamicObject(handle);
                        case 16:
                            return PdfViewing.Pdf.Annotations.Highlight.createDynamicObject(handle);
                        case 17:
                            return PdfViewing.Pdf.Annotations.Underline.createDynamicObject(handle);
                        case 18:
                            return PdfViewing.Pdf.Annotations.StrikeThrough.createDynamicObject(handle);
                        case 19:
                            return PdfViewing.Pdf.Annotations.Squiggly.createDynamicObject(handle);
                        case 20:
                            return PdfViewing.Pdf.Annotations.TextInsert.createDynamicObject(handle);
                        default:
                            return new MarkupAnnotation(handle);
                    }
                }
                /**
                * Whether the markup annotation can be modified (Getter)
                *
                * This does not restrict modification of the markup annotation's content.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get locked() {
                    let retVal = Module.ViewingPdfAnnotsMarkupAnnotationGetLocked(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The information content of this markup (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get info() {
                    let retVal = Module.ViewingPdfAnnotsMarkupAnnotationGetInfo(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.MarkupInfo.createDynamicObject(retVal);
                }
                /**
                * The replies to this markup (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get replies() {
                    let retVal = Module.ViewingPdfAnnotsMarkupAnnotationGetReplies(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.MarkupInfoList.createDynamicObject(retVal);
                }
            }
            Annotations.MarkupAnnotation = MarkupAnnotation;
            /**
             * A sticky note annotation
             *
             */
            class StickyNote extends PdfViewing.Pdf.Annotations.MarkupAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new StickyNote(handle);
                }
                /**
                 * Create a sticky note annotation.
                 *
                 * The returned sticky note annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param topLeft
                 * The location of the annotation's upper left corner on the page.
                 * @param content
                 * The text content
                 * @param color
                 * The paint for the sticky note icon and popup.
                 * If `null` then a default paint is used.
                 * @returns
                 * The newly created sticky note annotation
                 */
                static create(topLeft, content, color) {
                    if (typeof topLeft !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'topLeft' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                    if (typeof content !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'content' must be of type string and must not be null or undefined.");
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsStickyNoteCreate(topLeft, content, color);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.StickyNote.createDynamicObject(retVal);
                }
                /**
                * The paint for the sticky note icon and the popup (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get color() {
                    let retVal = Module.ViewingPdfAnnotsStickyNoteGetColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
                }
                /**
                * The paint for the sticky note icon and the popup (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set color(color) {
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsStickyNoteSetColor(this.handle, color);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The pop-up (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get popup() {
                    let retVal = Module.ViewingPdfAnnotsStickyNoteGetPopup(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Annotations.Popup.createDynamicObject(retVal) : null;
                }
            }
            Annotations.StickyNote = StickyNote;
            /**
             * A file attachment annotation
             *
             */
            class FileAttachment extends PdfViewing.Pdf.Annotations.MarkupAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new FileAttachment(handle);
                }
                /**
                * The displayed icon (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get icon() {
                    let retVal = Module.ViewingPdfAnnotsFileAttachmentGetIcon(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The paint for the icon and the popup (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get color() {
                    let retVal = Module.ViewingPdfAnnotsFileAttachmentGetColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
                }
                /**
                * The paint for the icon and the popup (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set color(color) {
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsFileAttachmentSetColor(this.handle, color);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The pop-up (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get popup() {
                    let retVal = Module.ViewingPdfAnnotsFileAttachmentGetPopup(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Annotations.Popup.createDynamicObject(retVal) : null;
                }
            }
            Annotations.FileAttachment = FileAttachment;
            /**
             * A stamp annotation
             *
             */
            class Stamp extends PdfViewing.Pdf.Annotations.MarkupAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfAnnotsStampGetType(handle);
                    switch (type) {
                        case 0:
                            return new Stamp(handle);
                        case 1:
                            return PdfViewing.Pdf.Annotations.TextStamp.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Annotations.CustomTextStamp.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Annotations.CustomImageStamp.createDynamicObject(handle);
                        default:
                            return new Stamp(handle);
                    }
                }
                /**
                * The pop-up (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get popup() {
                    let retVal = Module.ViewingPdfAnnotsStampGetPopup(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Annotations.Popup.createDynamicObject(retVal) : null;
                }
                /**
                * The paint for the popup (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get color() {
                    let retVal = Module.ViewingPdfAnnotsStampGetColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
                }
                /**
                * The paint for the popup (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set color(color) {
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsStampSetColor(this.handle, color);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * Rotation in relation to the page.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get rotation() {
                    let retVal = Module.ViewingPdfAnnotsStampGetRotation(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Rotation in relation to the page.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set rotation(rotation) {
                    if (typeof rotation !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'rotation' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsStampSetRotation(this.handle, rotation);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.Stamp = Stamp;
            /**
             * A text stamp annotation
             *
             */
            class TextStamp extends PdfViewing.Pdf.Annotations.Stamp {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new TextStamp(handle);
                }
                /**
                 * Create a text stamp annotation.
                 *
                 * The width of the annotation is computed from the given stamp text.
                 * The returned text stamp annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param topLeft
                 * The location of the annotation's upper left corner on the page.
                 * @param height
                 * The height of the annotation.
                 * @param textType
                 * The text stamp type.
                 * @param text
                 * The text to be shown in this stamp.
                 * @param rotation
                 * The rotation of the annotation in relation to the unrotated view.
                 * The annotation is created with a compensating (and hence opposite) {@link PdfViewing.Pdf.Annotations.Stamp.rotation },
                 * such that it is upright and readable when viewing the document with said view rotation.
                 * @returns
                 * The newly created text stamp annotation.
                 */
                static createRaw(topLeft, height, textType, text, rotation) {
                    if (typeof topLeft !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'topLeft' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                    if (height !== null && height !== undefined && (typeof height !== 'number'))
                        throw new PdfViewing.ArgumentError("Argument 'height' must be of type number or can be null or undefined.");
                    if (typeof textType !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'textType' must be of type PdfViewing.Pdf.Annotations.TextStampType and must not be null or undefined.");
                    if (typeof text !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'text' must be of type string and must not be null or undefined.");
                    if (typeof rotation !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'rotation' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsTextStampCreateRaw(topLeft, height, textType, text, rotation);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.TextStamp.createDynamicObject(retVal);
                }
                /**
                * The displayed text (Getter)
                *
                * This defines a predefined text for this text stamp.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                * @throws {@link PdfViewing.UnsupportedFeatureError} The text stamp's type is not supported.
                */
                get textType() {
                    let retVal = Module.ViewingPdfAnnotsTextStampGetTextType(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Annotations.TextStamp = TextStamp;
            /**
             * A stamp annotation with user defined stamp text
             *
             */
            class CustomTextStamp extends PdfViewing.Pdf.Annotations.Stamp {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new CustomTextStamp(handle);
                }
                /**
                 * Create a custom stamp annotation.
                 *
                 * The returned custom Textstamp annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * The custom stamp annotation's appearance is generated after it was added to a page.
                 * @param boundingBox
                 * The location of the annotation on the page.
                 * Use {@link PdfViewing.Pdf.Document.getTextStampAspectRatio } to obtain the correct aspect ratio of width divided by height of the {@link PdfViewing.Pdf.Annotations.CustomTextStamp.create boundingBox}
                 * @param stampText
                 * The custom stamp text
                 * @param stampColor
                 * The color of the stamp appearance
                 * @param rotation
                 * The rotation of the annotation in relation to the unrotated view.
                 * The annotation is created with a compensating (and hence opposite) {@link PdfViewing.Pdf.Annotations.Stamp.rotation },
                 * such that it is upright and readable when viewing the document with said view rotation.
                 * @returns
                 * The newly created custom text stamp annotation.
                 */
                static create(boundingBox, stampText, stampColor, rotation) {
                    if (typeof boundingBox !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'boundingBox' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                    if (typeof stampText !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'stampText' must be of type string and must not be null or undefined.");
                    if (typeof stampColor !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'stampColor' must be of type PdfViewing.Pdf.Annotations.StampColor and must not be null or undefined.");
                    if (typeof rotation !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'rotation' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsCustomTextStampCreate(boundingBox, stampText, stampColor, rotation);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.CustomTextStamp.createDynamicObject(retVal);
                }
            }
            Annotations.CustomTextStamp = CustomTextStamp;
            /**
             * A stamp annotatation based on an image
             *
             */
            class CustomImageStamp extends PdfViewing.Pdf.Annotations.Stamp {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new CustomImageStamp(handle);
                }
                /**
                 * Create a custom stamp annotation.
                 *
                 * The returned custom Imagestamp annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * The custom stamp annotation's appearance is generated after it was added to a page.
                 * @param boundingBox
                 * The location of the annotation on the page.
                 * For registered images the correct aspect ratio can be derived from the given image.
                 * When creating the stamp from a PDF Page, the aspect ratio can be derived from the size of the page that was copied using {@link PdfViewing.Pdf.Document.getPagePdfSize }
                 * @param imageId
                 * The ID of an image that is already registered in the Document.
                 * Image ID's can be generated from images using {@link PdfViewing.Pdf.Document.registerImage } or from a PDF Page using {@link PdfViewing.Pdf.Document.registerPdfPage }
                 * @param rotation
                 * The rotation of the annotation in relation to the unrotated view.
                 * The annotation is created with a compensating (and hence opposite) {@link PdfViewing.Pdf.Annotations.Stamp.rotation },
                 * such that it is upright and readable when viewing the document with said view rotation.
                 * @returns
                 * The newly created custom text stamp annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.CustomImageStamp.create imageId} argument is invalid
                 */
                static create(boundingBox, imageId, rotation) {
                    if (typeof boundingBox !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'boundingBox' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                    if (typeof imageId !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'imageId' must be of type number and must not be null or undefined.");
                    if (typeof rotation !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'rotation' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsCustomImageStampCreate(boundingBox, imageId, rotation);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.CustomImageStamp.createDynamicObject(retVal);
                }
            }
            Annotations.CustomImageStamp = CustomImageStamp;
            /**
             * An annotation that displays text
             *
             * For a free-text annotation, the annotation's content is used as text to be displayed as the annotation's visual manifestation on the page.
             */
            class FreeText extends PdfViewing.Pdf.Annotations.MarkupAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new FreeText(handle);
                }
                /**
                 * Create a free-text annotation.
                 *
                 * The returned free-text annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param boundingBox
                 * The location on the page.
                 * @param richText
                 * The Richtextstring describing content, color and font.
                 * @param backgroundColor
                 * The background color of the freetext annotation. Passing null results in a transparent background.
                 * @param annotationStroke
                 * The stroking style for all lines
                 * @param viewRotation
                 * The rotation of the view, see {@link PdfViewing.Pdf.View.viewRotation }.
                 * The annotation is created with a compensating (and hence opposite) {@link PdfViewing.Pdf.Annotations.FreeText.rotation },
                 * such that it is upright and readable when viewing the document with said view rotation.
                 * @returns
                 * The newly created free text annotation.
                 */
                static create(boundingBox, richText, backgroundColor, annotationStroke, viewRotation) {
                    if (typeof boundingBox !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'boundingBox' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                    if (typeof richText !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'richText' must be of type string and must not be null or undefined.");
                    if (backgroundColor !== null && backgroundColor !== undefined && (typeof backgroundColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'backgroundColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    if (typeof viewRotation !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'viewRotation' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsFreeTextCreate(boundingBox, richText, backgroundColor, annotationStroke.handle, viewRotation);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.FreeText.createDynamicObject(retVal);
                }
                /**
                * The stroking style for all lines. (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get annotationStroke() {
                    let retVal = Module.ViewingPdfAnnotsFreeTextGetAnnotationStroke(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.AnnotationStroke.createDynamicObject(retVal);
                }
                /**
                * The stroking style for all lines. (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set annotationStroke(annotationStroke) {
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsFreeTextSetAnnotationStroke(this.handle, annotationStroke.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The information content (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get richText() {
                    let retVal = Module.ViewingPdfAnnotsFreeTextGetRichText(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * The information content (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set richText(richText) {
                    if (typeof richText !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'richText' must be of type string and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsFreeTextSetRichText(this.handle, richText);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The background color (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get backgroundColor() {
                    let retVal = Module.ViewingPdfAnnotsFreeTextGetBackgroundColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal !== null ? new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha) : null;
                }
                /**
                * The background color (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set backgroundColor(backgroundColor) {
                    if (backgroundColor !== null && backgroundColor !== undefined && (typeof backgroundColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'backgroundColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsFreeTextSetBackgroundColor(this.handle, backgroundColor);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * Rotation in relation to the page.
                * When creating the annotation with a non-zero view rotation in {@link PdfViewing.Pdf.Annotations.FreeText.create },
                * then this property will initially be the opposite of the given view rotation.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get rotation() {
                    let retVal = Module.ViewingPdfAnnotsFreeTextGetRotation(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Rotation in relation to the page.
                * When creating the annotation with a non-zero view rotation in {@link PdfViewing.Pdf.Annotations.FreeText.create },
                * then this property will initially be the opposite of the given view rotation.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set rotation(rotation) {
                    if (typeof rotation !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'rotation' must be of type PdfViewing.Pdf.Geometry.Rotation and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsFreeTextSetRotation(this.handle, rotation);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.FreeText = FreeText;
            /**
             * A drawing annotation
             *
             * An annotation used to draws something on a page.
             */
            class DrawingAnnotation extends PdfViewing.Pdf.Annotations.MarkupAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfAnnotsDrawingAnnotationGetType(handle);
                    switch (type) {
                        case 0:
                            return new DrawingAnnotation(handle);
                        case 1:
                            return PdfViewing.Pdf.Annotations.LineAnnotation.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Annotations.InkAnnotation.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Annotations.PolyLineAnnotation.createDynamicObject(handle);
                        case 4:
                            return PdfViewing.Pdf.Annotations.PolygonAnnotation.createDynamicObject(handle);
                        case 5:
                            return PdfViewing.Pdf.Annotations.RectangleAnnotation.createDynamicObject(handle);
                        case 6:
                            return PdfViewing.Pdf.Annotations.EllipseAnnotation.createDynamicObject(handle);
                        default:
                            return new DrawingAnnotation(handle);
                    }
                }
                /**
                * The color used for any stroking and the popup.
                * The value `null` renders the color completely transparent.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get strokeColor() {
                    let retVal = Module.ViewingPdfAnnotsDrawingAnnotationGetStrokeColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal !== null ? new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha) : null;
                }
                /**
                * The color used for any stroking and the popup.
                * The value `null` renders the color completely transparent.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set strokeColor(strokeColor) {
                    if (strokeColor !== null && strokeColor !== undefined && (typeof strokeColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'strokeColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsDrawingAnnotationSetStrokeColor(this.handle, strokeColor);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The stroking style for all lines. (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get annotationStroke() {
                    let retVal = Module.ViewingPdfAnnotsDrawingAnnotationGetAnnotationStroke(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Annotations.AnnotationStroke.createDynamicObject(retVal) : null;
                }
                /**
                * The stroking style for all lines. (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set annotationStroke(annotationStroke) {
                    if (annotationStroke !== null && annotationStroke !== undefined && !(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsDrawingAnnotationSetAnnotationStroke(this.handle, (annotationStroke !== null && annotationStroke !== undefined) ? annotationStroke.handle : 0);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The pop-up (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get popup() {
                    let retVal = Module.ViewingPdfAnnotsDrawingAnnotationGetPopup(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Annotations.Popup.createDynamicObject(retVal) : null;
                }
                /**
                * The drawing path (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get path() {
                    let retVal = Module.ViewingPdfAnnotsDrawingAnnotationGetPath(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Geometry.Real.Path.createDynamicObject(retVal);
                }
            }
            Annotations.DrawingAnnotation = DrawingAnnotation;
            /**
             * A line annotation
             *
             * An annotation that draws a line on a page.
             */
            class LineAnnotation extends PdfViewing.Pdf.Annotations.DrawingAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new LineAnnotation(handle);
                }
                /**
                 * Create a line annotation.
                 *
                 * The returned line annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param start
                 * The line's start point.
                 * @param end
                 * The line's end point.
                 * @param strokeColor
                 * The color used for stroking and the popup. Pass `null` to set default grey color.
                 * @param annotationStroke
                 * The stroking style for all lines
                 * @returns
                 * The newly created line annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if points {@link PdfViewing.Pdf.Annotations.LineAnnotation.create start} and {@link PdfViewing.Pdf.Annotations.LineAnnotation.create end} are not on the same page
                 */
                static create(start, end, strokeColor, annotationStroke) {
                    if (typeof start !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'start' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                    if (typeof end !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'end' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                    if (strokeColor !== null && strokeColor !== undefined && (typeof strokeColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'strokeColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsLineAnnotationCreate(start, end, strokeColor, annotationStroke.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.LineAnnotation.createDynamicObject(retVal);
                }
                /**
                * The line's starting point (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get start() {
                    let retVal = Module.ViewingPdfAnnotsLineAnnotationGetStart(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Real.PointOnPage(retVal.pageNumber, retVal.x, retVal.y);
                }
                /**
                * The line's ending point (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get end() {
                    let retVal = Module.ViewingPdfAnnotsLineAnnotationGetEnd(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Real.PointOnPage(retVal.pageNumber, retVal.x, retVal.y);
                }
                /**
                * The starting point's style (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get startStyle() {
                    let retVal = Module.ViewingPdfAnnotsLineAnnotationGetStartStyle(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The ending point's style (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get endStyle() {
                    let retVal = Module.ViewingPdfAnnotsLineAnnotationGetEndStyle(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The line ending filling paint (Getter)
                *
                * This paint applies to both the starting end the ending point.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get lineEndingFill() {
                    let retVal = Module.ViewingPdfAnnotsLineAnnotationGetLineEndingFill(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
                }
            }
            Annotations.LineAnnotation = LineAnnotation;
            /**
             * A free-hand drawing annotation
             *
             */
            class InkAnnotation extends PdfViewing.Pdf.Annotations.DrawingAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new InkAnnotation(handle);
                }
                /**
                 * Create a ink annotation.
                 *
                 * The returned ink annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param pageNumber
                 * @param path
                 * The path of the free-hand drawing.
                 * @param strokeColor
                 * The color used for stroking and the popup
                 * @param annotationStroke
                 * The stroking style for all lines
                 * @returns
                 * The newly created ink annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.InkAnnotation.create path} argument is `null`
                 * @throws {@link PdfViewing.NotSupportedError} if the {@link PdfViewing.Pdf.Annotations.InkAnnotation.create path} is not valid for this operation
                 */
                static create(pageNumber, path, strokeColor, annotationStroke) {
                    if (typeof pageNumber !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                    if (!(path instanceof PdfViewing.Pdf.Geometry.Real.Path))
                        throw new PdfViewing.ArgumentError("Argument 'path' must be of type PdfViewing.Pdf.Geometry.Real.Path and must not be null or undefined.");
                    if (typeof strokeColor !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'strokeColor' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsInkAnnotationCreate(pageNumber, path.handle, strokeColor, annotationStroke.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.InkAnnotation.createDynamicObject(retVal);
                }
                /**
                 * Set the path
                 *
                 * Supported {@link PdfViewing.Pdf.Geometry.Real.PathOperation }s are
                 * {@link PdfViewing.Pdf.Geometry.Real.PathOperation.MoveTo } and {@link PdfViewing.Pdf.Geometry.Real.PathOperation.LineTo }.
                 * @param path
                 * The new path to be set for the annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.InkAnnotation.setPath path} argument is `null`
                 * @throws {@link PdfViewing.NotSupportedError} if the {@link PdfViewing.Pdf.Annotations.InkAnnotation.setPath path} contains unsupported {@link PdfViewing.Pdf.Geometry.Real.PathOperation }s
                 */
                setPath(path) {
                    if (!(path instanceof PdfViewing.Pdf.Geometry.Real.Path))
                        throw new PdfViewing.ArgumentError("Argument 'path' must be of type PdfViewing.Pdf.Geometry.Real.Path and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsInkAnnotationSetPath(this.handle, path.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.InkAnnotation = InkAnnotation;
            /**
             * A drawing annotation that consists of several line segments
             *
             */
            class PolyLineAnnotation extends PdfViewing.Pdf.Annotations.DrawingAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new PolyLineAnnotation(handle);
                }
                /**
                 * Create a poly-line annotation.
                 *
                 * The returned poly-line annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param pageNumber
                 * @param path
                 * The path of the poly line.
                 * @param strokeColor
                 * The color used for stroking and the popup
                 * @param annotationStroke
                 * The stroking style for all lines
                 * @returns
                 * The newly created poly-line annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.PolyLineAnnotation.create path} argument is `null`
                 * @throws {@link PdfViewing.NotSupportedError} if the {@link PdfViewing.Pdf.Annotations.PolyLineAnnotation.create path} is not valid for this operation
                 */
                static create(pageNumber, path, strokeColor, annotationStroke) {
                    if (typeof pageNumber !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                    if (!(path instanceof PdfViewing.Pdf.Geometry.Real.Path))
                        throw new PdfViewing.ArgumentError("Argument 'path' must be of type PdfViewing.Pdf.Geometry.Real.Path and must not be null or undefined.");
                    if (typeof strokeColor !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'strokeColor' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsPolyLineAnnotationCreate(pageNumber, path.handle, strokeColor, annotationStroke.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.PolyLineAnnotation.createDynamicObject(retVal);
                }
                /**
                * The starting point's style (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get startStyle() {
                    let retVal = Module.ViewingPdfAnnotsPolyLineAnnotationGetStartStyle(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The ending point's style (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get endStyle() {
                    let retVal = Module.ViewingPdfAnnotsPolyLineAnnotationGetEndStyle(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The line ending filling paint for both start and end (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get lineEndingFill() {
                    let retVal = Module.ViewingPdfAnnotsPolyLineAnnotationGetLineEndingFill(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
                }
            }
            Annotations.PolyLineAnnotation = PolyLineAnnotation;
            /**
             * A polygon annotation
             *
             */
            class PolygonAnnotation extends PdfViewing.Pdf.Annotations.DrawingAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new PolygonAnnotation(handle);
                }
                /**
                 * Create a polygon annotation.
                 *
                 * The returned polygon annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param pageNumber
                 * @param path
                 * The path of the polygon.
                 * @param strokeColor
                 * The color used for stroking and the popup.
                 * The alpha value of this color is used for stroking and filling.
                 * Set `null` or a color with alpha = 0 to make stroke transparent.
                 * @param annotationStroke
                 * The stroking style for all lines
                 * @param borderStyleType
                 * The style of the stroked lines
                 * @param fillColor
                 * The paint used for filling the polygon.
                 * If `null` then the polygon is not filled.
                 * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.PolygonAnnotation.create strokeColor} is `null` or its alpha value is 0.
                 * @returns
                 * The newly created polygon annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.PolygonAnnotation.create path} argument is `null`
                 * @throws {@link PdfViewing.NotSupportedError} if the {@link PdfViewing.Pdf.Annotations.PolygonAnnotation.create path} is not valid for this operation
                 */
                static create(pageNumber, path, strokeColor, annotationStroke, borderStyleType, fillColor) {
                    if (typeof pageNumber !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                    if (!(path instanceof PdfViewing.Pdf.Geometry.Real.Path))
                        throw new PdfViewing.ArgumentError("Argument 'path' must be of type PdfViewing.Pdf.Geometry.Real.Path and must not be null or undefined.");
                    if (strokeColor !== null && strokeColor !== undefined && (typeof strokeColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'strokeColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    if (typeof borderStyleType !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'borderStyleType' must be of type PdfViewing.Pdf.Annotations.BorderStyleType and must not be null or undefined.");
                    if (fillColor !== null && fillColor !== undefined && (typeof fillColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'fillColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsPolygonAnnotationCreate(pageNumber, path.handle, strokeColor, annotationStroke.handle, borderStyleType, fillColor);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.PolygonAnnotation.createDynamicObject(retVal);
                }
                /**
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get borderStyleType() {
                    let retVal = Module.ViewingPdfAnnotsPolygonAnnotationGetBorderStyleType(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set borderStyleType(borderStyleType) {
                    if (typeof borderStyleType !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'borderStyleType' must be of type PdfViewing.Pdf.Annotations.BorderStyleType and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsPolygonAnnotationSetBorderStyleType(this.handle, borderStyleType);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The filling paint (Getter)
                *
                * If `null` then the polygon is not filled.
                * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is `null` or its alpha value is 0.
                * Otherwise alpha of {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is used.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get fillColor() {
                    let retVal = Module.ViewingPdfAnnotsPolygonAnnotationGetFillColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal !== null ? new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha) : null;
                }
                /**
                * The filling paint (Setter)
                *
                * If `null` then the polygon is not filled.
                * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is `null` or its alpha value is 0.
                * Otherwise alpha of {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is used.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set fillColor(fillColor) {
                    if (fillColor !== null && fillColor !== undefined && (typeof fillColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'fillColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsPolygonAnnotationSetFillColor(this.handle, fillColor);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.PolygonAnnotation = PolygonAnnotation;
            /**
             * A rectangle drawing annotation
             *
             */
            class RectangleAnnotation extends PdfViewing.Pdf.Annotations.DrawingAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new RectangleAnnotation(handle);
                }
                /**
                 * Create a rectangle annotation.
                 *
                 * The returned rectangle annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param boundingBox
                 * The location on the page.
                 * @param strokeColor
                 * The color used for stroking and the popup.
                 * The alpha value of this color is used for stroking and filling.
                 * Set `null` or a color with alpha = 0 to make stroke transparent.
                 * @param annotationStroke
                 * The stroking style for all lines.
                 * @param borderStyleType
                 * The style of the stroked lines
                 * @param fillColor
                 * The paint used for filling the rectangle.
                 * If `null` then the rectangle is not filled.
                 * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.RectangleAnnotation.create strokeColor} is `null` or its alpha value is 0.
                 * @returns
                 * The newly created rectangle annotation.
                 */
                static create(boundingBox, strokeColor, annotationStroke, borderStyleType, fillColor) {
                    if (typeof boundingBox !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'boundingBox' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                    if (strokeColor !== null && strokeColor !== undefined && (typeof strokeColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'strokeColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    if (typeof borderStyleType !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'borderStyleType' must be of type PdfViewing.Pdf.Annotations.BorderStyleType and must not be null or undefined.");
                    if (fillColor !== null && fillColor !== undefined && (typeof fillColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'fillColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsRectangleAnnotationCreate(boundingBox, strokeColor, annotationStroke.handle, borderStyleType, fillColor);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.RectangleAnnotation.createDynamicObject(retVal);
                }
                /**
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get borderStyleType() {
                    let retVal = Module.ViewingPdfAnnotsRectangleAnnotationGetBorderStyleType(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set borderStyleType(borderStyleType) {
                    if (typeof borderStyleType !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'borderStyleType' must be of type PdfViewing.Pdf.Annotations.BorderStyleType and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsRectangleAnnotationSetBorderStyleType(this.handle, borderStyleType);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The filling paint (Getter)
                *
                * If `null` then the rectangle is not filled.
                * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is `null` or its alpha value is 0.
                * Otherwise alpha of {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is used.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get fillColor() {
                    let retVal = Module.ViewingPdfAnnotsRectangleAnnotationGetFillColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal !== null ? new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha) : null;
                }
                /**
                * The filling paint (Setter)
                *
                * If `null` then the rectangle is not filled.
                * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is `null` or its alpha value is 0.
                * Otherwise alpha of {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is used.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set fillColor(fillColor) {
                    if (fillColor !== null && fillColor !== undefined && (typeof fillColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'fillColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsRectangleAnnotationSetFillColor(this.handle, fillColor);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.RectangleAnnotation = RectangleAnnotation;
            /**
             * An ellipse drawing annotation
             *
             */
            class EllipseAnnotation extends PdfViewing.Pdf.Annotations.DrawingAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new EllipseAnnotation(handle);
                }
                /**
                 * Create an ellipse annotation.
                 *
                 * The returned ellipse annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param boundingBox
                 * The location on the page.
                 * @param strokeColor
                 * The color used for stroking and the popup.
                 * The alpha value of this color is used for stroking and filling.
                 * Set `null` or a color with alpha = 0 to make stroke transparent.
                 * @param annotationStroke
                 * The stroking style for all lines. The color is also used for the popup.
                 * @param borderStyleType
                 * The style of the stroked border
                 * @param fillColor
                 * The paint used for filling the rectangle.
                 * If `null` then the rectangle is not filled.
                 * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.EllipseAnnotation.create strokeColor} is `null` or its alpha value is 0.
                 * @returns
                 * The newly created ellipse annotation.
                 */
                static create(boundingBox, strokeColor, annotationStroke, borderStyleType, fillColor) {
                    if (typeof boundingBox !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'boundingBox' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                    if (strokeColor !== null && strokeColor !== undefined && (typeof strokeColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'strokeColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    if (typeof borderStyleType !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'borderStyleType' must be of type PdfViewing.Pdf.Annotations.BorderStyleType and must not be null or undefined.");
                    if (fillColor !== null && fillColor !== undefined && (typeof fillColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'fillColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsEllipseAnnotationCreate(boundingBox, strokeColor, annotationStroke.handle, borderStyleType, fillColor);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.EllipseAnnotation.createDynamicObject(retVal);
                }
                /**
                *
                */
                get borderStyleType() {
                    let retVal = Module.ViewingPdfAnnotsEllipseAnnotationGetBorderStyleType(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                *
                */
                set borderStyleType(borderStyleType) {
                    if (typeof borderStyleType !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'borderStyleType' must be of type PdfViewing.Pdf.Annotations.BorderStyleType and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsEllipseAnnotationSetBorderStyleType(this.handle, borderStyleType);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The filling paint (Getter)
                *
                * If `null` then the ellipse is not filled.
                * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is `null` or its alpha value is 0.
                * Otherwise alpha of {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is used.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get fillColor() {
                    let retVal = Module.ViewingPdfAnnotsEllipseAnnotationGetFillColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal !== null ? new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha) : null;
                }
                /**
                * The filling paint (Setter)
                *
                * If `null` then the ellipse is not filled.
                * The alpha value of this color only takes effect if {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is `null` or its alpha value is 0.
                * Otherwise alpha of {@link PdfViewing.Pdf.Annotations.DrawingAnnotation.strokeColor } is used.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set fillColor(fillColor) {
                    if (fillColor !== null && fillColor !== undefined && (typeof fillColor !== 'object'))
                        throw new PdfViewing.ArgumentError("Argument 'fillColor' must be of type PdfViewing.Pdf.Annotations.Color or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsEllipseAnnotationSetFillColor(this.handle, fillColor);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.EllipseAnnotation = EllipseAnnotation;
            /**
             * An annotation that marks up part(s) of a text
             *
             */
            class TextMarkup extends PdfViewing.Pdf.Annotations.MarkupAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfAnnotsTextMarkupGetType(handle);
                    switch (type) {
                        case 0:
                            return new TextMarkup(handle);
                        case 1:
                            return PdfViewing.Pdf.Annotations.Highlight.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Annotations.Underline.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Annotations.StrikeThrough.createDynamicObject(handle);
                        case 4:
                            return PdfViewing.Pdf.Annotations.Squiggly.createDynamicObject(handle);
                        default:
                            return new TextMarkup(handle);
                    }
                }
                /**
                * The Color of the annotation and the popup (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get color() {
                    let retVal = Module.ViewingPdfAnnotsTextMarkupGetColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
                }
                /**
                * The Color of the annotation and the popup (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set color(color) {
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsTextMarkupSetColor(this.handle, color);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The pop-up (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get popup() {
                    let retVal = Module.ViewingPdfAnnotsTextMarkupGetPopup(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Annotations.Popup.createDynamicObject(retVal) : null;
                }
                /**
                * Area of all marked text.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get markupArea() {
                    let retVal = Module.ViewingPdfAnnotsTextMarkupGetMarkupArea(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Geometry.Real.QuadrilateralList.createDynamicObject(retVal);
                }
                /**
                * Area of all marked text.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                * @throws {@link PdfViewing.ArgumentError} if the list is `null`
                * @throws {@link PdfViewing.ArgumentError} if the list contains no quadrilaterals
                */
                set markupArea(markupArea) {
                    if (!(markupArea instanceof PdfViewing.Pdf.Geometry.Real.QuadrilateralList))
                        throw new PdfViewing.ArgumentError("Argument 'markupArea' must be of type PdfViewing.Pdf.Geometry.Real.QuadrilateralList and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsTextMarkupSetMarkupArea(this.handle, markupArea.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * Text which is highlighted
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get markedText() {
                    let retVal = Module.ViewingPdfAnnotsTextMarkupGetMarkedText(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
            }
            Annotations.TextMarkup = TextMarkup;
            /**
             * An text highlighting annotation
             *
             */
            class Highlight extends PdfViewing.Pdf.Annotations.TextMarkup {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new Highlight(handle);
                }
                /**
                 * Create a Highlight annotation.
                 *
                 * The returned rectangle annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param markupArea
                 * List of areas to be highlighted.
                 * @param color
                 * The color used for the highlighted area and the popup.
                 * @returns
                 * The newly created highlight annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.Highlight.create markupArea} argument is `null`
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.Highlight.create markupArea} list contains no quadrilaterals
                 */
                static create(markupArea, color) {
                    if (!(markupArea instanceof PdfViewing.Pdf.Geometry.Real.QuadrilateralList))
                        throw new PdfViewing.ArgumentError("Argument 'markupArea' must be of type PdfViewing.Pdf.Geometry.Real.QuadrilateralList and must not be null or undefined.");
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsHighlightCreate(markupArea.handle, color);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.Highlight.createDynamicObject(retVal);
                }
            }
            Annotations.Highlight = Highlight;
            /**
             * An text underlining annotation
             *
             */
            class Underline extends PdfViewing.Pdf.Annotations.TextMarkup {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new Underline(handle);
                }
                /**
                 * Create a Highlight annotation.
                 *
                 * The returned rectangle annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param markupArea
                 * List of areas to be underlined. The underline is drawn on the baseline of each quadpoint.
                 * @param color
                 * The color used for the line and the popup.
                 * @returns
                 * The newly created Underline annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.Underline.create markupArea} argument is `null`
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.Underline.create markupArea} list contains no quadrilaterals
                 */
                static create(markupArea, color) {
                    if (!(markupArea instanceof PdfViewing.Pdf.Geometry.Real.QuadrilateralList))
                        throw new PdfViewing.ArgumentError("Argument 'markupArea' must be of type PdfViewing.Pdf.Geometry.Real.QuadrilateralList and must not be null or undefined.");
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsUnderlineCreate(markupArea.handle, color);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.Underline.createDynamicObject(retVal);
                }
            }
            Annotations.Underline = Underline;
            /**
             * An annotation for striking through text
             *
             */
            class StrikeThrough extends PdfViewing.Pdf.Annotations.TextMarkup {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new StrikeThrough(handle);
                }
                /**
                 * Create a Highlight annotation.
                 *
                 * The returned rectangle annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param markupArea
                 * List of areas to be striked through. The line is drawn in the middle of each quadpoints, parallel to its baseline.
                 * @param color
                 * The color used for the line and the popup.
                 * @returns
                 * The newly created strikethrough annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.StrikeThrough.create markupArea} argument is `null`
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.StrikeThrough.create markupArea} list contains no quadrilaterals
                 */
                static create(markupArea, color) {
                    if (!(markupArea instanceof PdfViewing.Pdf.Geometry.Real.QuadrilateralList))
                        throw new PdfViewing.ArgumentError("Argument 'markupArea' must be of type PdfViewing.Pdf.Geometry.Real.QuadrilateralList and must not be null or undefined.");
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsStrikeThroughCreate(markupArea.handle, color);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.StrikeThrough.createDynamicObject(retVal);
                }
            }
            Annotations.StrikeThrough = StrikeThrough;
            /**
             * A squiggly text underlining annotation
             *
             */
            class Squiggly extends PdfViewing.Pdf.Annotations.TextMarkup {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new Squiggly(handle);
                }
                /**
                 * Create a Highlight annotation.
                 *
                 * The returned rectangle annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param markupArea
                 * List of areas to be underlined with a squiggly line. The squiggly line is drawn on the baseline of each quadpoint.
                 * @param color
                 * The color used for the line and the popup.
                 * @returns
                 * The newly created Squiggly annotation.
                 *
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.Squiggly.create markupArea} argument is `null`
                 * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Annotations.Squiggly.create markupArea} list contains no quadrilaterals
                 */
                static create(markupArea, color) {
                    if (!(markupArea instanceof PdfViewing.Pdf.Geometry.Real.QuadrilateralList))
                        throw new PdfViewing.ArgumentError("Argument 'markupArea' must be of type PdfViewing.Pdf.Geometry.Real.QuadrilateralList and must not be null or undefined.");
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsSquigglyCreate(markupArea.handle, color);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.Squiggly.createDynamicObject(retVal);
                }
            }
            Annotations.Squiggly = Squiggly;
            /**
             * An annotation that marks a point to insert text
             *
             */
            class TextInsert extends PdfViewing.Pdf.Annotations.MarkupAnnotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new TextInsert(handle);
                }
                /**
                * The Color for the annotation and the popup (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get color() {
                    let retVal = Module.ViewingPdfAnnotsTextInsertGetColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
                }
                /**
                * The Color for the annotation and the popup (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set color(color) {
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsTextInsertSetColor(this.handle, color);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The pop-up (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get popup() {
                    let retVal = Module.ViewingPdfAnnotsTextInsertGetPopup(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Annotations.Popup.createDynamicObject(retVal) : null;
                }
            }
            Annotations.TextInsert = TextInsert;
            /**
             * A link
             *
             */
            class Link extends PdfViewing.Pdf.Annotations.Annotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfAnnotsLinkGetType(handle);
                    switch (type) {
                        case 0:
                            return new Link(handle);
                        case 1:
                            return PdfViewing.Pdf.Annotations.InternalLink.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Annotations.WebLink.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Annotations.EmbeddedPdfLink.createDynamicObject(handle);
                        default:
                            return new Link(handle);
                    }
                }
                /**
                * The link's border stroke (Setter)
                *
                * This property defines if and how a rectangular border is drawn for the link.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                * @throws {@link PdfViewing.ArgumentError} the given {@link PdfViewing.Pdf.Annotations.AnnotationStroke } object is `null`
                */
                set annotationStroke(annotationStroke) {
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsLinkSetAnnotationStroke(this.handle, annotationStroke.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The Color for the annotation (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get color() {
                    let retVal = Module.ViewingPdfAnnotsLinkGetColor(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Annotations.Color(retVal.red, retVal.green, retVal.blue, retVal.alpha);
                }
                /**
                * The Color for the annotation (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set color(color) {
                    if (typeof color !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'color' must be of type PdfViewing.Pdf.Annotations.Color and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsLinkSetColor(this.handle, color);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * The link area (Getter)
                *
                * This list of {@link PdfViewing.Pdf.Geometry.Real.QuadrilateralOnPage }s defines the active link area on the page.
                * A PDF viewer executes the appropriate action,
                * such as navigating to a destination or opening a web browser,
                * when a mouse click falls inside of this area.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get activeArea() {
                    let retVal = Module.ViewingPdfAnnotsLinkGetActiveArea(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Geometry.Real.QuadrilateralList.createDynamicObject(retVal);
                }
                /**
                * The link area (Setter)
                *
                * This list of {@link PdfViewing.Pdf.Geometry.Real.QuadrilateralOnPage }s defines the active link area on the page.
                * A PDF viewer executes the appropriate action,
                * such as navigating to a destination or opening a web browser,
                * when a mouse click falls inside of this area.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                * @throws {@link PdfViewing.ArgumentError} if the list is `null`.
                * @throws {@link PdfViewing.ArgumentError} if the list contains no quadrilaterals.
                */
                set activeArea(activeArea) {
                    if (!(activeArea instanceof PdfViewing.Pdf.Geometry.Real.QuadrilateralList))
                        throw new PdfViewing.ArgumentError("Argument 'activeArea' must be of type PdfViewing.Pdf.Geometry.Real.QuadrilateralList and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsLinkSetActiveArea(this.handle, activeArea.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.Link = Link;
            /**
             * A document-wide link
             *
             */
            class InternalLink extends PdfViewing.Pdf.Annotations.Link {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new InternalLink(handle);
                }
                /**
                * The link target (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                * @throws {@link PdfViewing.InvalidOperationError} if the link has no destination
                */
                get destination() {
                    let retVal = Module.ViewingPdfAnnotsInternalLinkGetDestination(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Navigation.Destination.createDynamicObject(retVal) : null;
                }
            }
            Annotations.InternalLink = InternalLink;
            /**
             * An external link
             *
             */
            class WebLink extends PdfViewing.Pdf.Annotations.Link {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new WebLink(handle);
                }
                /**
                 * Create a new external link
                 *
                 * The returned WebLink annotation is not yet part of any page.
                 * It can be added to a page's list of annotations.
                 * @param boundingBox
                 * The location on the page.
                 * @param annotationStroke
                 * The given AnnotationStroke defines if and how a rectangular border is drawn for the link.
                 * @param uri
                 * The link target
                 * @returns
                 * The newly created object
                 */
                static create(boundingBox, annotationStroke, uri) {
                    if (typeof boundingBox !== 'object')
                        throw new PdfViewing.ArgumentError("Argument 'boundingBox' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                    if (!(annotationStroke instanceof PdfViewing.Pdf.Annotations.AnnotationStroke))
                        throw new PdfViewing.ArgumentError("Argument 'annotationStroke' must be of type PdfViewing.Pdf.Annotations.AnnotationStroke and must not be null or undefined.");
                    if (typeof uri !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'uri' must be of type string and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsWebLinkCreate(boundingBox, annotationStroke.handle, uri);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.WebLink.createDynamicObject(retVal);
                }
                /**
                * The link target (Getter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get uri() {
                    let retVal = Module.ViewingPdfAnnotsWebLinkGetUri(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * The link target (Setter)
                *
                *
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set uri(uri) {
                    if (typeof uri !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'uri' must be of type string and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsWebLinkSetUri(this.handle, uri);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.WebLink = WebLink;
            /**
             * A link to an embedded PDF document
             *
             */
            class EmbeddedPdfLink extends PdfViewing.Pdf.Annotations.Link {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new EmbeddedPdfLink(handle);
                }
                /**
                * The opening behavior (Getter)
                *
                * This defines the viewer's behavior when opening the target PDF document.
                *   - `null`: The viewer uses its default behavior.
                *   - `true`: Open the document in an additional window.
                *   - `false`: Replace the parent document with the embedded document.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get newWindow() {
                    let retVal = Module.ViewingPdfAnnotsEmbeddedPdfLinkGetNewWindow(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The opening behavior (Setter)
                *
                * This defines the viewer's behavior when opening the target PDF document.
                *   - `null`: The viewer uses its default behavior.
                *   - `true`: Open the document in an additional window.
                *   - `false`: Replace the parent document with the embedded document.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set newWindow(newWindow) {
                    if (newWindow !== null && newWindow !== undefined && (typeof newWindow !== 'boolean'))
                        throw new PdfViewing.ArgumentError("Argument 'newWindow' must be of type boolean or can be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsEmbeddedPdfLinkSetNewWindow(this.handle, newWindow);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.EmbeddedPdfLink = EmbeddedPdfLink;
            /**
             *
             */
            class AnnotationStroke extends Internal.NativeObject {
                /**
                 *
                 */
                constructor() {
                    if (arguments[0] && typeof arguments[0].__handle === `number`)
                        super(arguments[0].__handle);
                    else {
                        super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfAnnotsNewAnnotationStroke()));
                    }
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new AnnotationStroke({ __handle: handle });
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfAnnotsAnnotationStrokeClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * Width of the line in points
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get lineWidth() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationStrokeGetLineWidth(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Width of the line in points
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set lineWidth(lineWidth) {
                    if (typeof lineWidth !== 'number')
                        throw new PdfViewing.ArgumentError("Argument 'lineWidth' must be of type number and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsAnnotationStrokeSetLineWidth(this.handle, lineWidth);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * Describes the sequence of dashlength and gaplength of the dashing pattern, starting with a dash in points. The pattern is repeated.
                * Leaving the {@link PdfViewing.Pdf.Annotations.AnnotationStroke.dashArray } empty results in a solid line.
                * The {@link PdfViewing.Pdf.Annotations.AnnotationStroke.dashArray } is ignored if the Annotation has a {@link PdfViewing.Pdf.Annotations.BorderStyleType } property that is not set to {@link PdfViewing.Pdf.Annotations.BorderStyleType.Lined }.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get dashArray() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationStrokeGetDashArray(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * Describes the sequence of dashlength and gaplength of the dashing pattern, starting with a dash in points. The pattern is repeated.
                * Leaving the {@link PdfViewing.Pdf.Annotations.AnnotationStroke.dashArray } empty results in a solid line.
                * The {@link PdfViewing.Pdf.Annotations.AnnotationStroke.dashArray } is ignored if the Annotation has a {@link PdfViewing.Pdf.Annotations.BorderStyleType } property that is not set to {@link PdfViewing.Pdf.Annotations.BorderStyleType.Lined }.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set dashArray(dashArray) {
                    if (!Array.isArray(dashArray))
                        throw new PdfViewing.ArgumentError("Argument 'dashArray' must be of type number and must not be null or undefined.");
                    let retVal = Module.ViewingPdfAnnotsAnnotationStrokeSetDashArray(this.handle, dashArray);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Annotations.AnnotationStroke = AnnotationStroke;
            /**
             *
             */
            class AnnotationList extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new AnnotationList(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfAnnotsAnnotationListClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                remove(element) {
                    throw new Error("Method not implemented.");
                }
                add(element) {
                    throw new Error("Method not implemented.");
                }
                addRange(inputList) {
                    throw new Error("Method not implemented.");
                }
                set(index, element) {
                    throw new Error("Method not implemented.");
                }
                clear() {
                    throw new Error("Method not implemented.");
                }
                get(index) {
                    let retVal = Module.ViewingPdfAnnotsAnnotationListGet(this.handle, index);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Annotations.Annotation.createDynamicObject(retVal);
                }
                getRange(index, count) {
                    throw new Error("Method not implemented.");
                }
                get size() {
                    let retVal = Module.ViewingPdfAnnotsAnnotationListGetCount(this.handle);
                    if (retVal === -1)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                [Symbol.iterator]() {
                    return new ListIterator(this);
                }
            }
            Annotations.AnnotationList = AnnotationList;
        })(Annotations = Pdf.Annotations || (Pdf.Annotations = {}));
        let Forms;
        (function (Forms) {
            /**
             * A form field widget
             *
             */
            class Widget extends PdfViewing.Pdf.Annotations.Annotation {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfFormsWidgetGetType(handle);
                    switch (type) {
                        case 0:
                            return new Widget(handle);
                        case 1:
                            return PdfViewing.Pdf.Forms.CheckBox.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Forms.RadioButton.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Forms.TextBox.createDynamicObject(handle);
                        case 4:
                            return PdfViewing.Pdf.Forms.ListBox.createDynamicObject(handle);
                        case 5:
                            return PdfViewing.Pdf.Forms.ComboBox.createDynamicObject(handle);
                        default:
                            return new Widget(handle);
                    }
                }
                /**
                * Editing this widget is not allowed.
                */
                get readOnly() {
                    let retVal = Module.ViewingPdfFormsWidgetGetReadOnly(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * When filling out form this field is not optional.
                */
                get required() {
                    let retVal = Module.ViewingPdfFormsWidgetGetRequired(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Forms.Widget = Widget;
            /**
             *
             * An empty box which can be marked with a checkmark.
             */
            class CheckBox extends PdfViewing.Pdf.Forms.Widget {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new CheckBox(handle);
                }
                /**
                 *
                 * Toggle whether the given box is checked.
                 */
                push() {
                    let retVal = Module.ViewingPdfFormsCheckBoxpush(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * Whether the box is checked
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get isChecked() {
                    let retVal = Module.ViewingPdfFormsCheckBoxGetIsChecked(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Forms.CheckBox = CheckBox;
            /**
             *
             * A radio button allows to choose one of multiple choices by selecting one of the buttons in a radio button group.
             */
            class RadioButton extends PdfViewing.Pdf.Forms.Widget {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new RadioButton(handle);
                }
                /**
                 *
                 * Toggle whether the given box is checked.
                 * If the radio button is not selected, then select it.
                 * If the radio button is selected and the radio button has {@link PdfViewing.Pdf.Forms.RadioButton.noSelectionAllowed } set to `true`, then deselect the radio button.
                 */
                push() {
                    let retVal = Module.ViewingPdfFormsRadioButtonpush(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * Whether this radiobutton may be deselected, resulting in no radiobuttons of this group being selected.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get noSelectionAllowed() {
                    let retVal = Module.ViewingPdfFormsRadioButtonGetNoSelectionAllowed(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Whether this button is selected.
                * Note that selecting one radio button might deselect other radio buttons.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get selected() {
                    let retVal = Module.ViewingPdfFormsRadioButtonGetSelected(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Forms.RadioButton = RadioButton;
            /**
             *
             * A text box allows the entry of arbitrary text.
             */
            class TextBox extends PdfViewing.Pdf.Forms.Widget {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new TextBox(handle);
                }
                /**
                * Whether horizontal scrolling of text is allowed in the text box
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get scrollAllowed() {
                    let retVal = Module.ViewingPdfFormsTextBoxGetScrollAllowed(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Whether the text is may be shown on multiple lines in the text box
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get multilineAllowed() {
                    let retVal = Module.ViewingPdfFormsTextBoxGetMultilineAllowed(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Interpret the given string as rich-text
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get textIsRichText() {
                    let retVal = Module.ViewingPdfFormsTextBoxGetTextIsRichText(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Whether text should be monospaced
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get comb() {
                    let retVal = Module.ViewingPdfFormsTextBoxGetComb(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The maximum amount of characters that {@link PdfViewing.Pdf.Forms.TextBox.text } may contain
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get maxLength() {
                    let retVal = Module.ViewingPdfFormsTextBoxGetMaxLength(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The text currently set in the text box
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get text() {
                    let retVal = Module.ViewingPdfFormsTextBoxGetText(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * The text currently set in the text box
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                * @throws {@link PdfViewing.ArgumentError} if the given {@link PdfViewing.Pdf.Forms.TextBox.maxLength } was exceeded
                */
                set text(text) {
                    if (typeof text !== 'string')
                        throw new PdfViewing.ArgumentError("Argument 'text' must be of type string and must not be null or undefined.");
                    let retVal = Module.ViewingPdfFormsTextBoxSetText(this.handle, text);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Forms.TextBox = TextBox;
            /**
             *
             * A list box shows a scrollable list of choices in a box.
             */
            class ListBox extends PdfViewing.Pdf.Forms.Widget {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new ListBox(handle);
                }
                /**
                * Whether multiple options may be selected.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get multiSelectAllowed() {
                    let retVal = Module.ViewingPdfFormsListBoxGetMultiSelectAllowed(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * List of strings which can be chosen for this box.
                */
                get options() {
                    let retVal = Module.ViewingPdfFormsListBoxGetOptions(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.StringList.createDynamicObject(retVal);
                }
                /**
                * This is a set of indices indicating which of the {@link PdfViewing.Pdf.Forms.ListBox.options } are currently chosen.
                * Index values may range from 0 up to size of {@link PdfViewing.Pdf.Forms.ListBox.options } - 1.
                */
                get chosen() {
                    let retVal = Module.ViewingPdfFormsListBoxGetChosen(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.IntegerSet.createDynamicObject(retVal);
                }
                /**
                * This is a set of indices indicating which of the {@link PdfViewing.Pdf.Forms.ListBox.options } are currently chosen.
                * Index values may range from 0 up to size of {@link PdfViewing.Pdf.Forms.ListBox.options } - 1.
                *
                * @throws {@link PdfViewing.ArgumentError} An index is not in the allowed range.
                */
                set chosen(chosen) {
                    if (!(chosen instanceof PdfViewing.IntegerSet))
                        throw new PdfViewing.ArgumentError("Argument 'chosen' must be of type PdfViewing.IntegerSet and must not be null or undefined.");
                    let retVal = Module.ViewingPdfFormsListBoxSetChosen(this.handle, chosen.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Forms.ListBox = ListBox;
            /**
             *
             * A combo box shows a scrollable list of choices in a drop-down menu potentially combined with an editable custom entry.
             */
            class ComboBox extends PdfViewing.Pdf.Forms.Widget {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new ComboBox(handle);
                }
                /**
                * Whether the combo box supports an editable custom entry instead of one of the {@link PdfViewing.Pdf.Forms.ComboBox.options }
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get customEntryAllowed() {
                    let retVal = Module.ViewingPdfFormsComboBoxGetCustomEntryAllowed(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * If {@link PdfViewing.Pdf.Forms.ComboBox.customEntryAllowed } is set a custom entry can be used instead of the entries in {@link PdfViewing.Pdf.Forms.ComboBox.options }.
                * Setting {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } to any value other than `null` automatically sets {@link PdfViewing.Pdf.Forms.ComboBox.chosen } to `null`.
                * Conversely, setting {@link PdfViewing.Pdf.Forms.ComboBox.chosen } to any value other than `null` automatically sets {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } to `null`.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get customEntry() {
                    let retVal = Module.ViewingPdfFormsComboBoxGetCustomEntry(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * If {@link PdfViewing.Pdf.Forms.ComboBox.customEntryAllowed } is set a custom entry can be used instead of the entries in {@link PdfViewing.Pdf.Forms.ComboBox.options }.
                * Setting {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } to any value other than `null` automatically sets {@link PdfViewing.Pdf.Forms.ComboBox.chosen } to `null`.
                * Conversely, setting {@link PdfViewing.Pdf.Forms.ComboBox.chosen } to any value other than `null` automatically sets {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } to `null`.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                * @throws {@link PdfViewing.NotSupportedError} Setting a Custom Entry is only allowed if {@link PdfViewing.Pdf.Forms.ComboBox.customEntryAllowed } is set to `true`.
                * @throws {@link PdfViewing.ArgumentError} {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } may not be set to `null`.
                */
                set customEntry(customEntry) {
                    if (customEntry !== null && customEntry !== undefined && (typeof customEntry !== 'string'))
                        throw new PdfViewing.ArgumentError("Argument 'customEntry' must be of type string or can be null or undefined.");
                    let retVal = Module.ViewingPdfFormsComboBoxSetCustomEntry(this.handle, customEntry);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * List of strings which can be chosen for this box.
                */
                get options() {
                    let retVal = Module.ViewingPdfFormsComboBoxGetOptions(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.StringList.createDynamicObject(retVal);
                }
                /**
                * The index of the currently chosen Option from {@link PdfViewing.Pdf.Forms.ComboBox.options }.
                * Setting {@link PdfViewing.Pdf.Forms.ComboBox.chosen } to any value other than `null` automatically sets {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } to `null`.
                * Conversely, setting {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } to any value other than `null` automatically sets {@link PdfViewing.Pdf.Forms.ComboBox.chosen } to `null`.
                */
                get chosen() {
                    let retVal = Module.ViewingPdfFormsComboBoxGetChosen(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The index of the currently chosen Option from {@link PdfViewing.Pdf.Forms.ComboBox.options }.
                * Setting {@link PdfViewing.Pdf.Forms.ComboBox.chosen } to any value other than `null` automatically sets {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } to `null`.
                * Conversely, setting {@link PdfViewing.Pdf.Forms.ComboBox.customEntry } to any value other than `null` automatically sets {@link PdfViewing.Pdf.Forms.ComboBox.chosen } to `null`.
                *
                * @throws {@link PdfViewing.ArgumentError} Index is not in the allowed range.
                * @throws {@link PdfViewing.ArgumentError} {@link PdfViewing.Pdf.Forms.ComboBox.chosen } may not be set to `null`.
                */
                set chosen(chosen) {
                    if (chosen !== null && chosen !== undefined && (typeof chosen !== 'number'))
                        throw new PdfViewing.ArgumentError("Argument 'chosen' must be of type number or can be null or undefined.");
                    let retVal = Module.ViewingPdfFormsComboBoxSetChosen(this.handle, chosen);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Forms.ComboBox = ComboBox;
        })(Forms = Pdf.Forms || (Pdf.Forms = {}));
        let Geometry;
        (function (Geometry) {
            /**
             *
             * Values represent the Rotation in degrees clockwise.
             */
            let Rotation;
            (function (Rotation) {
                /**
                 *
                 */
                Rotation[Rotation["NoRotation"] = 0] = "NoRotation";
                /**
                 *
                 */
                Rotation[Rotation["Clockwise"] = 90] = "Clockwise";
                /**
                 *
                 */
                Rotation[Rotation["UpsideDown"] = 180] = "UpsideDown";
                /**
                 *
                 */
                Rotation[Rotation["CounterClockwise"] = 270] = "CounterClockwise";
            })(Rotation = Geometry.Rotation || (Geometry.Rotation = {}));
            let Real;
            (function (Real) {
                /**
                 *
                 */
                class Size extends Internal.NativeBase {
                    constructor(width, height) {
                        super();
                        if (typeof width !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'width' must be of type number and must not be null or undefined.");
                        if (typeof height !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'height' must be of type number and must not be null or undefined.");
                        this.width = width;
                        this.height = height;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.width !== obj.width)
                            return false;
                        if (this.height !== obj.height)
                            return false;
                        return true;
                    }
                }
                Real.Size = Size;
                /**
                 *
                 */
                class Point extends Internal.NativeBase {
                    constructor(x, y) {
                        super();
                        if (typeof x !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'x' must be of type number and must not be null or undefined.");
                        if (typeof y !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'y' must be of type number and must not be null or undefined.");
                        this.x = x;
                        this.y = y;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.x !== obj.x)
                            return false;
                        if (this.y !== obj.y)
                            return false;
                        return true;
                    }
                }
                Real.Point = Point;
                /**
                 *
                 * A point relative to a PDF Page in PDF coordinates (double), the origin is at the bottom-left of the page, x increasing to the right and y increasing upwards.
                 */
                class PointOnPage extends Internal.NativeBase {
                    constructor(pageNumber, x, y) {
                        super();
                        if (typeof pageNumber !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                        if (typeof x !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'x' must be of type number and must not be null or undefined.");
                        if (typeof y !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'y' must be of type number and must not be null or undefined.");
                        this.pageNumber = pageNumber;
                        this.x = x;
                        this.y = y;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.pageNumber !== obj.pageNumber)
                            return false;
                        if (this.x !== obj.x)
                            return false;
                        if (this.y !== obj.y)
                            return false;
                        return true;
                    }
                }
                Real.PointOnPage = PointOnPage;
                /**
                 *
                 * A quadrilateral is a polygon with four sides and four corners.
                 * When associated with text, the horizontal text writing direction goes from {@link PdfViewing.Pdf.Geometry.Real.QuadrilateralOnPage.pageNumber } to {@link PdfViewing.Pdf.Geometry.Real.QuadrilateralOnPage.pageNumber }.
                 */
                class QuadrilateralOnPage extends Internal.NativeBase {
                    constructor(pageNumber, bottomLeft, bottomRight, topRight, topLeft) {
                        super();
                        if (typeof pageNumber !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                        if (typeof bottomLeft !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'bottomLeft' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        if (typeof bottomRight !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'bottomRight' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        if (typeof topRight !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'topRight' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        if (typeof topLeft !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'topLeft' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        this.pageNumber = pageNumber;
                        this.bottomLeft = bottomLeft;
                        this.bottomRight = bottomRight;
                        this.topRight = topRight;
                        this.topLeft = topLeft;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.pageNumber !== obj.pageNumber)
                            return false;
                        if (!this.bottomLeft.equals(obj.bottomLeft))
                            return false;
                        if (!this.bottomRight.equals(obj.bottomRight))
                            return false;
                        if (!this.topRight.equals(obj.topRight))
                            return false;
                        if (!this.topLeft.equals(obj.topLeft))
                            return false;
                        return true;
                    }
                }
                Real.QuadrilateralOnPage = QuadrilateralOnPage;
                /**
                 *
                 * A rectangle relative to a PDF Page in PDF coordinates (double), the origin is at the bottom-left of the page , x increasing to the right and y increasing upwards
                 */
                class RectangleOnPage extends Internal.NativeBase {
                    constructor(pageNumber, x, y, width, height) {
                        super();
                        if (typeof pageNumber !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                        if (typeof x !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'x' must be of type number and must not be null or undefined.");
                        if (typeof y !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'y' must be of type number and must not be null or undefined.");
                        if (typeof width !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'width' must be of type number and must not be null or undefined.");
                        if (typeof height !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'height' must be of type number and must not be null or undefined.");
                        this.pageNumber = pageNumber;
                        this.x = x;
                        this.y = y;
                        this.width = width;
                        this.height = height;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.pageNumber !== obj.pageNumber)
                            return false;
                        if (this.x !== obj.x)
                            return false;
                        if (this.y !== obj.y)
                            return false;
                        if (this.width !== obj.width)
                            return false;
                        if (this.height !== obj.height)
                            return false;
                        return true;
                    }
                }
                Real.RectangleOnPage = RectangleOnPage;
                /**
                 *
                 * A point relative to a PDF Page in PDF coordinates (double), the origin is at the bottom-left of the page, x increasing to the right and y increasing upwards.
                 * This point will join 2 lines.
                 */
                class Vertex extends Internal.NativeBase {
                    constructor(pageNumber, x, y, operator) {
                        super();
                        if (typeof pageNumber !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                        if (typeof x !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'x' must be of type number and must not be null or undefined.");
                        if (typeof y !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'y' must be of type number and must not be null or undefined.");
                        if (typeof operator !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'operator' must be of type PdfViewing.Pdf.Geometry.Real.PathOperation and must not be null or undefined.");
                        this.pageNumber = pageNumber;
                        this.x = x;
                        this.y = y;
                        this.operator = operator;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.pageNumber !== obj.pageNumber)
                            return false;
                        if (this.x !== obj.x)
                            return false;
                        if (this.y !== obj.y)
                            return false;
                        if (this.operator !== obj.operator)
                            return false;
                        return true;
                    }
                }
                Real.Vertex = Vertex;
                /**
                 *
                 * Values represent the type of path operation on the vertex.
                 */
                let PathOperation;
                (function (PathOperation) {
                    /**
                     *
                     */
                    PathOperation[PathOperation["MoveTo"] = 0] = "MoveTo";
                    /**
                     *
                     */
                    PathOperation[PathOperation["LineTo"] = 1] = "LineTo";
                })(PathOperation = Real.PathOperation || (Real.PathOperation = {}));
                /**
                 *
                 * A List of {@link PdfViewing.Pdf.Geometry.Real.RectangleOnPage }s
                 */
                class RectangleOnPageList extends Internal.NativeObject {
                    /** @internal */
                    constructor(handle) {
                        super(handle);
                    }
                    /** @internal */
                    static createDynamicObject(handle) {
                        return new RectangleOnPageList(handle);
                    }
                    /**
                     * Close the object
                     *
                     * Release all native resources associated with the object.
                     */
                    close() {
                        if (!Module.ViewingPdfGeomRealRectangleOnPageListClose(this.handle))
                            Internal.NativeBase.throwLastError();
                    }
                    remove(element) {
                        throw new Error("Method not implemented.");
                    }
                    add(element) {
                        throw new Error("Method not implemented.");
                    }
                    addRange(inputList) {
                        throw new Error("Method not implemented.");
                    }
                    set(index, element) {
                        throw new Error("Method not implemented.");
                    }
                    clear() {
                        throw new Error("Method not implemented.");
                    }
                    get(index) {
                        let retVal = Module.ViewingPdfGeomRealRectangleOnPageListGet(this.handle, index);
                        if (retVal === null)
                            Internal.NativeBase.throwLastError(false);
                        return new PdfViewing.Pdf.Geometry.Real.RectangleOnPage(retVal.pageNumber, retVal.x, retVal.y, retVal.width, retVal.height);
                    }
                    getRange(index, count) {
                        throw new Error("Method not implemented.");
                    }
                    get size() {
                        let retVal = Module.ViewingPdfGeomRealRectangleOnPageListGetCount(this.handle);
                        if (retVal === -1)
                            Internal.NativeBase.throwLastError(false);
                        return retVal;
                    }
                    [Symbol.iterator]() {
                        return new ListIterator(this);
                    }
                }
                Real.RectangleOnPageList = RectangleOnPageList;
                /**
                 *
                 * A path described by a series of vertices.
                 */
                class Path extends Internal.NativeObject {
                    /**
                     *
                     */
                    constructor() {
                        if (arguments[0] && typeof arguments[0].__handle === `number`)
                            super(arguments[0].__handle);
                        else {
                            super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfGeomRealNewPath()));
                        }
                    }
                    /** @internal */
                    static createDynamicObject(handle) {
                        return new Path({ __handle: handle });
                    }
                    /**
                    * List of vertices joined as a path.
                    *
                    * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                    */
                    get vertices() {
                        let retVal = Module.ViewingPdfGeomRealPathGetVertices(this.handle);
                        if (retVal === 0)
                            Internal.NativeBase.throwLastError(false);
                        return PdfViewing.Pdf.Geometry.Real.VertexList.createDynamicObject(retVal);
                    }
                    /**
                    * List of vertices joined as a path.
                    *
                    * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                    * @throws {@link PdfViewing.ArgumentError} The vertex list starts with a {@link PdfViewing.Pdf.Geometry.Real.PathOperation.LineTo }
                    *         or contains two successive {@link PdfViewing.Pdf.Geometry.Real.PathOperation.MoveTo }s
                    */
                    set vertices(vertices) {
                        if (!(vertices instanceof PdfViewing.Pdf.Geometry.Real.VertexList))
                            throw new PdfViewing.ArgumentError("Argument 'vertices' must be of type PdfViewing.Pdf.Geometry.Real.VertexList and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealPathSetVertices(this.handle, vertices.handle);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                    }
                }
                Real.Path = Path;
                /**
                 *
                 * A List of {@link PdfViewing.Pdf.Geometry.Real.RectangleOnPage }s
                 */
                class PathGenerator extends Internal.NativeObject {
                    /**
                     * Create a new path generator for appending to a path.
                     *
                     * @param path
                     * the path object
                     *
                     * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Geometry.Real.PathGenerator. path} argument is `null`
                     * @throws {@link PdfViewing.ArgumentError} if the {@link PdfViewing.Pdf.Geometry.Real.PathGenerator. path} object has already been closed
                     */
                    constructor(path) {
                        if (arguments[0] && typeof arguments[0].__handle === `number`)
                            super(arguments[0].__handle);
                        else {
                            if (!(path instanceof PdfViewing.Pdf.Geometry.Real.Path))
                                throw new PdfViewing.ArgumentError("Argument 'path' must be of type PdfViewing.Pdf.Geometry.Real.Path and must not be null or undefined.");
                            super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfGeomRealNewPathGenerator(path.handle)));
                        }
                    }
                    /** @internal */
                    static createDynamicObject(handle) {
                        return new PathGenerator({ __handle: handle });
                    }
                    /**
                     * Close the object
                     *
                     * Release all native resources associated with the object.
                     */
                    close() {
                        if (!Module.ViewingPdfGeomRealPathGeneratorClose(this.handle))
                            Internal.NativeBase.throwLastError();
                    }
                    /**
                     * Move the current position.
                     *
                     * Begin a new subpath by moving the current point to the specified coordinates,
                     * omitting any connecting line segment.
                     * If the previous path construction operator in the current path was also MoveTo,
                     * the new MoveTo overrides it;
                     * no vestige of the previous MoveTo operation remains in the path.
                     * @param target
                     * the target coordinates
                     *
                     * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                     * @throws {@link PdfViewing.InvalidOperationError} if the path object has already been closed
                     */
                    moveTo(target) {
                        if (typeof target !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'target' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealPathGeneratorMoveTo(this.handle, target);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                    }
                    /**
                     * Draw a line.
                     *
                     * Append a straight line segment from the current point to the target coordinates.
                     * The current position is changed to the target position.
                     * @param target
                     * the target coordinates
                     *
                     * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                     * @throws {@link PdfViewing.InvalidOperationError} if the path object has already been closed
                     */
                    lineTo(target) {
                        if (typeof target !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'target' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealPathGeneratorLineTo(this.handle, target);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                    }
                    /**
                     * Draw a bezier curve.
                     *
                     * Append a cubic Bézier curve to the current path.
                     * The curve extends from the current point to the {@link PdfViewing.Pdf.Geometry.Real.PathGenerator.bezierTo target} position,
                     * using {@link PdfViewing.Pdf.Geometry.Real.PathGenerator.bezierTo ctrl1} and {@link PdfViewing.Pdf.Geometry.Real.PathGenerator.bezierTo ctrl2} as the Bézier control points.
                     * The current position is changed to the target position.
                     * @param ctrl1
                     * the first bezier control point
                     * @param ctrl2
                     * the second bezier control point
                     * @param target
                     * the target coordinates
                     *
                     * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                     * @throws {@link PdfViewing.InvalidOperationError} if the path object has already been closed
                     */
                    bezierTo(ctrl1, ctrl2, target) {
                        if (typeof ctrl1 !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'ctrl1' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        if (typeof ctrl2 !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'ctrl2' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        if (typeof target !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'target' must be of type PdfViewing.Pdf.Geometry.Real.Point and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealPathGeneratorBezierTo(this.handle, ctrl1, ctrl2, target);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                    }
                    /**
                     * Close the current subpath.
                     *
                     * Close the current subpath by appending a straight line segment from the
                     * current point to the starting point of the subpath.
                     * This operator terminates the current subpath;
                     * appending another segment to the current path will begin a new subpath,
                     * even if the new segment begins at the endpoint reached by the closeSubpath() operation.
                     * If the current subpath is already closed, CloseSubpath() does nothing.
                     *
                     * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                     * @throws {@link PdfViewing.InvalidOperationError} if the path object has already been closed
                     */
                    closeSubpath() {
                        let retVal = Module.ViewingPdfGeomRealPathGeneratorCloseSubpath(this.handle);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                    }
                    /**
                     * Append a rectangle to the current path as a complete subpath.
                     *
                     * @param rect
                     * the rectangle to be added to the path
                     *
                     * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                     * @throws {@link PdfViewing.InvalidOperationError} if the path object has already been closed
                     */
                    addRectangle(rect) {
                        if (typeof rect !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'rect' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealPathGeneratorAddRectangle(this.handle, rect);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                    }
                }
                Real.PathGenerator = PathGenerator;
                /**
                 *
                 */
                class QuadrilateralList extends Internal.NativeObject {
                    /**
                     *
                     */
                    constructor() {
                        if (arguments[0] && typeof arguments[0].__handle === `number`)
                            super(arguments[0].__handle);
                        else {
                            super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfGeomRealNewQuadrilateralList()));
                        }
                    }
                    /** @internal */
                    static createDynamicObject(handle) {
                        return new QuadrilateralList({ __handle: handle });
                    }
                    /**
                     * Close the object
                     *
                     * Release all native resources associated with the object.
                     */
                    close() {
                        if (!Module.ViewingPdfGeomRealQuadrilateralListClose(this.handle))
                            Internal.NativeBase.throwLastError();
                    }
                    /**
                     *
                     * @param pointOnPage
                     * @returns
                     *
                     * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                     */
                    contains(pointOnPage) {
                        if (typeof pointOnPage !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'pointOnPage' must be of type PdfViewing.Pdf.Geometry.Real.PointOnPage and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealQuadrilateralListContains(this.handle, pointOnPage);
                        if (!retVal)
                            Internal.NativeBase.throwLastError();
                        return retVal;
                    }
                    /**
                    * The smallest rectangle which contains all quadrilaterals of this list.
                    *
                    * @throws {@link PdfViewing.ArgumentError} Property may not be read if the list is empty.
                    */
                    get boundingBox() {
                        let retVal = Module.ViewingPdfGeomRealQuadrilateralListGetBoundingBox(this.handle);
                        if (retVal === null)
                            Internal.NativeBase.throwLastError(false);
                        return new PdfViewing.Pdf.Geometry.Real.RectangleOnPage(retVal.pageNumber, retVal.x, retVal.y, retVal.width, retVal.height);
                    }
                    remove(element) {
                        throw new Error("Method not implemented.");
                    }
                    add(element) {
                        if (typeof element !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'element' must be of type PdfViewing.Pdf.Geometry.Real.QuadrilateralOnPage and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealQuadrilateralListAdd(this.handle, element);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                        return true;
                    }
                    addRange(inputList) {
                        throw new Error("Method not implemented.");
                    }
                    set(index, element) {
                        throw new Error("Method not implemented.");
                    }
                    clear() {
                        throw new Error("Method not implemented.");
                    }
                    get(index) {
                        let retVal = Module.ViewingPdfGeomRealQuadrilateralListGet(this.handle, index);
                        if (retVal === null)
                            Internal.NativeBase.throwLastError(false);
                        return new PdfViewing.Pdf.Geometry.Real.QuadrilateralOnPage(retVal.pageNumber, retVal.bottomLeft, retVal.bottomRight, retVal.topRight, retVal.topLeft);
                    }
                    getRange(index, count) {
                        throw new Error("Method not implemented.");
                    }
                    get size() {
                        let retVal = Module.ViewingPdfGeomRealQuadrilateralListGetCount(this.handle);
                        if (retVal === -1)
                            Internal.NativeBase.throwLastError(false);
                        return retVal;
                    }
                    [Symbol.iterator]() {
                        return new ListIterator(this);
                    }
                }
                Real.QuadrilateralList = QuadrilateralList;
                /**
                 *
                 */
                class VertexList extends Internal.NativeObject {
                    /**
                     *
                     */
                    constructor() {
                        if (arguments[0] && typeof arguments[0].__handle === `number`)
                            super(arguments[0].__handle);
                        else {
                            super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfGeomRealNewVertexList()));
                        }
                    }
                    /** @internal */
                    static createDynamicObject(handle) {
                        return new VertexList({ __handle: handle });
                    }
                    /** @internal */
                    indexOf(element) {
                        for (var i = 0; i < this.size; i++) {
                            if (element.equals(this.get(i)))
                                return i;
                        }
                        return -1;
                    }
                    remove(element) {
                        if (typeof element !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'element' must be of type PdfViewing.Pdf.Geometry.Real.Vertex and must not be null or undefined.");
                        let index = this.indexOf(element);
                        if (index == -1)
                            return false;
                        let retVal = Module.ViewingPdfGeomRealVertexListRemove(this.handle, index);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                        return true;
                    }
                    add(element) {
                        if (typeof element !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'element' must be of type PdfViewing.Pdf.Geometry.Real.Vertex and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealVertexListAdd(this.handle, element);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                        return true;
                    }
                    addRange(inputList) {
                        if (!(inputList instanceof PdfViewing.Pdf.Geometry.Real.VertexList))
                            throw new PdfViewing.ArgumentError("Argument 'inputList' must be of type PdfViewing.Pdf.Geometry.Real.VertexList and must not be null or undefined.");
                        if (inputList.size == 0)
                            return false;
                        let retVal = Module.ViewingPdfGeomRealVertexListAddRange(this.handle, inputList);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                        return true;
                    }
                    set(index, element) {
                        if (typeof element !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'element' must be of type PdfViewing.Pdf.Geometry.Real.Vertex and must not be null or undefined.");
                        let retVal = Module.ViewingPdfGeomRealVertexListSet(this.handle, index, element);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                    }
                    clear() {
                        let retVal = Module.ViewingPdfGeomRealVertexListClear(this.handle);
                        if (!retVal)
                            Internal.NativeBase.throwLastError(false);
                    }
                    get(index) {
                        let retVal = Module.ViewingPdfGeomRealVertexListGet(this.handle, index);
                        if (retVal === null)
                            Internal.NativeBase.throwLastError(false);
                        return new PdfViewing.Pdf.Geometry.Real.Vertex(retVal.pageNumber, retVal.x, retVal.y, retVal.operator);
                    }
                    getRange(index, count) {
                        let retVal = Module.ViewingPdfGeomRealVertexListGetRange(this.handle, index, count);
                        if (retVal == 0)
                            Internal.NativeBase.throwLastError(false);
                        return VertexList.createDynamicObject(retVal);
                    }
                    get size() {
                        let retVal = Module.ViewingPdfGeomRealVertexListGetCount(this.handle);
                        if (retVal === -1)
                            Internal.NativeBase.throwLastError(false);
                        return retVal;
                    }
                    [Symbol.iterator]() {
                        return new ListIterator(this);
                    }
                }
                Real.VertexList = VertexList;
            })(Real = Geometry.Real || (Geometry.Real = {}));
            let Integer;
            (function (Integer) {
                /**
                 *
                 */
                class Size extends Internal.NativeBase {
                    constructor(width, height) {
                        super();
                        if (typeof width !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'width' must be of type number and must not be null or undefined.");
                        if (typeof height !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'height' must be of type number and must not be null or undefined.");
                        this.width = width;
                        this.height = height;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.width !== obj.width)
                            return false;
                        if (this.height !== obj.height)
                            return false;
                        return true;
                    }
                }
                Integer.Size = Size;
                /**
                 *
                 * Describes the current position of the viewport on the document. Origin top left.
                 */
                class ScrollPosition extends Internal.NativeBase {
                    constructor(x, y) {
                        super();
                        if (typeof x !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'x' must be of type number and must not be null or undefined.");
                        if (typeof y !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'y' must be of type number and must not be null or undefined.");
                        this.x = x;
                        this.y = y;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.x !== obj.x)
                            return false;
                        if (this.y !== obj.y)
                            return false;
                        return true;
                    }
                }
                Integer.ScrollPosition = ScrollPosition;
                /**
                 *
                 * A point relative to the viewport in viewport coordinates (integer), the origin is at the top-left of the viewport, x increasing to the right and y increasing downwards
                 */
                class Point extends Internal.NativeBase {
                    constructor(x, y) {
                        super();
                        if (typeof x !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'x' must be of type number and must not be null or undefined.");
                        if (typeof y !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'y' must be of type number and must not be null or undefined.");
                        this.x = x;
                        this.y = y;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.x !== obj.x)
                            return false;
                        if (this.y !== obj.y)
                            return false;
                        return true;
                    }
                }
                Integer.Point = Point;
                /**
                 *
                 * A Rectangle relative to the viewport in viewport coordinates (integer), the origin is at the top-left of the viewport, x increasing to the right and y increasing downwards
                 */
                class Rectangle extends Internal.NativeBase {
                    constructor(x, y, width, height) {
                        super();
                        if (typeof x !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'x' must be of type number and must not be null or undefined.");
                        if (typeof y !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'y' must be of type number and must not be null or undefined.");
                        if (typeof width !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'width' must be of type number and must not be null or undefined.");
                        if (typeof height !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'height' must be of type number and must not be null or undefined.");
                        this.x = x;
                        this.y = y;
                        this.width = width;
                        this.height = height;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.x !== obj.x)
                            return false;
                        if (this.y !== obj.y)
                            return false;
                        if (this.width !== obj.width)
                            return false;
                        if (this.height !== obj.height)
                            return false;
                        return true;
                    }
                }
                Integer.Rectangle = Rectangle;
                /**
                 *
                 * A set of paddings to be added at the respective sides of a rectangular object.
                 */
                class Padding extends Internal.NativeBase {
                    constructor(left, right, top, bottom) {
                        super();
                        if (typeof left !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'left' must be of type number and must not be null or undefined.");
                        if (typeof right !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'right' must be of type number and must not be null or undefined.");
                        if (typeof top !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'top' must be of type number and must not be null or undefined.");
                        if (typeof bottom !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'bottom' must be of type number and must not be null or undefined.");
                        this.left = left;
                        this.right = right;
                        this.top = top;
                        this.bottom = bottom;
                    }
                    equals(obj) {
                        if (obj === null)
                            return false;
                        if (this.left !== obj.left)
                            return false;
                        if (this.right !== obj.right)
                            return false;
                        if (this.top !== obj.top)
                            return false;
                        if (this.bottom !== obj.bottom)
                            return false;
                        return true;
                    }
                }
                Integer.Padding = Padding;
            })(Integer = Geometry.Integer || (Geometry.Integer = {}));
        })(Geometry = Pdf.Geometry || (Pdf.Geometry = {}));
        let Content;
        (function (Content) {
            /**
             *
             */
            let Byteorder;
            (function (Byteorder) {
                /**
                 *
                 */
                Byteorder[Byteorder["Invalid"] = 0] = "Invalid";
            })(Byteorder = Content.Byteorder || (Content.Byteorder = {}));
            /**
             *
             * A List of {@link PdfViewing.Pdf.Content.TextFragment }s
             */
            class TextFragmentList extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new TextFragmentList(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentTextFragmentListClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                remove(element) {
                    throw new Error("Method not implemented.");
                }
                add(element) {
                    throw new Error("Method not implemented.");
                }
                addRange(inputList) {
                    throw new Error("Method not implemented.");
                }
                set(index, element) {
                    throw new Error("Method not implemented.");
                }
                clear() {
                    throw new Error("Method not implemented.");
                }
                get(index) {
                    let retVal = Module.ViewingPdfContentTextFragmentListGet(this.handle, index);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Content.TextFragment.createDynamicObject(retVal);
                }
                getRange(index, count) {
                    throw new Error("Method not implemented.");
                }
                get size() {
                    let retVal = Module.ViewingPdfContentTextFragmentListGetCount(this.handle);
                    if (retVal === -1)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                [Symbol.iterator]() {
                    return new ListIterator(this);
                }
            }
            Content.TextFragmentList = TextFragmentList;
            /**
             *
             * Calling `SearchText` returns a `TextSearchIterator` starting the search at the beginning of the specified page.
             * `GetNext` and `GetPrevious` starts the search in the respective direction and subsequent calls iterate further starting from the result of the previous call.
             * `null` is returned if no more results are found.
             */
            class TextSearchIterator extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                    this.eventListeners = new Map();
                }
                /**
                 * @event
                 */
                addEventListener(type, listener) {
                    if (typeof listener !== 'function')
                        throw new PdfViewing.ArgumentError("Argument 'listener' must be a function.");
                    var eventObj;
                    if (this.eventListeners.has(type)) {
                        if (!this.eventListeners.get(type).has(listener)) {
                            if (type === "matchChanged") {
                                eventObj = new MatchChangedNativeClass(listener);
                                let context = Module.ViewingPdfContentTextSearchIteratorAddMatchChangedHandler(this.handle, eventObj);
                                if (context == 0)
                                    Internal.NativeBase.throwLastError();
                                else
                                    eventObj.context = context;
                                this.eventListeners.get(type).set(listener, eventObj);
                            }
                        }
                        if (!this.eventListeners.get(type).has(listener)) {
                            if (type === "totalMatchesChanged") {
                                eventObj = new TotalMatchesChangedNativeClass(listener);
                                let context = Module.ViewingPdfContentTextSearchIteratorAddTotalMatchesChangedHandler(this.handle, eventObj);
                                if (context == 0)
                                    Internal.NativeBase.throwLastError();
                                else
                                    eventObj.context = context;
                                this.eventListeners.get(type).set(listener, eventObj);
                            }
                        }
                    }
                    else {
                        if (type === "matchChanged") {
                            eventObj = new MatchChangedNativeClass(listener);
                            let context = Module.ViewingPdfContentTextSearchIteratorAddMatchChangedHandler(this.handle, eventObj);
                            if (context == 0)
                                Internal.NativeBase.throwLastError();
                            else
                                eventObj.context = context;
                            let mapItem = new Map();
                            mapItem.set(listener, eventObj);
                            this.eventListeners.set(type, mapItem);
                        }
                        if (type === "totalMatchesChanged") {
                            eventObj = new TotalMatchesChangedNativeClass(listener);
                            let context = Module.ViewingPdfContentTextSearchIteratorAddTotalMatchesChangedHandler(this.handle, eventObj);
                            if (context == 0)
                                Internal.NativeBase.throwLastError();
                            else
                                eventObj.context = context;
                            let mapItem = new Map();
                            mapItem.set(listener, eventObj);
                            this.eventListeners.set(type, mapItem);
                        }
                    }
                }
                removeEventListener(type, listener) {
                    if (this.eventListeners.has(type)) {
                        if (type === "matchChanged") {
                            let listeners = this.eventListeners.get(type);
                            if (listeners.has(listener)) {
                                let eventObj = listeners.get(listener);
                                try {
                                    if (!Module.ViewingPdfContentTextSearchIteratorRemoveMatchChangedHandler(this.handle, eventObj === null || eventObj === void 0 ? void 0 : eventObj.context))
                                        Internal.NativeBase.throwLastError();
                                }
                                catch (err) {
                                    if (err instanceof NotFoundError)
                                        throw err;
                                }
                                listeners.delete(listener);
                                if (listeners.size === 0)
                                    this.eventListeners.delete("matchChanged");
                            }
                        }
                        if (type === "totalMatchesChanged") {
                            let listeners = this.eventListeners.get(type);
                            if (listeners.has(listener)) {
                                let eventObj = listeners.get(listener);
                                try {
                                    if (!Module.ViewingPdfContentTextSearchIteratorRemoveTotalMatchesChangedHandler(this.handle, eventObj === null || eventObj === void 0 ? void 0 : eventObj.context))
                                        Internal.NativeBase.throwLastError();
                                }
                                catch (err) {
                                    if (err instanceof NotFoundError)
                                        throw err;
                                }
                                listeners.delete(listener);
                                if (listeners.size === 0)
                                    this.eventListeners.delete("totalMatchesChanged");
                            }
                        }
                    }
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new TextSearchIterator(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentTextSearchIteratorClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                 *
                 * Update {@link PdfViewing.Pdf.Content.TextSearchIterator.match } to the next match in the document.
                 * If no further rersult can be found `false` is returned and {@link PdfViewing.Pdf.Content.TextSearchIterator.match } is not updated.
                 * @returns
                 *
                 * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                 */
                getNext() {
                    var thisHandle = this;
                    return new Promise(function (resolved, rejected) {
                        if (!Module.ViewingPdfContentTextSearchIteratorGetNext(thisHandle.handle, { thisHandle, resolved, rejected }))
                            rejected(Module.ViewingGetLastErrorMessage());
                    });
                }
                getNextCallback(context, retVal, errorCode, errorMessage) {
                    let error = null;
                    if (!retVal)
                        error = Internal.NativeBase.createLastError(errorCode, errorMessage);
                    if (error === null) {
                        context.resolved(retVal);
                    }
                    else
                        context.rejected(error);
                }
                /**
                 *
                 * Update {@link PdfViewing.Pdf.Content.TextSearchIterator.match } to the next match in the document in backwards direction.
                 * If no further rersult can be found `false` is returned and {@link PdfViewing.Pdf.Content.TextSearchIterator.match } is not updated.
                 * @returns
                 *
                 * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                 */
                getPrevious() {
                    var thisHandle = this;
                    return new Promise(function (resolved, rejected) {
                        if (!Module.ViewingPdfContentTextSearchIteratorGetPrevious(thisHandle.handle, { thisHandle, resolved, rejected }))
                            rejected(Module.ViewingGetLastErrorMessage());
                    });
                }
                getPreviousCallback(context, retVal, errorCode, errorMessage) {
                    let error = null;
                    if (!retVal)
                        error = Internal.NativeBase.createLastError(errorCode, errorMessage);
                    if (error === null) {
                        context.resolved(retVal);
                    }
                    else
                        context.rejected(error);
                }
                /**
                 *
                 * Start searching the entire document asynchronously.
                 * The property {@link PdfViewing.Pdf.Content.TextSearchIterator.totalMatches } will be updated continuously until the entire document has been searched.
                 * This is aborted if this {@link PdfViewing.Pdf.Content.TextSearchIterator } is closed.
                 * @returns newly created promise for further asynchronous processing.
                 *
                 * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                 */
                loadAllMatches() {
                    var thisHandle = this;
                    return new Promise(function (resolved, rejected) {
                        if (!Module.ViewingPdfContentTextSearchIteratorLoadAllMatches(thisHandle.handle, { thisHandle, resolved, rejected }))
                            rejected(Module.ViewingGetLastErrorMessage());
                    });
                }
                loadAllMatchesCallback(context, retVal, errorCode, errorMessage) {
                    let error = null;
                    if (!retVal)
                        error = Internal.NativeBase.createLastError(errorCode, errorMessage, false);
                    if (error === null) {
                        context.resolved();
                    }
                    else
                        context.rejected(error);
                }
                /**
                * The last text that was found with this search.
                * Initial value is `null`, call {@link PdfViewing.Pdf.Content.TextSearchIterator.getNext } or {@link PdfViewing.Pdf.Content.TextSearchIterator.getPrevious }
                * to get the next matching textselection in the respective direction.
                * Property remains unchanged if call to {@link PdfViewing.Pdf.Content.TextSearchIterator.getNext } or {@link PdfViewing.Pdf.Content.TextSearchIterator.getPrevious } returns `false`.
                * Matches can occur on different kind of content, being represented as different subtypes of {@link PdfViewing.Pdf.Content.Selection }.
                * To get positional information aboutselected text cast to the respective type. e.g. {@link PdfViewing.Pdf.Content.TextSelection } for any results in flowing text.
                */
                get match() {
                    let retVal = Module.ViewingPdfContentTextSearchIteratorGetMatch(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Content.Selection.createDynamicObject(retVal);
                }
                /**
                * Index of the current match since start of textsearchIterator.
                * First Match has index 1.
                */
                get matchIndex() {
                    let retVal = Module.ViewingPdfContentTextSearchIteratorGetMatchIndex(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Total known matches in document.
                * This number might not be correct if not all text is loaded.
                */
                get totalMatches() {
                    let retVal = Module.ViewingPdfContentTextSearchIteratorGetTotalMatches(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Whether when reaching beginning or end of document (depending on search direction)
                * search should be continued at other end.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get wrapping() {
                    let retVal = Module.ViewingPdfContentTextSearchIteratorGetWrapping(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Whether when reaching beginning or end of document (depending on search direction)
                * search should be continued at other end.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                set wrapping(wrapping) {
                    if (typeof wrapping !== 'boolean')
                        throw new PdfViewing.ArgumentError("Argument 'wrapping' must be of type boolean and must not be null or undefined.");
                    let retVal = Module.ViewingPdfContentTextSearchIteratorSetWrapping(this.handle, wrapping);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
            }
            Content.TextSearchIterator = TextSearchIterator;
            class EventTextSearchIteratorNativeBase {
                constructor(listener) {
                    this.listener = listener;
                }
            }
            class MatchChangedNativeClass extends EventTextSearchIteratorNativeBase {
                constructor(listener) {
                    super(listener);
                }
                dispatchEventMatchChanged(Match) {
                    this.listener(PdfViewing.Pdf.Content.TextSelection.createDynamicObject(Match));
                }
            }
            class TotalMatchesChangedNativeClass extends EventTextSearchIteratorNativeBase {
                constructor(listener) {
                    super(listener);
                }
                dispatchEventTotalMatchesChanged() {
                    this.listener(undefined);
                }
            }
            /**
             *
             * A rendered image of a page.
             * With high zoom only part of a page is rendered.
             */
            class Image extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfContentImageGetType(handle);
                    switch (type) {
                        case 0:
                            return new Image(handle);
                        case 1:
                            return PdfViewing.Pdf.Content.PlacedImage.createDynamicObject(handle);
                        default:
                            return new Image(handle);
                    }
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentImageClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                 *
                 * Removes image data from this image in order to reduce memory usage.
                 * This operation invalidates {@link PdfViewing.Pdf.Content.Image.samples } and {@link PdfViewing.Pdf.Content.Image.bufferView }.
                 * This functionality should only be used when image data has already been prepared in event `ImageCreated`.
                 *
                 * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                 */
                removeImageData() {
                    let retVal = Module.ViewingPdfContentImageRemoveImageData(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError(false);
                }
                /**
                * Indicates whether Image data has been removed using {@link PdfViewing.Pdf.Content.Image.removeImageData }.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get hasImageData() {
                    let retVal = Module.ViewingPdfContentImageGetHasImageData(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * A unique identifier for this image.
                * Note that the method {@link PdfViewing.Pdf.View.getRenderedResults }
                * returns the same image with the same ID multiple times to conserve memory.
                * Whenever an image is added to the internal cache {@link PdfViewing.Pdf.ViewingPdfViewEventMap.imageCreated } is triggered
                * and when removed from the cache the same ID is returned in event {@link PdfViewing.Pdf.ViewingPdfViewEventMap.imageRemovedFromCache }.
                * An identifier is only unique in the context of the associated {@link PdfViewing.ViewerController }.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get id() {
                    let retVal = Module.ViewingPdfContentImageGetId(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Width of the image in pixels
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get width() {
                    let retVal = Module.ViewingPdfContentImageGetWidth(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Height of the image in pixels
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get height() {
                    let retVal = Module.ViewingPdfContentImageGetHeight(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Number of bytes used per pixel of the image
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get bytePerPixel() {
                    let retVal = Module.ViewingPdfContentImageGetBytePerPixel(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * Raw byte array of the image.
                * This operation returns a copy of the internal buffer.
                * If image data has been removed using {@link PdfViewing.Pdf.Content.Image.removeImageData } this array will be empty.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get samples() {
                    let retVal = Module.ViewingPdfContentImageGetSamples(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new Uint8Array(retVal);
                }
                /**
                * A buffer view of the raw byte array of the image.
                * This operation returns a direct view on the internal buffer.
                * If image data has been removed using {@link PdfViewing.Pdf.Content.Image.removeImageData } this array will be empty.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get bufferView() {
                    let retVal = Module.ViewingPdfContentImageGetBufferView(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Content.Image = Image;
            /**
             *
             * An image that has a specific position on the viewport.
             */
            class PlacedImage extends PdfViewing.Pdf.Content.Image {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new PlacedImage(handle);
                }
                /**
                * Rectangle in relation to the page where the image should be rendered to.
                * Note, that the image might be in different resolution to the size of this rectangle.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get imageRectangle() {
                    let retVal = Module.ViewingPdfContentPlacedImageGetImageRectangle(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Integer.Rectangle(retVal.x, retVal.y, retVal.width, retVal.height);
                }
            }
            Content.PlacedImage = PlacedImage;
            /**
             *
             * A text fragment describes part of the text on a page.
             * Usually one text fragment is one line of text, but this may vary.
             */
            class TextFragment extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new TextFragment(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentTextFragmentClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * A rectangle where on the page the text is
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get rectangleOnPage() {
                    let retVal = Module.ViewingPdfContentTextFragmentGetRectangleOnPage(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Real.RectangleOnPage(retVal.pageNumber, retVal.x, retVal.y, retVal.width, retVal.height);
                }
                /**
                * A more accurate description where the text is on the page
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get textArea() {
                    let retVal = Module.ViewingPdfContentTextFragmentGetTextArea(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Real.QuadrilateralOnPage(retVal.pageNumber, retVal.bottomLeft, retVal.bottomRight, retVal.topRight, retVal.topLeft);
                }
                /**
                * The content of the text
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get text() {
                    let retVal = Module.ViewingPdfContentTextFragmentGetText(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * A list of offsets of the separate glyphs of the text.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get glyphOffsets() {
                    let retVal = Module.ViewingPdfContentTextFragmentGetGlyphOffsets(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
            }
            Content.TextFragment = TextFragment;
            /**
             *
             * A selection of text.
             */
            class Selection extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfContentSelectionGetType(handle);
                    switch (type) {
                        case 0:
                            return new Selection(handle);
                        case 1:
                            return PdfViewing.Pdf.Content.TextSelection.createDynamicObject(handle);
                        default:
                            return new Selection(handle);
                    }
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentSelectionClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * Actual content of text
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get text() {
                    let retVal = Module.ViewingPdfContentSelectionGetText(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Content.Selection = Selection;
            /**
             *
             * A selection of text in the pdf with an associated area on a page.
             */
            class TextSelection extends PdfViewing.Pdf.Content.Selection {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new TextSelection(handle);
                }
                /**
                * Area of all selected text. Used for highlighting.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get textArea() {
                    let retVal = Module.ViewingPdfContentTextSelectionGetTextArea(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Geometry.Real.QuadrilateralList.createDynamicObject(retVal);
                }
            }
            Content.TextSelection = TextSelection;
            /**
             *
             * Buffer of binary data
             */
            class BinaryBuffer extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new BinaryBuffer(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentBinaryBufferClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * Copy of raw buffer
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get bufferData() {
                    let retVal = Module.ViewingPdfContentBinaryBufferGetBufferData(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new Uint8Array(retVal);
                }
                /**
                * View on raw buffer
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get bufferView() {
                    let retVal = Module.ViewingPdfContentBinaryBufferGetBufferView(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Content.BinaryBuffer = BinaryBuffer;
            /**
             *
             * All information concerning a rendered page
             */
            class RenderedPage extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new RenderedPage(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentRenderedPageClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * Describes where a page is located on the viewport.
                * Conventionally a viewer should render this area as a white rectangle.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get pageRect() {
                    let retVal = Module.ViewingPdfContentRenderedPageGetPageRect(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Integer.Rectangle(retVal.x, retVal.y, retVal.width, retVal.height);
                }
                /**
                * Describes a rendered image of this page.
                * Depending on the zoom level and resolution this image may not contain the entire page.
                * The image's location and size are relative to the top-left corner of {@link PdfViewing.Pdf.Content.RenderedPage.pageRect }
                * Returns `null` if the page has not yet been rendered.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get image() {
                    let retVal = Module.ViewingPdfContentRenderedPageGetImage(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Content.PlacedImage.createDynamicObject(retVal) : null;
                }
                /**
                * The pagenumber within the document of this page.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get pageNumber() {
                    let retVal = Module.ViewingPdfContentRenderedPageGetPageNumber(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Content.RenderedPage = RenderedPage;
            /**
             *
             * A List of {@link PdfViewing.Pdf.Content.RenderedPage }s
             */
            class RenderedPageList extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new RenderedPageList(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentRenderedPageListClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                remove(element) {
                    throw new Error("Method not implemented.");
                }
                add(element) {
                    throw new Error("Method not implemented.");
                }
                addRange(inputList) {
                    throw new Error("Method not implemented.");
                }
                set(index, element) {
                    throw new Error("Method not implemented.");
                }
                clear() {
                    throw new Error("Method not implemented.");
                }
                get(index) {
                    let retVal = Module.ViewingPdfContentRenderedPageListGet(this.handle, index);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Content.RenderedPage.createDynamicObject(retVal);
                }
                getRange(index, count) {
                    throw new Error("Method not implemented.");
                }
                get size() {
                    let retVal = Module.ViewingPdfContentRenderedPageListGetCount(this.handle);
                    if (retVal === -1)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                [Symbol.iterator]() {
                    return new ListIterator(this);
                }
            }
            Content.RenderedPageList = RenderedPageList;
            /**
             *
             * Rendered results concerning the current view.
             */
            class RenderResults extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new RenderResults(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfContentRenderResultsClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * A list of all pages currently visible on the viewport.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get visiblePages() {
                    let retVal = Module.ViewingPdfContentRenderResultsGetVisiblePages(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Content.RenderedPageList.createDynamicObject(retVal);
                }
            }
            Content.RenderResults = RenderResults;
        })(Content = Pdf.Content || (Pdf.Content = {}));
        let Navigation;
        (function (Navigation) {
            /**
             *
             * Setting how the viewport will be fitted to the visible content
             */
            let FitMode;
            (function (FitMode) {
                /**
                 *
                 * Do not fit
                 */
                FitMode[FitMode["None"] = 0] = "None";
                /**
                 *
                 * Fit viewport to width of widest visible page
                 */
                FitMode[FitMode["FitWidth"] = 1] = "FitWidth";
                /**
                 *
                 * Fit viewport to be able to show largest visible page in its entirety
                 */
                FitMode[FitMode["FitPage"] = 2] = "FitPage";
            })(FitMode = Navigation.FitMode || (Navigation.FitMode = {}));
            /**
             *
             * Setting how the pages will be arranged on the viewport
             */
            let PageLayoutMode;
            (function (PageLayoutMode) {
                /**
                 *
                 * Display a single page at a time.
                 */
                PageLayoutMode[PageLayoutMode["SinglePage"] = 0] = "SinglePage";
                /**
                 *
                 * Display a Column of pages.
                 */
                PageLayoutMode[PageLayoutMode["OneColumn"] = 1] = "OneColumn";
                /**
                 *
                 * Display two columns of pages next to each other. The first page will be on the left.
                 */
                PageLayoutMode[PageLayoutMode["TwoColumnLeft"] = 2] = "TwoColumnLeft";
                /**
                 *
                 * Display two columns of pages next to each other. The first page will be on the right.
                 */
                PageLayoutMode[PageLayoutMode["TwoColumnRight"] = 3] = "TwoColumnRight";
                /**
                 *
                 * Display two pages next to each other. The first page will be on the left
                 */
                PageLayoutMode[PageLayoutMode["TwoPageLeft"] = 4] = "TwoPageLeft";
                /**
                 *
                 * Display two pages next to each other. The first page will be on the right
                 */
                PageLayoutMode[PageLayoutMode["TwoPageRight"] = 5] = "TwoPageRight";
            })(PageLayoutMode = Navigation.PageLayoutMode || (Navigation.PageLayoutMode = {}));
            /**
             *
             * A List of {@link PdfViewing.Pdf.Navigation.OutlineItem }s
             */
            class OutlineItemList extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new OutlineItemList(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfNavOutlineItemListClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                remove(element) {
                    throw new Error("Method not implemented.");
                }
                add(element) {
                    throw new Error("Method not implemented.");
                }
                addRange(inputList) {
                    throw new Error("Method not implemented.");
                }
                set(index, element) {
                    throw new Error("Method not implemented.");
                }
                clear() {
                    throw new Error("Method not implemented.");
                }
                get(index) {
                    let retVal = Module.ViewingPdfNavOutlineItemListGet(this.handle, index);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Navigation.OutlineItem.createDynamicObject(retVal);
                }
                getRange(index, count) {
                    throw new Error("Method not implemented.");
                }
                get size() {
                    let retVal = Module.ViewingPdfNavOutlineItemListGetCount(this.handle);
                    if (retVal === -1)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                [Symbol.iterator]() {
                    return new ListIterator(this);
                }
            }
            Navigation.OutlineItemList = OutlineItemList;
            /**
             *
             * A destination is a location in the document that
             * can be used as a jump target,
             * e.g. for outline items (bookmarks) or link annotations.
             */
            class Destination extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfNavDestinationGetType(handle);
                    switch (type) {
                        case 0:
                            return new Destination(handle);
                        case 1:
                            return PdfViewing.Pdf.Navigation.NamedDestination.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Navigation.DirectDestination.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Navigation.LocationZoomDestination.createDynamicObject(handle);
                        case 4:
                            return PdfViewing.Pdf.Navigation.FitPageDestination.createDynamicObject(handle);
                        case 5:
                            return PdfViewing.Pdf.Navigation.FitWidthDestination.createDynamicObject(handle);
                        case 6:
                            return PdfViewing.Pdf.Navigation.FitHeightDestination.createDynamicObject(handle);
                        case 7:
                            return PdfViewing.Pdf.Navigation.FitRectangleDestination.createDynamicObject(handle);
                        default:
                            return new Destination(handle);
                    }
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfNavDestinationClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * The target destination (Getter)
                *
                * For direct destinations,
                * this is just the destination itself.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get target() {
                    let retVal = Module.ViewingPdfNavDestinationGetTarget(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError(false);
                    return PdfViewing.Pdf.Navigation.DirectDestination.createDynamicObject(retVal);
                }
            }
            Navigation.Destination = Destination;
            /**
             *
             * A named destination that can be referred by name.
             * Named destinations have two advantages compared to direct destinations:
             *   - The name can be used in web links,
             * e.g. http://www.example.com/document.pdf#destinationname
             *   - If the target destination of a named destination is changed,
             * all occurrences automatically point ot the new target.
             */
            class NamedDestination extends PdfViewing.Pdf.Navigation.Destination {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new NamedDestination(handle);
                }
                /**
                * The name by which the destination is referred to.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get name() {
                    let retVal = Module.ViewingPdfNavNamedDestinationGetName(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
            }
            Navigation.NamedDestination = NamedDestination;
            /**
             *
             *
             * A destination that directly points to a specific location in the document.
             *
             * Note: Many PDF viewers support different viewing modes like "fit page" or
             * "fit width".
             * Most destination types will change the current viewing mode in those viewers.
             *
             * Changing the viewing mode is usually not very well received by users
             * and thus a {@link PdfViewing.Pdf.Navigation.LocationZoomDestination } should be preferred in most cases.
             */
            class DirectDestination extends PdfViewing.Pdf.Navigation.Destination {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    let type = Module.ViewingPdfNavDirectDestinationGetType(handle);
                    switch (type) {
                        case 0:
                            return new DirectDestination(handle);
                        case 1:
                            return PdfViewing.Pdf.Navigation.LocationZoomDestination.createDynamicObject(handle);
                        case 2:
                            return PdfViewing.Pdf.Navigation.FitPageDestination.createDynamicObject(handle);
                        case 3:
                            return PdfViewing.Pdf.Navigation.FitWidthDestination.createDynamicObject(handle);
                        case 4:
                            return PdfViewing.Pdf.Navigation.FitHeightDestination.createDynamicObject(handle);
                        case 5:
                            return PdfViewing.Pdf.Navigation.FitRectangleDestination.createDynamicObject(handle);
                        default:
                            return new DirectDestination(handle);
                    }
                }
                /**
                * The page in the document that this destination is pointing to.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get pageNumber() {
                    let retVal = Module.ViewingPdfNavDirectDestinationGetPageNumber(this.handle);
                    if (retVal === -1)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Navigation.DirectDestination = DirectDestination;
            /**
             *
             * A destination that points to a specific location on the target page,
             * using a specified zoom factor.
             * The location is displayed in the top left corner of the viewport (if possible).
             */
            class LocationZoomDestination extends PdfViewing.Pdf.Navigation.DirectDestination {
                /**
                 *
                 * Create a new {@link PdfViewing.Pdf.Navigation.LocationZoomDestination } object.
                 * @param pageNumber
                 * The page in the document that this destination is pointing to.
                 * @param left
                 *
                 * The location of the page that is displayed at the left border
                 * of the viewport or `null`.
                 *
                 * See property {@link PdfViewing.Pdf.Navigation.LocationZoomDestination.left } for more information.
                 * @param top
                 *
                 * The location of the page that is displayed at the top
                 * of the viewport or `null`.
                 *
                 * See property {@link PdfViewing.Pdf.Navigation.LocationZoomDestination.top } for more information.
                 * @param zoom
                 *
                 * The zoom factor that is applied when jumping to the destination
                 * or `null`.
                 *
                 * See property {@link PdfViewing.Pdf.Navigation.LocationZoomDestination.zoom } for more information.
                 */
                constructor(pageNumber, left, top, zoom) {
                    if (arguments[0] && typeof arguments[0].__handle === `number`)
                        super(arguments[0].__handle);
                    else {
                        if (typeof pageNumber !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                        if (left !== null && left !== undefined && (typeof left !== 'number'))
                            throw new PdfViewing.ArgumentError("Argument 'left' must be of type number or can be null or undefined.");
                        if (top !== null && top !== undefined && (typeof top !== 'number'))
                            throw new PdfViewing.ArgumentError("Argument 'top' must be of type number or can be null or undefined.");
                        if (zoom !== null && zoom !== undefined && (typeof zoom !== 'number'))
                            throw new PdfViewing.ArgumentError("Argument 'zoom' must be of type number or can be null or undefined.");
                        super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNavNewLocationZoomDestination(pageNumber, left, top, zoom)));
                    }
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new LocationZoomDestination({ __handle: handle });
                }
                /**
                *
                * The location of the page that is displayed at the left border of the viewport (if possible).
                *
                * If the property is `null`, the value from before the jump is retained.
                *
                * Note: Due to the current zoom factor,
                * it is usually not possible for viewers to scroll as far to the right side,
                * as would be necessary to place the location at the left corner of the viewport.
                * However, viewers will ensure, that the location is at least visible.
                *
                * In practice this means, that this value is mostly irrelevant.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get left() {
                    let retVal = Module.ViewingPdfNavLocationZoomDestinationGetLeft(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                *
                * The location of the page that is displayed at the top of the viewport (if possible).
                *
                * If the property is `null`, the value from before the jump is retained.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get top() {
                    let retVal = Module.ViewingPdfNavLocationZoomDestinationGetTop(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                *
                * The zoom factor that is applied when jumping to the destination.
                *
                * A value of `null` means that the current zoom level is retained.
                *
                * Note: Many PDF viewers support different viewing modes like "fit page" or "fit width".
                *
                * A {@link PdfViewing.Pdf.Navigation.LocationZoomDestination } with a {@link PdfViewing.Pdf.Navigation.LocationZoomDestination.zoom } value of `null`
                * will usually not change the current viewing mode in most viewers.
                *
                * For other {@link PdfViewing.Pdf.Navigation.LocationZoomDestination.zoom } values however,
                * the viewer must switch to the standard mode,
                * i.e. deactivate special modes like "fit page" or "fit width".
                *
                * Because of this,
                * using a {@link PdfViewing.Pdf.Navigation.LocationZoomDestination.zoom } value other than `null` is discouraged.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get zoom() {
                    let retVal = Module.ViewingPdfNavLocationZoomDestinationGetZoom(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Navigation.LocationZoomDestination = LocationZoomDestination;
            /**
             *
             *
             * A destination fits an entire page into the viewport.
             *
             * Note: Many PDF viewers support different viewing modes like "fit page" or
             * "fit width".
             * A {@link PdfViewing.Pdf.Navigation.FitPageDestination } will change the current viewing mode to
             * "fit page" in those viewers.
             *
             * Changing the viewing mode is usually not very well received by users
             * and thus a {@link PdfViewing.Pdf.Navigation.LocationZoomDestination } should be preferred in most cases.
             */
            class FitPageDestination extends PdfViewing.Pdf.Navigation.DirectDestination {
                /**
                 *
                 * @param pageNumber
                 * The page in the document that this destination is pointing to.
                 * @param fitActualContent
                 *
                 * If `true`, the viewport is fitted to the actual content of the page,
                 * instead of the size of the page.
                 *
                 * See property {@link PdfViewing.Pdf.Navigation.FitPageDestination.fitActualContent } for more information.
                 */
                constructor(pageNumber, fitActualContent) {
                    if (arguments[0] && typeof arguments[0].__handle === `number`)
                        super(arguments[0].__handle);
                    else {
                        if (typeof pageNumber !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                        if (typeof fitActualContent !== 'boolean')
                            throw new PdfViewing.ArgumentError("Argument 'fitActualContent' must be of type boolean and must not be null or undefined.");
                        super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNavNewFitPageDestination(pageNumber, fitActualContent)));
                    }
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new FitPageDestination({ __handle: handle });
                }
                /**
                *
                * If `true`, the viewport is fitted to the actual content of the page,
                * instead of the size of the page.
                *
                * Note: Many PDF viewers simply ignore this property and always treat it
                * as `false`, i.e. switching to "fit page" mode anyway.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get fitActualContent() {
                    let retVal = Module.ViewingPdfNavFitPageDestinationGetFitActualContent(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Navigation.FitPageDestination = FitPageDestination;
            /**
             *
             *
             * A destination fits the width of a page into the viewport.
             *
             * Note: Many PDF viewers support different viewing modes like "fit page" or
             * "fit width".
             * A {@link PdfViewing.Pdf.Navigation.FitWidthDestination } will change the current viewing mode to
             * "fit width" in those viewers.
             *
             * Changing the viewing mode is usually not very well received by users
             * and thus a {@link PdfViewing.Pdf.Navigation.LocationZoomDestination } should be preferred in most cases.
             */
            class FitWidthDestination extends PdfViewing.Pdf.Navigation.DirectDestination {
                /**
                 *
                 * @param pageNumber
                 * The page in the document that this destination is pointing to.
                 * @param top
                 *
                 * The location of the page that is displayed at the top of the viewport (if possible).
                 *
                 * Set `null` to use top edge of the page.
                 * @param fitActualContent
                 *
                 * If `true`, the viewport is fitted to the actual content of the page,
                 * instead of the size of the page.
                 *
                 * See property {@link PdfViewing.Pdf.Navigation.FitWidthDestination.fitActualContent } for more information.
                 */
                constructor(pageNumber, top, fitActualContent) {
                    if (arguments[0] && typeof arguments[0].__handle === `number`)
                        super(arguments[0].__handle);
                    else {
                        if (typeof pageNumber !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                        if (top !== null && top !== undefined && (typeof top !== 'number'))
                            throw new PdfViewing.ArgumentError("Argument 'top' must be of type number or can be null or undefined.");
                        if (typeof fitActualContent !== 'boolean')
                            throw new PdfViewing.ArgumentError("Argument 'fitActualContent' must be of type boolean and must not be null or undefined.");
                        super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNavNewFitWidthDestination(pageNumber, top, fitActualContent)));
                    }
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new FitWidthDestination({ __handle: handle });
                }
                /**
                *
                * If `true`, the viewport is fitted to the width of the actual content of the page,
                * instead of the width of the page.
                *
                * Note: Many PDF viewers simply ignore this property and always treat it
                * as `false`, i.e. switching to "fit page" mode anyway.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get fitActualContent() {
                    let retVal = Module.ViewingPdfNavFitWidthDestinationGetFitActualContent(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                *
                * The location of the page that is displayed at the top of the viewport (if possible).
                *
                * If the property is `null`, then the top of the page will be used.
                *
                * This value is ignored by viewers if the view is rotated.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get top() {
                    let retVal = Module.ViewingPdfNavFitWidthDestinationGetTop(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Navigation.FitWidthDestination = FitWidthDestination;
            /**
             *
             *
             * A destination fits the height of a page into the viewport.
             *
             * Note: Many PDF viewers support different viewing modes like "fit page" or
             * "fit width".
             * A {@link PdfViewing.Pdf.Navigation.FitHeightDestination } will change the current viewing mode to
             * "fit height" in those viewers.
             *
             * Changing the viewing mode is usually not very well received by users
             * and thus a {@link PdfViewing.Pdf.Navigation.LocationZoomDestination } should be preferred in most cases.
             */
            class FitHeightDestination extends PdfViewing.Pdf.Navigation.DirectDestination {
                /**
                 *
                 * @param pageNumber
                 * The page in the document that this destination is pointing to.
                 * @param left
                 *
                 * The location of the page that is displayed at the left edge of the viewport (if possible).
                 *
                 * Set `null` to use left edge of the page.
                 * @param fitActualContent
                 *
                 * If `true`, the viewport is fitted to the actual content of the page,
                 * instead of the size of the page.
                 *
                 * See property {@link PdfViewing.Pdf.Navigation.FitHeightDestination.fitActualContent } for more information.
                 */
                constructor(pageNumber, left, fitActualContent) {
                    if (arguments[0] && typeof arguments[0].__handle === `number`)
                        super(arguments[0].__handle);
                    else {
                        if (typeof pageNumber !== 'number')
                            throw new PdfViewing.ArgumentError("Argument 'pageNumber' must be of type number and must not be null or undefined.");
                        if (left !== null && left !== undefined && (typeof left !== 'number'))
                            throw new PdfViewing.ArgumentError("Argument 'left' must be of type number or can be null or undefined.");
                        if (typeof fitActualContent !== 'boolean')
                            throw new PdfViewing.ArgumentError("Argument 'fitActualContent' must be of type boolean and must not be null or undefined.");
                        super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNavNewFitHeightDestination(pageNumber, left, fitActualContent)));
                    }
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new FitHeightDestination({ __handle: handle });
                }
                /**
                *
                * If `true`, the viewport is fitted to the width of the actual content of the page,
                * instead of the width of the page.
                *
                * Note: Many PDF viewers simply ignore this property and always treat it
                * as `false`, i.e. switching to "fit page" mode anyway.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get fitActualContent() {
                    let retVal = Module.ViewingPdfNavFitHeightDestinationGetFitActualContent(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                *
                * The location of the page that is displayed as the left edge of the viewport (if possible).
                *
                * If the property is `null`, then the left edge of the page will be used.
                *
                * This value is ignored by viewers if the view is rotated.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get left() {
                    let retVal = Module.ViewingPdfNavFitHeightDestinationGetLeft(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Navigation.FitHeightDestination = FitHeightDestination;
            /**
             *
             *
             * A destination that fits a specified area of a page into the viewport.
             *
             * Note: Many PDF viewers support different viewing modes like "fit page" or
             * "fit width".
             * A {@link PdfViewing.Pdf.Navigation.FitRectangleDestination } will change the current viewing mode to
             * standard mode in those viewers,
             * i.e. deactivate any special mode like "fit page" or "fit width".
             *
             * Changing the viewing mode is usually not very well received by users
             * and thus a {@link PdfViewing.Pdf.Navigation.LocationZoomDestination } should be preferred in most cases.
             */
            class FitRectangleDestination extends PdfViewing.Pdf.Navigation.DirectDestination {
                /**
                 *
                 * @param rectangleOnPage
                 * The rectangle that is displayed in the viewport.
                 */
                constructor(rectangleOnPage) {
                    if (arguments[0] && typeof arguments[0].__handle === `number`)
                        super(arguments[0].__handle);
                    else {
                        if (typeof rectangleOnPage !== 'object')
                            throw new PdfViewing.ArgumentError("Argument 'rectangleOnPage' must be of type PdfViewing.Pdf.Geometry.Real.RectangleOnPage and must not be null or undefined.");
                        super(Internal.NativeObject.checkReturnHandleErrorCode(Module.ViewingPdfNavNewFitRectangleDestination(rectangleOnPage)));
                    }
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new FitRectangleDestination({ __handle: handle });
                }
                /**
                * The rectangle that is displayed in the viewport.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get rectangle() {
                    let retVal = Module.ViewingPdfNavFitRectangleDestinationGetRectangle(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return new PdfViewing.Pdf.Geometry.Real.RectangleOnPage(retVal.pageNumber, retVal.x, retVal.y, retVal.width, retVal.height);
                }
            }
            Navigation.FitRectangleDestination = FitRectangleDestination;
            /**
             *
             * An outline item represents an entry in the outline tree of the document.
             * It is also known as "Bookmark".
             */
            class OutlineItem extends Internal.NativeObject {
                /** @internal */
                constructor(handle) {
                    super(handle);
                }
                /** @internal */
                static createDynamicObject(handle) {
                    return new OutlineItem(handle);
                }
                /**
                 * Close the object
                 *
                 * Release all native resources associated with the object.
                 */
                close() {
                    if (!Module.ViewingPdfNavOutlineItemClose(this.handle))
                        Internal.NativeBase.throwLastError();
                }
                /**
                * The title of the outline item.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get title() {
                    let retVal = Module.ViewingPdfNavOutlineItemGetTitle(this.handle);
                    if (retVal === null)
                        Internal.NativeBase.throwLastError(false);
                    return retVal;
                }
                /**
                * If `true`, the outline item is displayed in bold font.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get bold() {
                    let retVal = Module.ViewingPdfNavOutlineItemGetBold(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * If `true`, the outline item is displayed in italic font.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get italic() {
                    let retVal = Module.ViewingPdfNavOutlineItemGetItalic(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * The destination of the outline item.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get destination() {
                    let retVal = Module.ViewingPdfNavOutlineItemGetDestination(this.handle);
                    if (retVal === 0)
                        Internal.NativeBase.throwLastError();
                    return retVal !== 0 ? PdfViewing.Pdf.Navigation.Destination.createDynamicObject(retVal) : null;
                }
                /**
                *   - If `true`, the item is expanded.
                *   - If `false`, the item is collapsed.
                * This is property is only meaningful if the item has child items.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get isOpen() {
                    let retVal = Module.ViewingPdfNavOutlineItemGetIsOpen(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
                /**
                * If `true`, this outline item has further children outline items.
                *
                * @throws {@link PdfViewing.InvalidOperationError} if the object has already been closed
                */
                get hasChildren() {
                    let retVal = Module.ViewingPdfNavOutlineItemGetHasChildren(this.handle);
                    if (!retVal)
                        Internal.NativeBase.throwLastError();
                    return retVal;
                }
            }
            Navigation.OutlineItem = OutlineItem;
        })(Navigation = Pdf.Navigation || (Pdf.Navigation = {}));
    })(Pdf = PdfViewing.Pdf || (PdfViewing.Pdf = {}));
    /**
     * A generic error occurred.
     *
     */
    class GenericError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.GenericError = GenericError;
    /**
     * A fatal error occurred.
     *
     */
    class FatalError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.FatalError = FatalError;
    /**
     * The license is not valid.
     *
     */
    class LicenseError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.LicenseError = LicenseError;
    /**
     * The format is not known.
     *
     */
    class UnknownFormatError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.UnknownFormatError = UnknownFormatError;
    /**
     * The file is corrupt and cannot be opened.
     *
     */
    class CorruptError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.CorruptError = CorruptError;
    /**
     * Invalid password specified.
     *
     */
    class PasswordError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.PasswordError = PasswordError;
    /**
     * The document has an invalid conformance level.
     *
     */
    class ConformanceError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.ConformanceError = ConformanceError;
    /**
     * The document contains an unsupported feature.
     *
     */
    class UnsupportedFeatureError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.UnsupportedFeatureError = UnsupportedFeatureError;
    /**
     * Infrastructure error occurred.
     *
     */
    class InfrastructureError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.InfrastructureError = InfrastructureError;
    /**
     * The file cannot be processed.
     *
     */
    class ProcessingError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.ProcessingError = ProcessingError;
    /**
     * The specified item already exists.
     *
     */
    class ExistsError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.ExistsError = ExistsError;
    /**
     * The update failed.
     *
     */
    class UpdateFailedError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.UpdateFailedError = UpdateFailedError;
    /**
     *
     */
    class NotSupportedError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.NotSupportedError = NotSupportedError;
    /**
     *
     */
    class InvalidOperationError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.InvalidOperationError = InvalidOperationError;
    /**
     *
     */
    class ArgumentError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.ArgumentError = ArgumentError;
    /**
     *
     */
    class NotFoundError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.NotFoundError = NotFoundError;
    /**
     *
     */
    class IOError extends PdfViewingError {
        constructor(message) {
            super(message);
        }
    }
    PdfViewing.IOError = IOError;
    let Sys;
    (function (Sys) {
        class StreamObject {
            constructor() {
                /** @internal */
                this._parameter = new Uint8Array(0);
                /** @internal */
                this.currPos = 0;
            }
            /**
             * @returns Underlying Uint8Array.
             */
            get parameter() {
                return this._parameter;
            }
            /**
             * @param value Allowed types are Uint8Array and Blob.
             */
            set parameter(value) {
                if (value instanceof Blob)
                    this._parameter = new Uint8Array(new FileReaderSync().readAsArrayBuffer(value));
                else if (value instanceof Uint8Array)
                    this._parameter = value;
                else
                    throw new TypeError("Not allowed type for parameter in StreamObject. Allowed types are Uint8Array and Blob.");
            }
            /** @internal */
            getLength() {
                return this._parameter.byteLength;
            }
            /** @internal */
            seek(position) {
                if (position > this.getLength())
                    return false;
                if (position === -1)
                    this.currPos = this.getLength();
                else
                    this.currPos = position;
                return true;
            }
            /** @internal */
            tell() {
                return this.currPos;
            }
            /** @internal */
            read(bufoffset, size) {
                size = Math.min(size, this._parameter.byteLength - this.currPos);
                if (size !== 0) {
                    let writearr = new Uint8Array(Module.HEAP8.buffer, bufoffset, size);
                    writearr.set(this._parameter.subarray(this.currPos, this.currPos + size));
                    this.currPos = this.currPos + size;
                    return writearr.length;
                }
                return 0;
            }
            /** @internal */
            write(bufoffset, size) {
                let requiredLength = this.currPos + size;
                if (requiredLength > this._parameter.byteLength) { // resize Uint8Array-View
                    if (requiredLength > (this._parameter.buffer.byteLength - this._parameter.byteOffset)) { // resize underlying ArrayBuffer
                        if (requiredLength > Number.MAX_SAFE_INTEGER)
                            throw new IOError("Reached maximum array size.");
                        let newLength = 8096;
                        while (newLength < requiredLength)
                            newLength *= 2;
                        newLength = Math.min(newLength, Number.MAX_SAFE_INTEGER);
                        let uint8ArrayTemp = new Uint8Array(new ArrayBuffer(newLength));
                        uint8ArrayTemp.set(this._parameter);
                        this._parameter = uint8ArrayTemp;
                    }
                    this._parameter = new Uint8Array(this._parameter.buffer, this._parameter.byteOffset, requiredLength);
                }
                let readarr = new Uint8Array(Module.HEAP8.buffer, bufoffset, size);
                this._parameter.subarray(this.currPos, this.currPos + size).set(readarr);
                this.currPos = this.currPos + size;
                return size;
            }
        }
        Sys.StreamObject = StreamObject;
    })(Sys = PdfViewing.Sys || (PdfViewing.Sys = {}));
    class ListIterator {
        /** @internal */
        constructor(list) {
            /** @internal */
            this.index = 0;
            this.list = list;
        }
        next() {
            if (this.index === this.list.size)
                return { done: true, value: null };
            let element = this.list.get(this.index);
            this.index++;
            return { done: element === null, value: element };
        }
        ;
    }
    class AnnotationFilterWrapper {
        constructor(callback) {
            this.callback = callback;
        }
        annotationFilter(annotation) {
            try {
                let retVal = this.callback(PdfViewing.Pdf.Annotations.Annotation.createDynamicObject(annotation));
                Module.ViewingSetLastError(0, null);
                return retVal;
            }
            catch (err) {
                if (err instanceof Error)
                    setLastErrorFromCallback(err);
                return false;
            }
        }
    }
    function setLastErrorFromCallback(err) {
        if (err instanceof PdfViewing.GenericError)
            Module.ViewingSetLastError(10, err.message);
        else if (err instanceof PdfViewing.FatalError)
            Module.ViewingSetLastError(11, err.message);
        else if (err instanceof PdfViewing.LicenseError)
            Module.ViewingSetLastError(12, err.message);
        else if (err instanceof PdfViewing.UnknownFormatError)
            Module.ViewingSetLastError(15, err.message);
        else if (err instanceof PdfViewing.CorruptError)
            Module.ViewingSetLastError(16, err.message);
        else if (err instanceof PdfViewing.PasswordError)
            Module.ViewingSetLastError(17, err.message);
        else if (err instanceof PdfViewing.ConformanceError)
            Module.ViewingSetLastError(18, err.message);
        else if (err instanceof PdfViewing.UnsupportedFeatureError)
            Module.ViewingSetLastError(19, err.message);
        else if (err instanceof PdfViewing.InfrastructureError)
            Module.ViewingSetLastError(20, err.message);
        else if (err instanceof PdfViewing.ProcessingError)
            Module.ViewingSetLastError(21, err.message);
        else if (err instanceof PdfViewing.ExistsError)
            Module.ViewingSetLastError(22, err.message);
        else if (err instanceof PdfViewing.UpdateFailedError)
            Module.ViewingSetLastError(23, err.message);
        else if (err instanceof PdfViewing.NotSupportedError)
            Module.ViewingSetLastError(1, err.message);
        else if (err instanceof PdfViewing.InvalidOperationError)
            Module.ViewingSetLastError(2, err.message);
        else if (err instanceof PdfViewing.ArgumentError)
            Module.ViewingSetLastError(3, err.message);
        else if (err instanceof PdfViewing.NotFoundError)
            Module.ViewingSetLastError(5, err.message);
        else if (err instanceof PdfViewing.IOError)
            Module.ViewingSetLastError(4, err.message);
        else
            Module.ViewingSetLastError(6, err.message);
    }
})(PdfViewing || (PdfViewing = {}));


/***/ }),

/***/ "./src/pdf-viewer-api/PdfViewingWrapper.ts":
/*!*************************************************!*\
  !*** ./src/pdf-viewer-api/PdfViewingWrapper.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PdfViewingWrapper": () => (/* binding */ PdfViewingWrapper)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "./src/pdf-viewer-api/enums.ts");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./src/pdf-viewer-api/types.ts");
/* harmony import */ var _annotationDefaultBehaviors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotationDefaultBehaviors */ "./src/pdf-viewer-api/annotationDefaultBehaviors.ts");
/* harmony import */ var _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pdf-tools/four-heights-pdf-viewing */ "../../node_modules/@pdf-tools/four-heights-pdf-viewing/es6/PdfViewing.js");
/* harmony import */ var _ImageContainer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ImageContainer */ "./src/pdf-viewer-api/ImageContainer.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (undefined && undefined.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};





class PdfViewingWrapper {
    constructor(key, pdfViewerApiOptions) {
        this.pdfDocument = null;
        this.objectUrls = [];
        this.view = null;
        this.textFragmentCache = new Map();
        this.nativeAnnotationCache = new Map();
        this.handleAnnotationCache = new Map();
        this.pageAnnotationCache = new Map();
        this.imageBitmapCache = new Map();
        this.ignoreDocumentPreferences = false;
        this.nativeOutlines = new Map();
        this.devicePixelRatio = window.devicePixelRatio;
        this.xDPI = 0;
        this.yDPI = 0;
        _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.initialize(key, _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.version);
        this.validateViewingSdkVersion();
        this.pdfViewerApiOptions = pdfViewerApiOptions;
        this.licenseFeatures = _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.supportedFeatures;
        this.pdfController = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.ViewerController();
        this.eventListeners = new Map();
        this.viewportSize = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Size(0, 0);
        this.pdfStampDocuments = new Map();
        this.registeredPdfStamps = new Map();
        this.attachEventListeners = this.attachEventListeners.bind(this);
        this.onDocumentOpened = this.onDocumentOpened.bind(this);
        this.onViewUpdated = this.onViewUpdated.bind(this);
        this.onImageCreated = this.onImageCreated.bind(this);
        this.onImageRemovedFromCache = this.onImageRemovedFromCache.bind(this);
        this.getAnnotationsFromPage = this.getAnnotationsFromPage.bind(this);
    }
    getIgnoringPreferences() {
        return this.ignoreDocumentPreferences;
    }
    setIgnoringPreferences(ignorePreferences) {
        this.ignoreDocumentPreferences = ignorePreferences;
    }
    open(pdfFile, fdfFiles, password, viewOptions, renderOptions, viewportSize) {
        return new Promise((resolve, reject) => {
            const mapInputDocument = (file, fileType) => {
                try {
                    let mimeType = 'application/pdf';
                    switch (fileType) {
                        case _types__WEBPACK_IMPORTED_MODULE_1__.FileType.Fdf:
                            mimeType = 'application/vnd.fdf';
                            break;
                    }
                    const { data } = file;
                    let uri = '';
                    let httpOptions = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.IO.HttpOptions();
                    if (data) {
                        uri = URL.createObjectURL(new File([data], pdfFile.sourceTag || '', {
                            type: mimeType,
                        }));
                    }
                    else {
                        const inputUri = file;
                        uri = inputUri.uri;
                        if (inputUri.httpOptions) {
                            const { headers } = inputUri.httpOptions;
                            if (headers) {
                                Object.keys(headers).forEach((key) => {
                                    var _a;
                                    (_a = httpOptions.headers) === null || _a === void 0 ? void 0 : _a.set(key, headers[key]);
                                });
                            }
                            httpOptions.credentials = inputUri.httpOptions.credentials || null;
                            httpOptions.cache = inputUri.httpOptions.cache || null;
                            httpOptions.mode = inputUri.httpOptions.mode || null;
                            httpOptions.redirect = inputUri.httpOptions.redirect || null;
                            httpOptions.referrerPolicy = inputUri.httpOptions.referrerPolicy || null;
                        }
                    }
                    return new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.IO.InputUri(uri, httpOptions, pdfFile.sourceTag);
                }
                catch (err) {
                    throw new Error('failed to create InputDocument');
                }
            };
            const pdfInputFile = mapInputDocument(pdfFile, _types__WEBPACK_IMPORTED_MODULE_1__.FileType.Pdf);
            const fdfInputFiles = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.IO.InputDocumentList();
            if (fdfFiles && fdfFiles.length) {
                fdfFiles.forEach((file) => {
                    const fdfFile = mapInputDocument(file, _types__WEBPACK_IMPORTED_MODULE_1__.FileType.Fdf);
                    if (fdfFile) {
                        fdfInputFiles.add(fdfFile);
                    }
                });
            }
            const mapViewOptions = (viewOptions) => {
                try {
                    if (!viewOptions) {
                        return null;
                    }
                    const options = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.ViewOptions();
                    options.initialDestination = null;
                    if (typeof viewOptions.initialFitMode === 'number') {
                        options.initialFitMode = this.WwFitModeToViewingFitMode(viewOptions.initialFitMode);
                    }
                    if (typeof viewOptions.initialPageLayoutMode === 'number') {
                        options.initialPageLayoutMode = this.WwPageLayoutToViewingPageLayout(viewOptions.initialPageLayoutMode);
                    }
                    if (typeof viewOptions.initialPageNumber === 'number' ||
                        typeof viewOptions.initialZoom === 'number') {
                        const pageNumber = typeof viewOptions.initialPageNumber === 'number' ? viewOptions.initialPageNumber : 1;
                        const zoom = typeof viewOptions.initialZoom === 'number' ? viewOptions.initialZoom : null;
                        options.initialDestination = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.LocationZoomDestination(pageNumber, null, null, zoom);
                    }
                    if (typeof viewportSize === 'object') {
                        this.viewportSize = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Integer.Size(viewportSize.width, viewportSize.height);
                        options.viewportSize = this.viewportSize;
                    }
                    return options;
                }
                catch (err) {
                    console.error(err);
                    throw new Error('failed to create View Options');
                }
            };
            const sdkViewOptions = mapViewOptions(viewOptions);
            const mapRenderOptions = (renderOptions) => {
                try {
                    if (!renderOptions) {
                        return null;
                    }
                    const options = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.RenderOptions();
                    if (renderOptions.formFieldHighlightColor) {
                        options.formFieldHighlightColor = this.createNativeColor(renderOptions.formFieldHighlightColor);
                    }
                    if (renderOptions.formFieldRequiredHighlightColor) {
                        options.formFieldRequiredHighlightColor = this.createNativeColor(renderOptions.formFieldRequiredHighlightColor);
                    }
                    return options;
                }
                catch (err) {
                    throw new Error('failed to create Render Options');
                }
            };
            const sdkRenderOptions = mapRenderOptions(renderOptions);
            this.pdfController
                .open(pdfInputFile, fdfInputFiles, password)
                .then((document) => {
                this.pdfDocument = document;
                this.onDocumentOpened(document, sdkRenderOptions, sdkViewOptions);
                resolve();
            })
                .catch((error) => {
                console.warn(error);
                reject(error);
            });
        });
    }
    save(saveOptions) {
        const { fileType, annotationFilter } = saveOptions || {};
        const _saveOptions = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.SaveOptions();
        switch (fileType) {
            case _types__WEBPACK_IMPORTED_MODULE_1__.FileType.Fdf:
                _saveOptions.fileType = _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.IO.FileType.Fdf;
                break;
            default:
                _saveOptions.fileType = _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.IO.FileType.Pdf;
        }
        _saveOptions.annotationFilter = annotationFilter
            ? this.createAnnotationFilter(annotationFilter)
            : null;
        return new Promise((resolve, reject) => {
            if (this.pdfDocument) {
                this.pdfDocument
                    .save(_saveOptions)
                    .then((file) => {
                    const buffer = file.bufferData;
                    if (buffer) {
                        const blob = new Blob([file.bufferData]);
                        file.close();
                        resolve(blob);
                    }
                    else {
                        reject('Returned save buffer is null');
                    }
                })
                    .catch((error) => {
                    console.warn(error);
                    reject(error);
                });
            }
            else {
                reject('No document opened');
            }
        });
    }
    close() {
        var _a, _b;
        this.nativeAnnotationCache.forEach((annot) => {
            var _a;
            if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.MarkupAnnotation) {
                (_a = annot.info) === null || _a === void 0 ? void 0 : _a.close();
            }
            annot.close();
        });
        this.nativeAnnotationCache.clear();
        this.handleAnnotationCache.clear();
        this.pageAnnotationCache.clear();
        this.textFragmentCache.clear();
        this.objectUrls.forEach((url) => {
            URL.revokeObjectURL(url);
        });
        this.objectUrls = [];
        this.nativeOutlines.forEach((outline) => {
            outline.close();
        });
        this.nativeOutlines.clear();
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.close();
        (_b = this.pdfDocument) === null || _b === void 0 ? void 0 : _b.close();
        this.pdfDocument = null;
    }
    destroy() {
        if (this.view) {
            this.view.removeEventListener('viewUpdated', this.onViewUpdated);
            this.view.removeEventListener('imageCreated', this.onImageCreated);
            this.view.removeEventListener('imageRemovedFromCache', this.onImageRemovedFromCache);
        }
        this.close();
        this.pdfStampDocuments.forEach((stampDocument) => {
            stampDocument.close();
        });
        this.pdfController.close();
        this.imageBitmapCache.forEach((imageContainer) => {
            imageContainer.destroy();
        });
        this.nativeOutlines.clear();
        this.imageBitmapCache.clear();
        this.textFragmentCache.clear();
        this.nativeAnnotationCache.clear();
        this.handleAnnotationCache.clear();
        this.pageAnnotationCache.clear();
        this.pdfStampDocuments.clear();
        this.registeredPdfStamps.clear();
    }
    registerPdfStampFile(pdfStampFileName, data, onStampCreated) {
        const url = URL.createObjectURL(new File([data], pdfStampFileName, { type: 'application/pdf' }));
        this.objectUrls.push(url);
        this.pdfController
            .openUri(url, null, null, null, null)
            .then((pdfDocument) => {
            const createStamps = () => __awaiter(this, void 0, void 0, function* () {
                var e_1, _a, e_2, _b;
                const pageNumbers = Array.from({ length: pdfDocument.pageCount }, (_, i) => i + 1);
                let maxHeight = 0;
                let maxWidth = 0;
                const stampSizes = {};
                try {
                    for (var pageNumbers_1 = __asyncValues(pageNumbers), pageNumbers_1_1; pageNumbers_1_1 = yield pageNumbers_1.next(), !pageNumbers_1_1.done;) {
                        let pageNumber = pageNumbers_1_1.value;
                        const size = yield pdfDocument.getPagePdfSize(pageNumber);
                        stampSizes[pageNumber] = size;
                        maxHeight = Math.max(size.height, maxHeight);
                        maxWidth = Math.max(size.width, maxWidth);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (pageNumbers_1_1 && !pageNumbers_1_1.done && (_a = pageNumbers_1.return)) yield _a.call(pageNumbers_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                const MAX_PX_WIDTH = 200;
                const MAX_PX_HEIGHT = 100;
                const scale = Math.max(maxHeight / MAX_PX_HEIGHT, maxWidth / MAX_PX_WIDTH);
                try {
                    for (var pageNumbers_2 = __asyncValues(pageNumbers), pageNumbers_2_1; pageNumbers_2_1 = yield pageNumbers_2.next(), !pageNumbers_2_1.done;) {
                        let pageNumber = pageNumbers_2_1.value;
                        const size = stampSizes[pageNumber];
                        const aspectRatio = size.width / size.height;
                        const img = yield pdfDocument.renderPage(pageNumber, size.width / scale, size.height / scale, 0);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempContext = tempCanvas.getContext('2d');
                        const imgData = new ImageData(new Uint8ClampedArray(img.bufferView), img.width, img.height);
                        tempContext.putImageData(imgData, 0, 0);
                        const thumbnail = tempCanvas.toDataURL('png');
                        onStampCreated({
                            pdfStampFileName,
                            name: `${pdfStampFileName} - ${pageNumber}`,
                            pageNumber,
                            thumbnail,
                            aspectRatio,
                        });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (pageNumbers_2_1 && !pageNumbers_2_1.done && (_b = pageNumbers_2.return)) yield _b.call(pageNumbers_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            });
            this.pdfStampDocuments.set(pdfStampFileName, pdfDocument);
            createStamps();
        })
            .catch((error) => {
            console.warn(error);
        });
    }
    getPageCount() {
        if (this.pdfDocument) {
            return this.pdfDocument.pageCount;
        }
        else {
            return null;
        }
    }
    registerImage(imageBuffer) {
        return new Promise((resolve, reject) => {
            if (this.pdfDocument) {
                const imgBlob = URL.createObjectURL(new Blob([imageBuffer]));
                this.pdfDocument.registerImageUri(imgBlob, null).then((id) => {
                    resolve(id);
                });
            }
        });
    }
    registerPdfPage(fileName, pageNumber) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if (this.pdfDocument) {
                const pdfDoc = this.pdfStampDocuments.get(fileName);
                if (!pdfDoc) {
                    resolve(0);
                }
                else {
                    const registeredPdfStampsKey = `${fileName}__${pageNumber}`;
                    const stampRefId = this.registeredPdfStamps.get(registeredPdfStampsKey);
                    if (stampRefId) {
                        resolve(stampRefId);
                    }
                    else {
                        const id = yield this.pdfDocument.registerPdfPage(pdfDoc, pageNumber);
                        this.registeredPdfStamps.set(registeredPdfStampsKey, id);
                        resolve(id);
                    }
                }
            }
        }));
    }
    getPageNumber() {
        if (this.view) {
            return this.view.pageNumber;
        }
        return 0;
    }
    getFitMode() {
        var _a;
        var fitMode = (_a = this.view) === null || _a === void 0 ? void 0 : _a.fitMode;
        if (fitMode === undefined) {
            throw new Error('Invalid fit mode');
        }
        else {
            return fitMode;
        }
    }
    setFitMode(mode) {
        if (this.view) {
            this.view.fitMode = mode;
        }
    }
    setPageNumber(page) {
        if (this.view) {
            this.view.pageNumber = page;
        }
    }
    getZoom() {
        if (this.view) {
            return this.view.zoom;
        }
        return 0;
    }
    setZoom(zoom, location) {
        if (this.view) {
            if (location) {
                const p = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Integer.Point(location.x, location.y);
                this.view.zoomOnLocation(zoom, p);
            }
            else {
                this.view.zoom = zoom;
            }
        }
    }
    getRotation() {
        if (this.view) {
            return this.view.viewRotation;
        }
        return 0;
    }
    setRotation(rotation) {
        if (this.view) {
            this.view.viewRotation = rotation;
        }
    }
    setBorderSize(size) {
        if (this.view) {
            this.view.borderSize = size;
        }
    }
    getBorderSize() {
        if (this.view) {
            return this.view.borderSize;
        }
        return 0;
    }
    suspendDrawing() {
        var _a;
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.suspendDrawing();
    }
    resumeDrawing() {
        var _a;
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.resumeDrawing();
    }
    renderCanvas(ctx, options) {
        var _a;
        if (this.view) {
            if (this.viewportSize.width != ctx.canvas.width ||
                this.viewportSize.height != ctx.canvas.height) {
                this.viewportSize.width = ctx.canvas.width;
                this.viewportSize.height = ctx.canvas.height;
                this.view.viewportSize = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Integer.Size(ctx.canvas.width, ctx.canvas.height);
            }
            const data = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getRenderedResults();
            if (data) {
                this.drawImages(ctx, data, options);
                data.close();
            }
        }
    }
    renderPage(page, width, height) {
        return new Promise((resolve, reject) => {
            var _a;
            (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.renderPage(page, width, height, 0).then((image) => {
                const imgBuffer = image.bufferView;
                if (!imgBuffer) {
                    reject();
                }
                let pageImage = {};
                pageImage.page = page;
                pageImage.imageData = new ImageData(new Uint8ClampedArray(imgBuffer), image.width, image.height);
                image.close();
                resolve(pageImage);
            }).catch((err) => {
                if (err.message !== 'Document was closed before operation could finish') {
                    reject(`failed to render page ${page}`);
                }
            });
        });
    }
    rotatePage(pageNumber, direction) {
        var _a;
        const page = (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.pages.get(pageNumber - 1);
        if (page) {
            page.rotatePage(direction === _enums__WEBPACK_IMPORTED_MODULE_0__.RotationDirection.CLOCKWISE ? 90 : -90);
            this.dispatchEvent('pageChanged', pageNumber);
        }
    }
    getPagePdfSize(page) {
        return new Promise((resolve, reject) => {
            var _a;
            (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.getPagePdfSize(page).then((pageSize) => {
                resolve(pageSize);
            });
        });
    }
    setLicenseKey(key) {
        try {
            _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.initialize(key, _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.version);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    getSupportedFeatures() {
        return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.supportedFeatures;
    }
    hasChanges() {
        if (this.pdfDocument) {
            const changes = this.pdfDocument.hasChanges;
            let ret = _enums__WEBPACK_IMPORTED_MODULE_0__.DocumentChange.NONE;
            if (changes & _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.DocumentChange.Annotation) {
                ret = ret | _enums__WEBPACK_IMPORTED_MODULE_0__.DocumentChange.ANNOTATION;
            }
            if (changes & _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.DocumentChange.Content) {
                ret = ret | _enums__WEBPACK_IMPORTED_MODULE_0__.DocumentChange.CONTENT;
            }
            return ret;
        }
        return null;
    }
    getSearchIterator(keyword, page, caseSensitive, wrap, regex) {
        var _a;
        try {
            return (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.searchText(keyword, page, caseSensitive, wrap, regex);
        }
        catch (err) {
            if (err.message !== 'Invalid search text') {
                throw err;
            }
            console.warn(err.message);
        }
    }
    getTextFragmentOnPoint(point) {
        var _a;
        const pointOnVp = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Integer.Point(point.x, point.y);
        if (this.pdfDocument === null)
            return null;
        try {
            const fragmentList = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getTextFragmentsOnPoint(pointOnVp);
            let frag = null;
            if (fragmentList && fragmentList.size > 0) {
                const nativeFrag = fragmentList.get(0);
                frag = this.createWebViewerFragment(nativeFrag);
                nativeFrag.close();
                fragmentList === null || fragmentList === void 0 ? void 0 : fragmentList.close();
            }
            return frag;
        }
        catch (error) {
            return null;
        }
    }
    getWordOnPoint(point) {
        var _a;
        const pointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(point.page, point.pdfX, point.pdfY);
        try {
            const selection = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getWordOnPoint(pointOnPage);
            if (selection) {
                const { textArea } = selection;
                if (textArea) {
                    const quadrilaterals = [];
                    for (let index = 0; index < textArea.size; index++) {
                        quadrilaterals.push(textArea.get(index));
                    }
                    textArea.close();
                    selection.close();
                    const q = quadrilaterals[0];
                    if (q) {
                        const { bottomLeft, bottomRight, topRight, topLeft, pageNumber } = q;
                        return {
                            quadrilaterals,
                            startPoint: {
                                pdfX: Math.min(bottomLeft.x, bottomRight.x, topRight.x, topLeft.x),
                                pdfY: Math.max(bottomLeft.y, bottomRight.y, topRight.y, topLeft.y),
                                page: pageNumber,
                            },
                            endPoint: {
                                pdfX: Math.max(bottomLeft.x, bottomRight.x, topRight.x, topLeft.x),
                                pdfY: Math.min(bottomLeft.y, bottomRight.y, topRight.y, topLeft.y),
                                page: pageNumber,
                            },
                        };
                    }
                }
            }
        }
        catch (e) { }
        return null;
    }
    getTextSelection(startPoint, endPoint) {
        var _a;
        const startPointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(startPoint.page, startPoint.pdfX, startPoint.pdfY);
        const endPointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(endPoint.page, endPoint.pdfX, endPoint.pdfY);
        try {
            const selection = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getTextSelection(startPointOnPage, endPointOnPage);
            if (selection) {
                const { textArea } = selection;
                if (textArea) {
                    const quadrilaterals = [];
                    for (let index = 0; index < textArea.size; index++) {
                        quadrilaterals.push(textArea.get(index));
                    }
                    textArea.close();
                    selection.close();
                    return {
                        quadrilaterals,
                        startPoint,
                        endPoint,
                    };
                }
            }
        }
        catch (e) { }
        return null;
    }
    getRectangularTextSelection(startPoint, endPoint) {
        var _a;
        const startPointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(startPoint.page, startPoint.pdfX, startPoint.pdfY);
        const endPointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(endPoint.page, endPoint.pdfX, endPoint.pdfY);
        try {
            const selection = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getRectangularTextSelection(startPointOnPage, endPointOnPage);
            if (selection) {
                const { textArea } = selection;
                if (textArea) {
                    const quadrilaterals = [];
                    for (let index = 0; index < textArea.size; index++) {
                        quadrilaterals.push(textArea.get(index));
                    }
                    textArea.close();
                    selection.close();
                    return {
                        quadrilaterals,
                        startPoint,
                        endPoint,
                    };
                }
            }
        }
        catch (err) { }
        return null;
    }
    getText(startPoint, endPoint) {
        var _a;
        const startPointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(startPoint.page, startPoint.pdfX, startPoint.pdfY);
        const endPointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(endPoint.page, endPoint.pdfX, endPoint.pdfY);
        try {
            const selection = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getTextSelection(startPointOnPage, endPointOnPage);
            if (selection) {
                const { text } = selection;
                selection.close();
                return text;
            }
        }
        catch (e) { }
        return null;
    }
    getTextForRectangularSelection(startPoint, endPoint) {
        var _a;
        const startPointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(startPoint.page, startPoint.pdfX, startPoint.pdfY);
        const endPointOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(endPoint.page, endPoint.pdfX, endPoint.pdfY);
        try {
            const selection = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getRectangularTextSelection(startPointOnPage, endPointOnPage);
            if (selection) {
                const { text } = selection;
                selection.close();
                return text;
            }
        }
        catch (e) { }
        return null;
    }
    createWebViewerFragment(nativeFragment) {
        const fragment = {};
        fragment.glyphOffsets = nativeFragment.glyphOffsets ? nativeFragment.glyphOffsets : [];
        fragment.text = nativeFragment.text || '';
        const fragRect = nativeFragment.rectangleOnPage;
        if (fragRect) {
            fragment.pdfRect = this.ViewingPdfRect2WwPdfRect(fragRect);
        }
        return fragment;
    }
    getIsOpen() {
        return this.pdfDocument !== null;
    }
    getOutlines(parent) {
        return new Promise((resolve, reject) => {
            if (this.pdfDocument) {
                if (parent !== null) {
                    parent = this.nativeOutlines.get(parent.id);
                }
                this.pdfDocument
                    .getOutlines(parent)
                    .then((outlineList) => {
                    const outlines = [];
                    for (let i = 0; i < outlineList.size; i++) {
                        const nativeOutline = outlineList.get(i);
                        const outline = {};
                        outline.id = nativeOutline.getHashCode();
                        outline.title = nativeOutline.title || '';
                        outline.hasDescendants = nativeOutline.hasChildren;
                        outline.destination = nativeOutline.destination;
                        this.nativeOutlines.set(nativeOutline.getHashCode(), nativeOutline);
                        outlines.push(outline);
                    }
                    outlineList.close();
                    resolve(outlines);
                })
                    .catch((err) => {
                    if (err.message !== 'Document was closed before operation could finish') {
                        reject('failed to get outlines');
                    }
                });
            }
            else {
                reject();
            }
        });
    }
    goTo(destination) {
        if (destination != null)
            this.goToPage(destination.pageNumber, destination.left, destination.top, destination.zoom);
    }
    goToPage(pageNumber, left = null, top = null, zoom = null) {
        if (this.view) {
            const nativeDest = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.LocationZoomDestination(pageNumber, left, top, zoom);
            this.view.goToDestination(nativeDest);
        }
    }
    goToRectangle(rectangle) {
        if (this.view) {
            const rectangleOnPage = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.RectangleOnPage(rectangle.page, rectangle.pdfX, rectangle.pdfY, rectangle.pdfW, rectangle.pdfH);
            this.view.goToRectangle(rectangleOnPage);
        }
    }
    getAnnotationsFromPage(page) {
        return new Promise((resolve, reject) => {
            var _a;
            (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.getAnnotations(page).then((annotList) => {
                var _a;
                const annotRet = {};
                annotRet.page = page;
                annotRet.itemCategory = 1;
                annotRet.items = [];
                for (let i = 0; i < annotList.size; i++) {
                    const nativeAnnot = annotList.get(i);
                    const ww_annot = this.createWebViewerAnnotation(nativeAnnot, page);
                    if (ww_annot) {
                        annotRet.items.push(ww_annot);
                        this.nativeAnnotationCache.set(ww_annot.id, nativeAnnot);
                        this.handleAnnotationCache.set(ww_annot.id, ww_annot);
                        if (!this.pageAnnotationCache.has(page)) {
                            this.pageAnnotationCache.set(page, []);
                        }
                        (_a = this.pageAnnotationCache.get(page)) === null || _a === void 0 ? void 0 : _a.push(ww_annot);
                    }
                }
                resolve(annotRet);
            }).catch((err) => {
                if (err.message !== 'Document was closed before operation could finish') {
                    reject(`Failed to get annotations for page ${page}, ${err}`);
                }
            });
        });
    }
    deleteItem(item) {
        return this.deleteAnnotation(item);
    }
    validateViewingSdkVersion() {
        const parseVersionString = (versionString) => {
            const match = versionString.match(/(\d+)\.(\d+)\.(\d+)[\-]{0,1}(\w*)[\.]{0,1}(\d*)/);
            if (match) {
                return {
                    major: parseInt(match[1]),
                    minor: parseInt(match[2]),
                    patch: parseInt(match[3]),
                    type: match[4],
                    buildId: parseInt(match[5]),
                };
            }
        };
        const requiredSdk = parseVersionString('4.2.0');
        const currentSdk = parseVersionString(_pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.version);
        if (requiredSdk && currentSdk) {
            const valid = requiredSdk.major === currentSdk.major &&
                requiredSdk.minor === currentSdk.minor &&
                requiredSdk.patch === currentSdk.patch &&
                (requiredSdk.type ? requiredSdk.buildId === currentSdk.buildId : true);
            if (!valid) {
                console.warn(`**************************************
Version mismatch between PDF Viewing SDK and  PDF Web Viewer

Most likely, the static assets of the PDF Viewing SDK have not been copied to the configured location. For more information please consult the documentation ("static assets").

Current version: ${currentSdk.major}.${currentSdk.minor}.${currentSdk.patch}
Required version: ${requiredSdk.major}.${requiredSdk.minor}.${requiredSdk.patch}${requiredSdk.type ? ` (${requiredSdk.type.toUpperCase()} version)` : ''}

**************************************`);
            }
        }
        else {
            console.warn('The PDF Viewing SDK version number has an incorrect format');
        }
    }
    deleteAnnotation(item) {
        return new Promise((resolve, reject) => {
            var _a;
            const id = item.id;
            const nativeAnnot = this.nativeAnnotationCache.get(id);
            const page = item.page;
            if (nativeAnnot) {
                (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.deleteAnnotation(nativeAnnot).then(() => {
                    nativeAnnot.close();
                    this.nativeAnnotationCache.delete(id);
                    this.handleAnnotationCache.delete(id);
                    this.dispatchEvent('itemDeleted', { page, id, categoryType: 1 });
                    this.dispatchEvent('pageChanged', page);
                    resolve();
                });
            }
        });
    }
    getItem(id) {
        if (this.handleAnnotationCache.has(id)) {
            return this.handleAnnotationCache.get(id);
        }
        return null;
    }
    createItem(item) {
        return this.createAnnotation(item);
    }
    createAnnotationFilter(annotationFilter) {
        return (annot) => {
            const { pageNumber } = annot.boundingBox;
            const ww_annot = this.createWebViewerAnnotation(annot, pageNumber);
            annot.close();
            const res = annotationFilter(ww_annot);
            return res;
        };
    }
    createMarkupAnnotation(item) {
        const color = this.createNativeColor(item.color);
        const fillColor = this.createNativeColor(item.fillColor);
        let borderStyle = _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Lined;
        const stroke = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.AnnotationStroke();
        if (item.border) {
            stroke.lineWidth = item.border.width;
            borderStyle = this.convertToNativeBorderStyle(item.border.style);
            if (item.border.style === 1) {
                stroke.dashArray = [item.border.width];
            }
        }
        const bbox = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.RectangleOnPage(item.pdfRect.page, item.pdfRect.pdfX, item.pdfRect.pdfY, item.pdfRect.pdfW, item.pdfRect.pdfH);
        switch (item.itemType) {
            case 1:
                const stickyOrigin = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(item.pdfRect.page, item.pdfRect.pdfX, item.pdfRect.pdfY);
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.StickyNote.create(stickyOrigin, '', color);
            case 3:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.FreeText.create(bbox, item.richtext, color, stroke, this.view ? this.view.viewRotation : _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Rotation.NoRotation);
            case 5:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.RectangleAnnotation.create(bbox, stroke.lineWidth ? color : null, stroke, borderStyle, fillColor);
            case 6:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.EllipseAnnotation.create(bbox, stroke.lineWidth ? color : null, stroke, borderStyle, fillColor);
            case 9:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Highlight.create(this.createQuadrilateralList(item.quadrilaterals), color);
            case 10:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Underline.create(this.createQuadrilateralList(item.quadrilaterals), color);
            case 11:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Squiggly.create(this.createQuadrilateralList(item.quadrilaterals), color);
            case 12:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.StrikeThrough.create(this.createQuadrilateralList(item.quadrilaterals), color);
            case 13:
                if (item.stampText) {
                    return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.CustomTextStamp.create(bbox, item.stampText, item.stampColor, this.view ? this.view.viewRotation : _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Rotation.NoRotation);
                }
                else if (item.imageId) {
                    return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.CustomImageStamp.create(bbox, item.imageId, this.view ? this.view.viewRotation : _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Rotation.NoRotation);
                }
                else {
                    throw new Error(`createAnnotation: Unknown custom stamp annotation`);
                }
            case 15:
                const inkList = item.inkList;
                const path = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Path();
                if (inkList) {
                    const pathGen = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PathGenerator(path);
                    for (let i = 0; i < inkList.length; i++) {
                        pathGen.moveTo(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Point(inkList[i][0], inkList[i][1]));
                        for (let j = 2; j < inkList[i].length; j += 2) {
                            pathGen.lineTo(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Point(inkList[i][j], inkList[i][j + 1]));
                        }
                    }
                    pathGen.close();
                }
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.InkAnnotation.create(item.page, path, color, stroke);
            default:
                throw new Error(`createAnnotation: Type not implemented: ${item.itemType}`);
        }
    }
    createAnnotation(item) {
        let annot = this.createMarkupAnnotation(item);
        const page = item.page;
        annot.info.author = item.author || '';
        return new Promise((resolve, reject) => {
            var _a;
            (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.createAnnotation(annot).then(() => {
                const ww_annot = this.createWebViewerAnnotation(annot, item.page);
                if (ww_annot) {
                    this.nativeAnnotationCache.set(ww_annot.id, annot);
                    this.handleAnnotationCache.set(ww_annot.id, ww_annot);
                    this.dispatchEvent('itemCreated', ww_annot);
                    this.dispatchEvent('pageChanged', page);
                    resolve(ww_annot);
                }
                reject('Failed to create Web Viewer annotation');
            }).catch((error) => {
                reject(error);
            });
        });
    }
    createQuadrilateralList(quadrilaterals) {
        const quadrilateralList = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.QuadrilateralList();
        for (let i = 0; i < quadrilaterals.length; i++) {
            const q = quadrilaterals[i];
            quadrilateralList.add(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.QuadrilateralOnPage(q.pageNumber, new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Point(q.bottomLeft.x, q.bottomLeft.y), new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Point(q.bottomRight.x, q.bottomRight.y), new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Point(q.topRight.x, q.topRight.y), new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Point(q.topLeft.x, q.topLeft.y)));
        }
        return quadrilateralList;
    }
    convertToNativeBorderStyle(style) {
        switch (style) {
            case 0:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Lined;
            case 2:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Beveled;
            case 3:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Inset;
            case 4:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Underline;
            default:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Lined;
        }
    }
    convertToWebViewerBorderStyle(style) {
        switch (style) {
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Lined:
                return 0;
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Beveled:
                return 2;
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Inset:
                return 3;
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.BorderStyleType.Underline:
                return 4;
            default:
                return 0;
        }
    }
    updateItem(item) {
        return new Promise((resolve, reject) => {
            var _a, _b;
            if (item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.WIDGET) {
                (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.editAnnotation(item.widget).then(() => {
                    this.dispatchEvent('pageChanged', item.widget.boundingBox.pageNumber);
                    resolve(item);
                }).catch((error) => {
                    reject(error);
                });
            }
            else {
                const nativeAnnot = this.nativeAnnotationCache.get(item.id);
                if (nativeAnnot) {
                    const rotationChanged = item.hasOwnProperty('rotation') &&
                        item.rotation % 360 !== nativeAnnot.rotation % 360;
                    if (!rotationChanged) {
                        const bbox = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.RectangleOnPage(item.pdfRect.page, item.pdfRect.pdfX, item.pdfRect.pdfY, item.pdfRect.pdfW, item.pdfRect.pdfH);
                        nativeAnnot.boundingBox = bbox;
                    }
                    let nativeColor = null;
                    nativeColor = this.createNativeColor(item.color);
                    const markupAnnot = nativeAnnot;
                    if (markupAnnot && item.privateData) {
                        markupAnnot.privateData = item.privateData;
                    }
                    if (nativeAnnot.popup) {
                        const rect = item.popup.pdfRect;
                        nativeAnnot.popup.boundingBox =
                            new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.RectangleOnPage(rect.page, rect.pdfX, rect.pdfY, rect.pdfW, rect.pdfH);
                        nativeAnnot.popup.isOpen = item.popup.isOpen;
                    }
                    if (markupAnnot && markupAnnot.info) {
                        markupAnnot.info.content = item.content || '';
                        markupAnnot.info.subject = item.subject || '';
                    }
                    if (item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.TEXT) {
                        const stickyAnnot = nativeAnnot;
                        stickyAnnot.color = nativeColor;
                    }
                    if (item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.FREE_TEXT) {
                        const freetextAnnot = nativeAnnot;
                        freetextAnnot.richText = item.richText;
                        freetextAnnot.backgroundColor = this.createNativeColor(item.color);
                        const stroke = freetextAnnot.annotationStroke;
                        if (stroke) {
                            stroke.lineWidth = item.border.width;
                            freetextAnnot.annotationStroke = stroke;
                            stroke.close();
                        }
                        if (rotationChanged) {
                            freetextAnnot.rotation = item.rotation;
                            item.pdfRect = {
                                page: freetextAnnot.boundingBox.pageNumber,
                                pdfX: freetextAnnot.boundingBox.x,
                                pdfY: freetextAnnot.boundingBox.y,
                                pdfW: freetextAnnot.boundingBox.width,
                                pdfH: freetextAnnot.boundingBox.height,
                            };
                        }
                    }
                    if (item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.INK) {
                        const inkAnnotation = nativeAnnot;
                        const inkAnnot = item;
                        inkAnnotation.strokeColor = nativeColor;
                        const { annotationStroke } = inkAnnotation;
                        if (annotationStroke) {
                            annotationStroke.lineWidth = item.border.width;
                            inkAnnotation.annotationStroke = annotationStroke;
                        }
                        const { path } = inkAnnotation;
                        const { vertices } = path;
                        vertices.clear();
                        for (let line of inkAnnot.inkList) {
                            let isFirstPoint = true;
                            for (let point of line) {
                                if (isFirstPoint) {
                                    vertices.add(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Vertex(inkAnnot.page, point.x, point.y, _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PathOperation.MoveTo));
                                    isFirstPoint = false;
                                }
                                else {
                                    vertices.add(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.Vertex(inkAnnot.page, point.x, point.y, _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PathOperation.LineTo));
                                }
                            }
                        }
                        path.vertices = vertices;
                        inkAnnotation.setPath(path);
                    }
                    if (item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SQUARE || item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.CIRCLE) {
                        const shapeAnnotation = nativeAnnot;
                        const { annotationStroke } = shapeAnnotation;
                        if (annotationStroke) {
                            annotationStroke.lineWidth = item.border.width;
                            if (item.border.style === 1) {
                                annotationStroke.dashArray = [item.border.width];
                            }
                            else {
                                annotationStroke.dashArray = [0];
                            }
                            shapeAnnotation.annotationStroke = annotationStroke;
                        }
                        shapeAnnotation.borderStyleType = this.convertToNativeBorderStyle(item.border.style);
                        shapeAnnotation.strokeColor = nativeColor;
                        shapeAnnotation.fillColor = this.createNativeColor(item.fillColor);
                    }
                    if (item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.HIGHLIGHT ||
                        item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SQUIGGLY ||
                        item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.STRIKE_OUT ||
                        item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.UNDERLINE) {
                        const textMarkupAnnot = nativeAnnot;
                        textMarkupAnnot.color = nativeColor;
                    }
                    if (item.itemType === _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.STAMP) {
                        const stampAnnot = nativeAnnot;
                        if (rotationChanged) {
                            stampAnnot.rotation = item.rotation;
                            item.pdfRect = {
                                page: stampAnnot.boundingBox.pageNumber,
                                pdfX: stampAnnot.boundingBox.x,
                                pdfY: stampAnnot.boundingBox.y,
                                pdfW: stampAnnot.boundingBox.width,
                                pdfH: stampAnnot.boundingBox.height,
                            };
                        }
                    }
                    (_b = this.pdfDocument) === null || _b === void 0 ? void 0 : _b.editAnnotation(nativeAnnot).then(() => {
                        const { pageNumber } = nativeAnnot.boundingBox;
                        const updatedItem = this.createWebViewerAnnotation(nativeAnnot, pageNumber);
                        if (updatedItem) {
                            this.handleAnnotationCache.set(item.id, updatedItem);
                            this.dispatchEvent('itemUpdated', updatedItem);
                            this.dispatchEvent('pageChanged', pageNumber);
                            resolve(updatedItem);
                        }
                        else {
                            throw new Error('failed to update item');
                        }
                    }).catch((error) => {
                        reject(error);
                    });
                }
            }
        });
    }
    getTextStampAspectRatio(stampText) {
        return new Promise((resolve, reject) => {
            var _a;
            if (this.pdfDocument && this.view) {
                (_a = this.pdfDocument) === null || _a === void 0 ? void 0 : _a.getTextStampAspectRatio(stampText).then((ratio) => {
                    resolve(ratio);
                });
            }
            else {
                reject('No document opened');
            }
        });
    }
    createNativeColor(color) {
        let red = 0;
        let green = 0;
        let blue = 0;
        let alpha = 0;
        if (!color) {
            return new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Color(red, green, blue, alpha);
        }
        color = color.replace(/\s+/gi, '');
        if (color.indexOf('#') === 0) {
            if (color.length === 4) {
                red = parseInt(color.substring(1, 2), 16);
                green = parseInt(color.substring(2, 3), 16);
                blue = parseInt(color.substring(3, 4), 16);
                alpha = 255;
            }
            else if (color.length === 5) {
                red = parseInt(color.substring(1, 2), 16);
                green = parseInt(color.substring(2, 3), 16);
                blue = parseInt(color.substring(3, 4), 16);
                alpha = parseInt(color.substring(4, 5), 16);
            }
            else if (color.length === 7) {
                red = parseInt(color.substring(1, 3), 16);
                green = parseInt(color.substring(3, 5), 16);
                blue = parseInt(color.substring(5, 7), 16);
                alpha = 255;
            }
            else if (color.length === 9) {
                red = parseInt(color.substring(1, 3), 16);
                green = parseInt(color.substring(3, 5), 16);
                blue = parseInt(color.substring(5, 7), 16);
                alpha = parseInt(color.substring(7, 9), 16);
            }
            else {
                throw new Error('invalid color string: ' + color);
            }
        }
        else if (color.indexOf('rgb') === 0) {
            const values = color.substring(color.indexOf('(') + 1, color.indexOf(')')).split(',');
            if (values.length < 3 || values.length > 4) {
                throw new Error('invalid color string: ' + color);
            }
            red = parseInt(values[0], 10);
            green = parseInt(values[1], 10);
            blue = parseInt(values[2], 10);
            if (values.length === 4) {
                alpha = Math.floor(parseFloat(values[3]) * 255);
            }
            else {
                alpha = 255;
            }
        }
        else {
            throw new Error('invalid color string: ' + color);
        }
        return new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Color(red, green, blue, alpha);
    }
    createWebViewerAnnotation(annot, page) {
        var _a, _b;
        let ww_annot = {};
        ww_annot.itemCategory = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemCategory.ANNOTATION;
        ww_annot.sourceTag = annot.sourceTag;
        if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.MarkupAnnotation) {
            const bbox = annot.boundingBox;
            if (bbox) {
                ww_annot.pdfRect = this.ViewingPdfRect2WwPdfRect(bbox);
            }
            ww_annot.page = page;
            ww_annot.privateData = annot.privateData ? annot.privateData : null;
            const info = annot.info;
            if (info) {
                ww_annot.content = info === null || info === void 0 ? void 0 : info.content;
                ww_annot.author = (info === null || info === void 0 ? void 0 : info.author) || '';
                ww_annot.id = info === null || info === void 0 ? void 0 : info.getHashCode();
                ww_annot.modificationDate = (info === null || info === void 0 ? void 0 : info.modificationDate) || null;
                ww_annot.creationDate = (info === null || info === void 0 ? void 0 : info.creationDate) || null;
                ww_annot.subject = info === null || info === void 0 ? void 0 : info.subject;
            }
            ww_annot.isLocked = () => {
                const cachedAnnotation = this.nativeAnnotationCache.get(ww_annot.id);
                if (cachedAnnotation instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.MarkupAnnotation) {
                    const markupAnnot = cachedAnnotation;
                    if (markupAnnot.info) {
                        return markupAnnot.info.locked;
                    }
                }
                console.warn('annotation not found');
                return false;
            };
            ww_annot.setLock = (isLocked) => {
                const cachedAnnotation = this.nativeAnnotationCache.get(ww_annot.id);
                if (cachedAnnotation instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.MarkupAnnotation) {
                    const markupAnnot = cachedAnnotation;
                    if (markupAnnot.info) {
                        markupAnnot.info.locked = isLocked;
                    }
                }
            };
            if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.TextMarkup) {
                ww_annot.color = this.convertColorToRgbaString(annot.color);
            }
            ww_annot.isHidden = () => {
                const cachedAnnotation = this.nativeAnnotationCache.get(ww_annot.id);
                if (!cachedAnnotation) {
                    console.warn('annotation not found');
                    return false;
                }
                return cachedAnnotation.hidden;
            };
            ww_annot.setHidden = (isHidden) => {
                const cachedAnnotation = this.nativeAnnotationCache.get(ww_annot.id);
                if (!cachedAnnotation) {
                    console.warn('annotation not found');
                    return false;
                }
                return (cachedAnnotation.hidden = isHidden);
            };
            ww_annot.border = {};
            this.addPopup(ww_annot, annot);
            if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.StickyNote) {
                ww_annot.color = this.convertColorToRgbaString(annot.color);
                ww_annot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.TEXT;
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.FreeText) {
                ww_annot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.FREE_TEXT;
                const freetextAnnot = annot;
                const ww_freetextAnnot = ww_annot;
                ww_freetextAnnot.richText =
                    freetextAnnot.richText ||
                        `<?xml version="1.0"?><body xmlns="http://www.w3.org/1999/xhtml" xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/" xfa:APIVersion="Acrobat:21.11.0" xfa:spec="2.0.2" style="color:#000000;font-family:Helvetica;font-size:12pt;"><p>${annot.info.content}</p></body>`;
                ww_freetextAnnot.rotation = freetextAnnot.rotation;
                ww_freetextAnnot.color = this.convertColorToRgbaString(freetextAnnot.backgroundColor);
                const stroke = freetextAnnot.annotationStroke;
                if (stroke) {
                    ww_freetextAnnot.border.width = stroke === null || stroke === void 0 ? void 0 : stroke.lineWidth;
                    ww_freetextAnnot.border.style = 0;
                    stroke.close();
                }
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.RectangleAnnotation) {
                const ww_shapeAnnot = ww_annot;
                ww_shapeAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SQUARE;
                ww_shapeAnnot.color = this.convertColorToRgbaString(annot.strokeColor);
                const stroke = annot.annotationStroke;
                if (stroke) {
                    ww_shapeAnnot.border.width = stroke === null || stroke === void 0 ? void 0 : stroke.lineWidth;
                    const hasDashArray = stroke.dashArray.length && stroke.dashArray[0] > 0;
                    ww_shapeAnnot.border.style = hasDashArray
                        ? 1
                        : this.convertToWebViewerBorderStyle(annot.borderStyleType);
                    stroke.close();
                }
                if (annot.fillColor) {
                    ww_shapeAnnot.fillColor = this.convertColorToRgbaString(annot.fillColor);
                }
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.EllipseAnnotation) {
                const ww_shapeAnnot = ww_annot;
                ww_shapeAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.CIRCLE;
                ww_shapeAnnot.color = this.convertColorToRgbaString(annot.strokeColor);
                const stroke = annot.annotationStroke;
                if (stroke) {
                    ww_shapeAnnot.border.width = stroke === null || stroke === void 0 ? void 0 : stroke.lineWidth;
                    const hasDashArray = stroke.dashArray.length && stroke.dashArray[0] > 0;
                    ww_shapeAnnot.border.style = hasDashArray
                        ? 1
                        : this.convertToWebViewerBorderStyle(annot.borderStyleType);
                    stroke.close();
                }
                if (annot.fillColor) {
                    ww_shapeAnnot.fillColor = this.convertColorToRgbaString(annot.fillColor);
                }
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.PolygonAnnotation) {
                ww_annot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.POLYGON;
                const stroke = annot.annotationStroke;
                if (stroke) {
                    ww_annot.border.width = stroke === null || stroke === void 0 ? void 0 : stroke.lineWidth;
                    const hasDashArray = stroke.dashArray.length && stroke.dashArray[0] > 0;
                    ww_annot.border.style = hasDashArray
                        ? 1
                        : this.convertToWebViewerBorderStyle(annot.borderStyleType);
                }
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.PolyLineAnnotation) {
                ww_annot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.POLY_LINE;
                const stroke = annot.annotationStroke;
                if (stroke) {
                    ww_annot.border.width = stroke === null || stroke === void 0 ? void 0 : stroke.lineWidth;
                    ww_annot.border.style = 0;
                    stroke.close();
                }
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.TextMarkup) {
                const highlightAnnot = ww_annot;
                highlightAnnot.markedText = annot.markedText;
                if (annot.markupArea !== null) {
                    highlightAnnot.quadrilaterals = [];
                    for (let index = 0; index < annot.markupArea.size; index++) {
                        highlightAnnot.quadrilaterals.push(annot.markupArea.get(index));
                    }
                }
                if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Highlight) {
                    highlightAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.HIGHLIGHT;
                }
                else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Underline) {
                    highlightAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.UNDERLINE;
                }
                else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Squiggly) {
                    highlightAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SQUIGGLY;
                }
                else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.StrikeThrough) {
                    highlightAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.STRIKE_OUT;
                }
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Stamp) {
                const stampAnnot = ww_annot;
                stampAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.STAMP;
                stampAnnot.rotation = annot.rotation;
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.TextInsert) {
                return null;
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.InkAnnotation) {
                const sdkInkAnnot = annot;
                const inkAnnot = ww_annot;
                inkAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.INK;
                inkAnnot.color = this.convertColorToRgbaString(sdkInkAnnot.strokeColor);
                inkAnnot.border = {
                    width: ((_a = sdkInkAnnot.annotationStroke) === null || _a === void 0 ? void 0 : _a.lineWidth) || 1,
                    style: _enums__WEBPACK_IMPORTED_MODULE_0__.AnnotationBorderStyle.SOLID,
                };
                inkAnnot.inkList = [];
                const { vertices } = sdkInkAnnot.path;
                let path = null;
                for (let i = 0; i < vertices.size; i++) {
                    const vertex = vertices.get(i);
                    if (vertex.operator === _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PathOperation.MoveTo) {
                        if (path) {
                            inkAnnot.inkList.push(path);
                        }
                        path = [{ x: vertex.x, y: vertex.y }];
                    }
                    else if (vertex.operator === _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PathOperation.LineTo) {
                        path === null || path === void 0 ? void 0 : path.push({ x: vertex.x, y: vertex.y });
                    }
                }
                if (path) {
                    inkAnnot.inkList.push(path);
                }
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Popup) {
                return null;
            }
            else {
                return null;
            }
        }
        else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.Link) {
            ww_annot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.LINK;
            const linkAnnot = ww_annot;
            ww_annot.id = annot.getHashCode();
            ww_annot.pdfRect = this.ViewingPdfRect2WwPdfRect(annot.boundingBox);
            if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.WebLink) {
                linkAnnot.uri = annot.uri;
                linkAnnot.actionType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfActionType.URI;
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Annotations.InternalLink) {
                const target = (_b = annot.destination) === null || _b === void 0 ? void 0 : _b.target;
                linkAnnot.actionType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfActionType.GO_TO;
                if (target) {
                    linkAnnot.destination = {
                        destinationType: 8,
                        pageNumber: target.pageNumber,
                        left: null,
                        top: null,
                        zoom: null,
                    };
                }
            }
        }
        else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Forms.Widget) {
            const widgetAnnot = ww_annot;
            widgetAnnot.id = annot.getHashCode();
            widgetAnnot.itemType = _enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.WIDGET;
            widgetAnnot.page = page;
            const bbox = annot.boundingBox;
            widgetAnnot.pdfRect = this.ViewingPdfRect2WwPdfRect(bbox);
            widgetAnnot.widget = annot;
            widgetAnnot.isLocked = () => {
                return false;
            };
            widgetAnnot.isHidden = () => {
                return annot.hidden;
            };
            widgetAnnot.setHidden = (isHidden) => {
                annot.hidden = isHidden;
            };
            widgetAnnot.pdfDocument = this.pdfDocument;
            if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Forms.CheckBox) {
                widgetAnnot.widgetType = _enums__WEBPACK_IMPORTED_MODULE_0__.WidgetType.CHECK_BOX;
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Forms.RadioButton) {
                widgetAnnot.widgetType = _enums__WEBPACK_IMPORTED_MODULE_0__.WidgetType.RADIO_BUTTON;
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Forms.TextBox) {
                widgetAnnot.widgetType = _enums__WEBPACK_IMPORTED_MODULE_0__.WidgetType.TEXT_BOX;
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Forms.ListBox) {
                widgetAnnot.widgetType = _enums__WEBPACK_IMPORTED_MODULE_0__.WidgetType.LIST_BOX;
            }
            else if (annot instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Forms.ComboBox) {
                widgetAnnot.widgetType = _enums__WEBPACK_IMPORTED_MODULE_0__.WidgetType.COMBO_BOX;
            }
        }
        else {
            return null;
        }
        const isReadOnly = () => {
            const { annotationPermissionCallback, onlyAuthorCanEdit, user } = this.pdfViewerApiOptions;
            let eventThrottlingTimer = null;
            let lastResult = false;
            const viewOnly = this.pdfViewerApiOptions.viewOnly ||
                !(_pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.supportedFeatures & _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.LicenseFeature.Annotate);
            return () => {
                if (eventThrottlingTimer) {
                    return lastResult;
                }
                lastResult = false;
                if (viewOnly || !(_pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.supportedFeatures & _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.LicenseFeature.Annotate)) {
                    lastResult = true;
                }
                else if (annotationPermissionCallback) {
                    lastResult = !annotationPermissionCallback(ww_annot, user);
                }
                else if (onlyAuthorCanEdit) {
                    lastResult = !ww_annot.author || user !== ww_annot.author;
                }
                eventThrottlingTimer = window.setTimeout(() => {
                    eventThrottlingTimer = null;
                }, 50);
                return lastResult;
            };
        };
        ww_annot.isReadOnly = isReadOnly();
        ww_annot.behaviors = this.getAnnotationBehaviors(ww_annot);
        return ww_annot;
    }
    getAnnotationBehaviors(ww_annot) {
        const defaultBehaviors = _annotationDefaultBehaviors__WEBPACK_IMPORTED_MODULE_2__.annotationDefaultBehaviors[ww_annot.itemType];
        if (!defaultBehaviors) {
            return {
                isReadOnly: true,
                selectable: false,
                editable: false,
                deletable: false,
                movable: false,
                rotatable: false,
                resizable: false,
                aspectRatioChangeable: false,
                canHavePopup: false,
                link: false,
                text: false,
            };
        }
        let isReadOnly = false;
        if (this.pdfViewerApiOptions.viewOnly ||
            !(this.licenseFeatures & _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.LicenseFeature.Annotate)) {
            isReadOnly = true;
        }
        const behaviors = {
            isReadOnly,
            selectable: defaultBehaviors[0],
            editable: defaultBehaviors[1],
            deletable: defaultBehaviors[2],
            movable: defaultBehaviors[3],
            rotatable: defaultBehaviors[4],
            resizable: defaultBehaviors[5],
            aspectRatioChangeable: defaultBehaviors[6],
            canHavePopup: this.pdfViewerApiOptions.allowPopups && defaultBehaviors[7],
            link: defaultBehaviors[8],
            text: defaultBehaviors[9],
        };
        return behaviors;
    }
    addPopup(ww_annot, annot) {
        const popup = annot.popup;
        if (popup) {
            ww_annot.popup = {};
            ww_annot.popup.pdfRect = this.ViewingPdfRect2WwPdfRect(popup.boundingBox);
            ww_annot.popup.isOpen = popup.isOpen;
            ww_annot.popup.pdfRect.page = ww_annot.page;
            popup.close();
        }
    }
    getOpenPopups(firstPage, lastPage) {
        var _a;
        const annotationsWithOpenPopups = [];
        for (let i = firstPage; i <= lastPage; i++) {
            (_a = this.pageAnnotationCache.get(i)) === null || _a === void 0 ? void 0 : _a.forEach((annot) => {
                if (annot.popup && annot.popup.isOpen) {
                    annotationsWithOpenPopups.push(annot);
                }
            });
        }
        return annotationsWithOpenPopups;
    }
    convertColorToRgbaString(color) {
        let rgba_string = '#';
        if (!color) {
            rgba_string += '00000000';
            return rgba_string;
        }
        rgba_string += color.red.toString(16).padStart(2, '0');
        rgba_string += color.green.toString(16).padStart(2, '0');
        rgba_string += color.blue.toString(16).padStart(2, '0');
        rgba_string += color.alpha.toString(16).padStart(2, '0');
        return rgba_string;
    }
    getPageLayoutMode() {
        if (this.view) {
            return this.view.pageLayoutMode;
        }
        return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.SinglePage;
    }
    setPageLayoutMode(layout) {
        if (this.view) {
            this.view.pageLayoutMode = layout;
        }
    }
    getScrollMaxPosition() {
        var _a;
        const sp = (_a = this.view) === null || _a === void 0 ? void 0 : _a.scrollMaxPosition;
        if (sp) {
            sp.x = Math.max(sp.x - this.viewportSize.width, 0);
            sp.y = Math.max(sp.y - this.viewportSize.height, 0);
        }
        return sp;
    }
    getScrollPosition() {
        var _a;
        return (_a = this.view) === null || _a === void 0 ? void 0 : _a.scrollPosition;
    }
    setScrollPosition(pos) {
        const sp = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Integer.ScrollPosition(pos.x, pos.y);
        if (this.view) {
            this.view.scrollPosition = pos;
        }
    }
    getPageScreenRect(page) {
        var _a;
        const viewingRect = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getPageRectangleOnViewport(page);
        if (viewingRect) {
            return this.ViewingVPRect2WwVpRect(viewingRect);
        }
        return null;
    }
    getClosestPointOnPdfByScreenPoint(point, padding = 0, page) {
        if (this.view && this.pdfDocument) {
            const p = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Integer.Point(point.x, point.y);
            const pointOnPage = page
                ? this.view.transformPointFromViewportToSpecificPage(p, page, true)
                : this.view.transformPointFromViewportToPage(p, true);
            const pageSize = this.pdfDocument.getPageSize(pointOnPage.pageNumber, true);
            const pdfPoint = {
                pdfX: pointOnPage.x,
                pdfY: pointOnPage.y,
                page: pointOnPage.pageNumber,
            };
            if (pdfPoint.pdfX < padding) {
                pdfPoint.pdfX = padding;
            }
            else if (pdfPoint.pdfX > pageSize.width - padding) {
                pdfPoint.pdfX = pageSize.width - padding;
            }
            if (pdfPoint.pdfY < padding) {
                pdfPoint.pdfY = padding;
            }
            else if (pdfPoint.pdfY > pageSize.height - padding) {
                pdfPoint.pdfY = pageSize.height - padding;
            }
            return pdfPoint;
        }
        throw new Error('PDF Document must not be null');
    }
    transformPdfLengthToScreenLength(pdfLength) {
        var _a;
        if (this.view) {
            return (_a = this.view) === null || _a === void 0 ? void 0 : _a.transformPdfLengthToViewportLength(pdfLength);
        }
        throw new Error('View must not be null');
    }
    transformScreenLengthToPdfLength(pdfLength) {
        var _a;
        if (this.view) {
            return (_a = this.view) === null || _a === void 0 ? void 0 : _a.transformViewportLengthToPdfLength(pdfLength);
        }
        throw new Error('View must not be null');
    }
    transformScreenPointToPdfPoint(point, page) {
        if (this.view && this.pdfDocument) {
            const p = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Integer.Point(point.x, point.y);
            try {
                const pointOnPage = page
                    ? this.view.transformPointFromViewportToSpecificPage(p, page, false)
                    : this.view.transformPointFromViewportToPage(p, false);
                const pageSize = this.pdfDocument.getPageSize(pointOnPage.pageNumber, true);
                return {
                    pdfPoint: { pdfX: pointOnPage.x, pdfY: pointOnPage.y, page: pointOnPage.pageNumber },
                    isOnPage: pointOnPage.x >= 0 &&
                        pointOnPage.x <= pageSize.width &&
                        pointOnPage.y >= 0 &&
                        pointOnPage.y <= pageSize.height,
                };
            }
            catch (error) {
                if (error instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.ArgumentError) {
                    return { pdfPoint: null, isOnPage: false };
                }
            }
        }
        return null;
    }
    transformPdfPointToScreenPoint(pdfPoint) {
        var _a;
        const screenPoint = (_a = this.view) === null || _a === void 0 ? void 0 : _a.transformPointFromPageToViewport(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(pdfPoint.page, pdfPoint.pdfX, pdfPoint.pdfY));
        return {
            x: screenPoint === null || screenPoint === void 0 ? void 0 : screenPoint.x,
            y: screenPoint === null || screenPoint === void 0 ? void 0 : screenPoint.y,
        };
    }
    transformPdfPageRectToScreenRect(pdfRect) {
        var _a;
        const screenRect = (_a = this.view) === null || _a === void 0 ? void 0 : _a.transformRectangleFromPageToViewport(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.RectangleOnPage(pdfRect.page, pdfRect.pdfX, pdfRect.pdfY, pdfRect.pdfW, pdfRect.pdfH));
        return {
            x: screenRect === null || screenRect === void 0 ? void 0 : screenRect.x,
            y: screenRect === null || screenRect === void 0 ? void 0 : screenRect.y,
            w: screenRect === null || screenRect === void 0 ? void 0 : screenRect.width,
            h: screenRect === null || screenRect === void 0 ? void 0 : screenRect.height,
        };
    }
    transformScreenRectToPdfRect(screenRect, page) {
        var _a;
        const vpRect = new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Integer.Rectangle(screenRect.x, screenRect.y, screenRect.w, screenRect.h);
        try {
            const pdfRect = (_a = this.view) === null || _a === void 0 ? void 0 : _a.transformRectangleFromViewportToSpecificPage(vpRect, page);
            return {
                pdfX: pdfRect === null || pdfRect === void 0 ? void 0 : pdfRect.x,
                pdfY: pdfRect === null || pdfRect === void 0 ? void 0 : pdfRect.y,
                pdfW: pdfRect === null || pdfRect === void 0 ? void 0 : pdfRect.width,
                pdfH: pdfRect === null || pdfRect === void 0 ? void 0 : pdfRect.height,
                page,
            };
        }
        catch (error) {
            return null;
        }
    }
    transformQuadrilateralToViewport(quadrilateral) {
        const points = [];
        if (this.view) {
            points.push(this.view.transformPointFromPageToViewport(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(quadrilateral.pageNumber, quadrilateral.topLeft.x, quadrilateral.topLeft.y)));
            points.push(this.view.transformPointFromPageToViewport(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(quadrilateral.pageNumber, quadrilateral.topRight.x, quadrilateral.topRight.y)));
            points.push(this.view.transformPointFromPageToViewport(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(quadrilateral.pageNumber, quadrilateral.bottomRight.x, quadrilateral.bottomRight.y)));
            points.push(this.view.transformPointFromPageToViewport(new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Geometry.Real.PointOnPage(quadrilateral.pageNumber, quadrilateral.bottomLeft.x, quadrilateral.bottomLeft.y)));
        }
        return points;
    }
    getAnnotationsOnPoint(point, onlySelectable) {
        var _a;
        const annotList = (_a = this.view) === null || _a === void 0 ? void 0 : _a.getAnnotationsOnPoint(point, onlySelectable);
        if (annotList && annotList.size > 0) {
            const annotationList = [];
            for (let i = 0; i < annotList.size; i++) {
                const annot = annotList.get(i);
                const annotId = annot.getHashCode();
                if (this.handleAnnotationCache.has(annotId)) {
                    annotationList.push(this.handleAnnotationCache.get(annotId));
                }
                else {
                    console.warn('annotation handle is not cached');
                }
                annot.close();
            }
            annotList.close();
            return annotationList;
        }
        return null;
    }
    getItemsFromPage(page, type) {
        if (type === 1) {
            return this.getAnnotationsFromPage(page);
        }
    }
    onDocumentOpened(document, renderOptions, viewOptions) {
        const _viewOptions = viewOptions ? viewOptions : new _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.ViewOptions();
        _viewOptions.viewDPI = this.getXDPI();
        const { initialDestination, initialPageLayoutMode } = document;
        if (initialPageLayoutMode !== null && _viewOptions.initialPageLayoutMode === null) {
            _viewOptions.initialPageLayoutMode = initialPageLayoutMode;
        }
        if (initialDestination !== null && _viewOptions.initialDestination === null) {
            _viewOptions.initialDestination = initialDestination;
        }
        this.view = _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.View.create(document, renderOptions, viewOptions);
        this.attachEventListeners();
        if (this.view) {
            this.dispatchEvent('firstVisiblePage', this.view.firstVisiblePage);
            this.dispatchEvent('lastVisiblePage', this.view.lastVisiblePage);
            this.dispatchEvent('pageNumber', this.view.pageNumber);
            this.dispatchEvent('fitMode', this.view.fitMode);
            this.dispatchEvent('pageLayoutMode', this.ViewingPageLayoutToWwPageLayout(this.view.pageLayoutMode));
        }
    }
    ViewingPageLayoutToWwPageLayout(layout) {
        switch (layout) {
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.OneColumn:
                return _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.ONE_COLUMN;
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.SinglePage:
                return _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.SINGLE_PAGE;
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.TwoColumnLeft:
                return _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_COLUMN_LEFT;
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.TwoColumnRight:
                return _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_COLUMN_RIGHT;
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.TwoPageLeft:
                return _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_PAGE_LEFT;
            case _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.TwoPageRight:
                return _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_PAGE_RIGHT;
            default:
                return _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.ONE_COLUMN;
        }
    }
    WwPageLayoutToViewingPageLayout(layout) {
        switch (layout) {
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.ONE_COLUMN:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.OneColumn;
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.SINGLE_PAGE:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.SinglePage;
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_COLUMN_LEFT:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.TwoColumnLeft;
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_COLUMN_RIGHT:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.TwoColumnRight;
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_PAGE_LEFT:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.TwoPageLeft;
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_PAGE_RIGHT:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.TwoPageRight;
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.ONE_COLUMN:
            default:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.PageLayoutMode.OneColumn;
        }
    }
    WwFitModeToViewingFitMode(fitMode) {
        switch (fitMode) {
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfFitMode.NONE:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.FitMode.None;
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfFitMode.FIT_PAGE:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.FitMode.FitPage;
            case _enums__WEBPACK_IMPORTED_MODULE_0__.PdfFitMode.FIT_WIDTH:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.FitMode.FitWidth;
            default:
                return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.FitMode.None;
        }
    }
    getLastVisiblePage() {
        if (this.view) {
            return this.view.lastVisiblePage;
        }
        return 0;
    }
    getFirstVisiblePage() {
        if (this.view) {
            return this.view.firstVisiblePage;
        }
        return 0;
    }
    drawImages(ctx, data, options) {
        if (data.visiblePages) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const currentPage = this.getPageNumber();
            for (let i = 0; i < data.visiblePages.size; i++) {
                const { image, pageRect, pageNumber } = data.visiblePages.get(i);
                ctx.save();
                if (currentPage === pageNumber && options.currentPageShadow) {
                    ctx.shadowColor = options.currentPageShadow.shadowColor;
                    ctx.shadowBlur = options.currentPageShadow.shadowBlur;
                    ctx.shadowOffsetX = options.currentPageShadow.shadowOffsetX;
                    ctx.shadowOffsetY = options.currentPageShadow.shadowOffsetY;
                }
                else if (options.pageShadow) {
                    ctx.shadowColor = options.pageShadow.shadowColor;
                    ctx.shadowBlur = options.pageShadow.shadowBlur;
                    ctx.shadowOffsetX = options.pageShadow.shadowOffsetX;
                    ctx.shadowOffsetY = options.pageShadow.shadowOffsetY;
                }
                ctx.fillStyle = '#ffffffff';
                ctx.fillRect(pageRect.x, pageRect.y, pageRect.width, pageRect.height);
                ctx.restore();
                if (image) {
                    const imageContainer = this.imageBitmapCache.get(image.id);
                    if (imageContainer) {
                        const { scaledImage, imageData } = imageContainer;
                        const { imageRectangle } = image;
                        if (imageData && scaledImage) {
                            if (imageRectangle.width !== image.width || imageRectangle.height !== image.height) {
                                ctx.drawImage(scaledImage, pageRect.x + imageRectangle.x, pageRect.y + imageRectangle.y, imageRectangle.width, imageRectangle.height);
                            }
                            else {
                                ctx.putImageData(imageData, pageRect.x + imageRectangle.x, pageRect.y + imageRectangle.y);
                            }
                        }
                    }
                    image.close();
                }
            }
        }
    }
    addEventListener(type, listener) {
        if (type === 'busyState') {
            this.pdfController.addEventListener('busyChanged', listener);
            return;
        }
        if (this.eventListeners.has(type)) {
            ;
            this.eventListeners.get(type).push(listener);
        }
        else {
            this.eventListeners.set(type, [listener]);
        }
    }
    removeEventListener(type, listener) {
        if (this.eventListeners.has(type)) {
            let listeners = this.eventListeners.get(type);
            listeners = listeners.filter((listenerInArray) => listenerInArray !== listener);
            if (listeners.length !== 0) {
                this.eventListeners.set(type, listeners);
            }
            else {
                this.eventListeners.delete(type);
            }
        }
    }
    dispatchEvent(type, args) {
        if (this.eventListeners.has(type)) {
            const listeners = this.eventListeners.get(type);
            listeners.forEach((listener) => listener(args));
        }
    }
    attachEventListeners() {
        if (this.view) {
            this.view.addEventListener('viewUpdated', this.onViewUpdated);
            this.view.addEventListener('imageCreated', this.onImageCreated);
            this.view.addEventListener('imageRemovedFromCache', this.onImageRemovedFromCache);
        }
    }
    onViewUpdated(args) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (args.bitmapsUpdated) {
        }
        if (args.fitmodeChanged) {
            (_a = this.eventListeners.get('fitMode')) === null || _a === void 0 ? void 0 : _a.forEach((listener) => {
                listener(this.view ? this.view.fitMode : _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Pdf.Navigation.FitMode.None);
            });
        }
        if (args.pageLayoutModeChanged) {
            (_b = this.eventListeners.get('pageLayoutMode')) === null || _b === void 0 ? void 0 : _b.forEach((listener) => {
                listener(this.view ? this.view.pageLayoutMode : 0);
            });
        }
        if (args.pageSizeUpdated) {
        }
        if (args.scrollMaxPositionChanged) {
        }
        if (args.viewRotationChanged) {
            (_c = this.eventListeners.get('rotation')) === null || _c === void 0 ? void 0 : _c.forEach((listener) => {
                listener(this.view ? this.view.viewRotation : 0);
            });
        }
        if (args.visisblePageRangeChanged) {
            (_d = this.eventListeners.get('firstVisiblePage')) === null || _d === void 0 ? void 0 : _d.forEach((listener) => {
                listener(this.view ? this.view.firstVisiblePage : 0);
            });
            (_e = this.eventListeners.get('lastVisiblePage')) === null || _e === void 0 ? void 0 : _e.forEach((listener) => {
                listener(this.view ? this.view.lastVisiblePage : 0);
            });
        }
        if (args.pageNumberChanged) {
            (_f = this.eventListeners.get('pageNumber')) === null || _f === void 0 ? void 0 : _f.forEach((listener) => {
                listener(this.view ? this.view.pageNumber : 0);
            });
        }
        if (args.zoomChanged) {
            (_g = this.eventListeners.get('zoom')) === null || _g === void 0 ? void 0 : _g.forEach((listener) => {
                listener(this.view ? this.view.zoom : 0);
            });
        }
        (_h = this.eventListeners.get('canvasInvalidated')) === null || _h === void 0 ? void 0 : _h.forEach((listener) => {
            listener(true);
        });
    }
    onImageRemovedFromCache(id) {
        const imgContainer = this.imageBitmapCache.get(id);
        imgContainer === null || imgContainer === void 0 ? void 0 : imgContainer.destroy();
        this.imageBitmapCache.delete(id);
    }
    onImageCreated(image) {
        this.imageBitmapCache.set(image.id, new _ImageContainer__WEBPACK_IMPORTED_MODULE_4__.ImageContainer(image));
        image.removeImageData();
        image.close();
    }
    getProductVersion() {
        return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_3__.PdfViewing.Sdk.version;
    }
    getXDPI() {
        var _a;
        if (this.devicePixelRatio !== window.devicePixelRatio || this.xDPI === 0) {
            const dpi = document.createElement('div');
            dpi.style.height = '1in';
            dpi.style.width = '1in';
            dpi.style.visibility = 'hidden';
            document.body.appendChild(dpi);
            this.xDPI = window.devicePixelRatio * dpi.offsetWidth;
            (_a = dpi.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(dpi);
        }
        return this.xDPI;
    }
    getYDPI() {
        var _a;
        if (this.devicePixelRatio !== window.devicePixelRatio || this.yDPI === 0) {
            const dpi = document.createElement('div');
            dpi.style.height = '1in';
            dpi.style.width = '1in';
            dpi.style.visibility = 'hidden';
            document.body.appendChild(dpi);
            this.yDPI = window.devicePixelRatio * dpi.offsetHeight;
            (_a = dpi.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(dpi);
        }
        return this.yDPI;
    }
    ViewingPdfRect2WwPdfRect(rect) {
        return {
            pdfX: rect.x,
            pdfY: rect.y,
            pdfW: rect.width,
            pdfH: rect.height,
            page: rect.pageNumber,
        };
    }
    ViewingQuadrilateral2WwPdfRect(quadrilateral) {
        if (quadrilateral.bottomLeft && quadrilateral.bottomRight && quadrilateral.topLeft) {
            const width = quadrilateral.bottomRight.x - quadrilateral.bottomLeft.x;
            const height = quadrilateral.topLeft.y - quadrilateral.bottomLeft.y;
            return {
                pdfX: quadrilateral.bottomLeft.x,
                pdfY: quadrilateral.bottomLeft.y,
                pdfW: width,
                pdfH: height,
                page: quadrilateral.pageNumber,
            };
        }
        return { page: -1, pdfX: -1, pdfY: -1, pdfW: -1, pdfH: -1 };
    }
    ViewingVPRect2WwVpRect(rect) {
        return { x: rect.x, y: rect.y, w: rect.width, h: rect.height };
    }
}


/***/ }),

/***/ "./src/common/Color.ts":
/*!*****************************!*\
  !*** ./src/common/Color.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": () => (/* binding */ Color)
/* harmony export */ });
class Color {
    constructor(color) {
        this.pR = 0;
        this.pG = 0;
        this.pB = 0;
        this.pA = 0;
        color = color.replace(/\s+/gi, '');
        if (color === 'transparent') {
            this.pR = 255;
            this.pG = 255;
            this.pB = 255;
            this.pA = 0;
        }
        else if (color.indexOf('#') === 0) {
            if (color.length === 4) {
                this.pR = parseInt(color.substring(1, 2), 16);
                this.pG = parseInt(color.substring(2, 3), 16);
                this.pB = parseInt(color.substring(3, 4), 16);
                this.pA = 255;
            }
            else if (color.length === 5) {
                this.pR = parseInt(color.substring(1, 2), 16);
                this.pG = parseInt(color.substring(2, 3), 16);
                this.pB = parseInt(color.substring(3, 4), 16);
                this.pA = parseInt(color.substring(4, 5), 16);
            }
            else if (color.length === 7) {
                this.pR = parseInt(color.substring(1, 3), 16);
                this.pG = parseInt(color.substring(3, 5), 16);
                this.pB = parseInt(color.substring(5, 7), 16);
                this.pA = 255;
            }
            else if (color.length === 9) {
                this.pR = parseInt(color.substring(1, 3), 16);
                this.pG = parseInt(color.substring(3, 5), 16);
                this.pB = parseInt(color.substring(5, 7), 16);
                this.pA = parseInt(color.substring(7, 9), 16);
            }
            else {
                throw new Error('invalid color string: ' + color);
            }
        }
        else if (color.indexOf('rgb') === 0) {
            const values = color.substring(color.indexOf('(') + 1, color.indexOf(')')).split(',');
            if (values.length < 3 || values.length > 4) {
                throw new Error('invalid color string: ' + color);
            }
            this.pR = parseInt(values[0], 10);
            this.pG = parseInt(values[1], 10);
            this.pB = parseInt(values[2], 10);
            if (values.length === 4) {
                this.pA = Math.floor(parseFloat(values[3]) * 255);
            }
            else {
                this.pA = 255;
            }
        }
        else {
            throw new Error('invalid color string: ' + color);
        }
    }
    isDark() {
        return this.pR * 0.3 + this.pG * 0.59 + this.pB * 0.11 < 127;
    }
    get r() {
        return this.pR;
    }
    set r(r) {
        this.pR = r;
    }
    get g() {
        return this.pG;
    }
    set g(g) {
        this.pG = g;
    }
    get b() {
        return this.pB;
    }
    set b(b) {
        this.pB = b;
    }
    get a() {
        return Math.floor((this.pA / 255) * 1000) / 1000;
    }
    darken(percent) {
        const f = 1 - Math.abs(percent / 100);
        const r = Math.floor(this.pR * f);
        const g = Math.floor(this.pG * f);
        const b = Math.floor(this.pB * f);
        this.pR = r > 255 ? 255 : r;
        this.pG = g > 255 ? 255 : g;
        this.pB = b > 255 ? 255 : b;
    }
    setOpacity(opacity) {
        this.pA = Math.floor(opacity * 255);
    }
    toRgb() {
        return `rgb(${this.pR},${this.pG},${this.pB})`;
    }
    toRgba() {
        return `rgba(${this.pR},${this.pG},${this.pB},${this.a})`;
    }
    toHexRgb() {
        return `#${this.toHex(this.pR)}${this.toHex(this.pG)}${this.toHex(this.pB)}`;
    }
    toHexRgba() {
        return `#${this.toHex(this.pR)}${this.toHex(this.pG)}${this.toHex(this.pB)}${this.toHex(this.pA)}`;
    }
    toHex(value) {
        let h = value.toString(16);
        if (h.length === 1) {
            h = '0' + h;
        }
        return h;
    }
}


/***/ }),

/***/ "./src/common/ColorPicker.tsx":
/*!************************************!*\
  !*** ./src/common/ColorPicker.tsx ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorPicker": () => (/* binding */ ColorPicker)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Color */ "./src/common/Color.ts");
/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Dropdown */ "./src/common/Dropdown.tsx");
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _TooltipManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TooltipManager */ "./src/common/TooltipManager.ts");






const ColorPicker = ({ icon, tooltip, disabled, colors, color, allowRgba = true, mode, onChange, }) => {
    const items = allowRgba ? colors : colors.filter((c) => new _common_Color__WEBPACK_IMPORTED_MODULE_2__.Color(c).a >= 1);
    if (mode === 'buttons' && window.innerWidth > 580) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(ColorPickerButtons, { icon: icon, colors: items, color: color, onChange: onChange });
    }
    else {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(ColorPickerDropdown, { icon: icon, tooltip: tooltip, disabled: disabled, colors: items, color: color, onChange: onChange }));
    }
};
const ColorPickerDropdown = ({ icon, tooltip, disabled, colors, color, onChange, }) => {
    if (disabled) {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ColorPicker pwv-Dropdown pwv-ToolbarItem pwv-disabled" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({}, _TooltipManager__WEBPACK_IMPORTED_MODULE_5__.tooltipManager.createTooltip(tooltip), { oncreate: _Dropdown__WEBPACK_IMPORTED_MODULE_3__.DropdownComponent.create, onremove: _Dropdown__WEBPACK_IMPORTED_MODULE_3__.DropdownComponent.remove }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: icon }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-ColorPicker__selectedColor'), style: { backgroundColor: color } }))));
    }
    else {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ColorPicker pwv-Dropdown pwv-ToolbarItem" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({}, _TooltipManager__WEBPACK_IMPORTED_MODULE_5__.tooltipManager.createTooltip(tooltip), { oncreate: _Dropdown__WEBPACK_IMPORTED_MODULE_3__.DropdownComponent.create, onremove: _Dropdown__WEBPACK_IMPORTED_MODULE_3__.DropdownComponent.remove }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: icon }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-ColorPicker__selectedColor'), style: { backgroundColor: color } })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-DropdownPanel', {
                    'pwv-DropdownPanel-wide': colors.length > 6,
                }) }, colors.map((c) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { disabled: c.toLowerCase() === color.toLowerCase(), class: (0,_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-ColorPicker__Button', {
                    'pwv-selected': c.toLowerCase() === color.toLowerCase(),
                }), onclick: (e) => {
                    onChange && onChange(c);
                } },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { style: { backgroundColor: c } })))))));
    }
};
const ColorPickerButtons = ({ icon, colors, color, onChange }) => {
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ColorPicker--buttons pwv-ToolbarItem" }, colors.map((c) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { disabled: c.toLowerCase() === color.toLowerCase(), class: (0,_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-ColorPicker__Button', {
            'pwv-selected': c.toLowerCase() === color.toLowerCase(),
        }), onclick: (e) => {
            onChange && onChange(c);
        } },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { style: { backgroundColor: c } }))))));
};


/***/ }),

/***/ "./src/common/Contextbar.tsx":
/*!***********************************!*\
  !*** ./src/common/Contextbar.tsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Contextbar": () => (/* binding */ Contextbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");

const stopPropagation = (e) => {
    e.stopPropagation();
};
const Contextbar = ({}, children) => {
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-contextbar", oncreate: (element) => {
            element.addEventListener('click', (e) => {
                e.preventDefault();
            }, { passive: false });
            element.addEventListener('mousedown', stopPropagation, false);
            element.addEventListener('mousemove', stopPropagation, false);
            element.addEventListener('mouseup', stopPropagation, false);
            element.addEventListener('touchstart', stopPropagation, { passive: false });
            element.addEventListener('touchmove', stopPropagation, { passive: true });
            element.addEventListener('touchend', stopPropagation, { passive: true });
        } },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-contextbar-content" }, children)));
};


/***/ }),

/***/ "./src/common/DragMoveHandler.ts":
/*!***************************************!*\
  !*** ./src/common/DragMoveHandler.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DragMoveHandler": () => (/* binding */ DragMoveHandler)
/* harmony export */ });
class DragMoveHandler {
    constructor(element, onDragStart, onDragMove, onDragEnd, onClick, onDblClick) {
        this.lastPosX = 0;
        this.lastPosY = 0;
        this.startPosX = 0;
        this.startPosY = 0;
        this.isSuspended = false;
        this.dragging = false;
        this.clickTimer = null;
        this.dragStartTimer = null;
        this.clickDuration = 250;
        this.dragStartDuration = 300;
        this.dblClickTimer = null;
        this.dblClickDuration = 250;
        this.suspend = this.suspend.bind(this);
        this.resume = this.resume.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.start = this.start.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this);
        this.move = this.move.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.end = this.end.bind(this);
        this.element = element;
        this.onDragStart = onDragStart;
        this.onDragMove = onDragMove;
        this.onDragEnd = onDragEnd;
        this.onClick = onClick;
        this.onDblClick = onDblClick;
        this.disableCanvasEvents = true;
        this.element.addEventListener('mousedown', this.onMouseDown, { passive: true });
        this.element.addEventListener('touchstart', this.onTouchStart, { passive: false });
    }
    suspend() {
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        this.element.removeEventListener('mousedown', this.onMouseDown);
        this.element.removeEventListener('touchstart', this.onTouchStart);
        this.isSuspended = true;
    }
    resume() {
        if (this.isSuspended) {
            this.element.addEventListener('mousedown', this.onMouseDown, { passive: true });
            this.element.addEventListener('touchstart', this.onTouchStart, { passive: false });
        }
    }
    clearClickTimer() {
        if (this.clickTimer !== null) {
            window.clearTimeout(this.clickTimer);
            this.clickTimer = null;
        }
    }
    clearDblClickTimer() {
        if (this.dblClickTimer !== null) {
            window.clearTimeout(this.dblClickTimer);
            this.dblClickTimer = null;
        }
    }
    clearDragStartTimer() {
        if (this.dragStartTimer !== null) {
            window.clearTimeout(this.dragStartTimer);
            this.dragStartTimer = null;
        }
    }
    onMouseDown(e) {
        if (e.buttons === 1) {
            this.start(e.clientX, e.clientY);
            window.addEventListener('mousemove', this.onMouseMove, { passive: true });
            window.addEventListener('mouseup', this.onMouseUp, { passive: true });
        }
    }
    onTouchStart(e) {
        if (e.touches.length === 1) {
            this.start(e.touches[0].clientX, e.touches[0].clientY);
            window.addEventListener('touchmove', this.onTouchMove, { passive: false });
            window.addEventListener('touchend', this.onTouchEnd, { passive: false });
        }
    }
    start(clientX, clientY) {
        if (this.disableCanvasEvents) {
            window.dispatchEvent(new Event('pdfwebviewer.DragMoveHandlerStart'));
        }
        this.startPosX = this.lastPosX = clientX;
        this.startPosY = this.lastPosY = clientY;
        this.dragging = false;
        if (!this.dblClickTimer) {
            this.clickTimer = window.setTimeout(() => {
                this.clickTimer = null;
            }, this.clickDuration);
            this.dragStartTimer = window.setTimeout(() => {
                this.dragging = true;
                this.onDragStart({
                    clientX: this.startPosX,
                    clientY: this.startPosY,
                    movementX: 0,
                    movementY: 0,
                    element: this.element,
                });
            }, this.dragStartDuration);
        }
    }
    onMouseMove(e) {
        this.move(e.clientX, e.clientY);
    }
    onTouchMove(e) {
        this.move(e.touches[0].clientX, e.touches[0].clientY);
    }
    move(clientX, clientY) {
        let movementX = clientX - this.lastPosX;
        let movementY = clientY - this.lastPosY;
        this.lastPosX = clientX;
        this.lastPosY = clientY;
        if (this.clickTimer || this.dragStartTimer) {
            if (Math.abs(movementX) > 5 || Math.abs(movementY) > 5) {
                this.clearClickTimer();
                this.clearDragStartTimer();
                this.dragging = true;
                this.onDragStart({
                    clientX: this.startPosX,
                    clientY: this.startPosY,
                    movementX: 0,
                    movementY: 0,
                    element: this.element,
                });
                movementX = clientX - this.startPosX;
                movementY = clientY - this.startPosY;
            }
        }
        if (this.dragging) {
            this.onDragMove({ clientX, clientY, movementX, movementY, element: this.element });
        }
    }
    onMouseUp(e) {
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        this.end();
    }
    onTouchEnd(e) {
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        this.end();
    }
    end() {
        const moved = this.startPosX !== this.lastPosX || this.startPosY !== this.lastPosY;
        const clientX = this.lastPosX;
        const clientY = this.lastPosY;
        if (this.disableCanvasEvents) {
            window.dispatchEvent(new Event('pdfwebviewer.DragMoveHandlerEnd'));
        }
        if (this.dblClickTimer !== null) {
            this.clearDblClickTimer();
            if (this.onDblClick) {
                this.onDblClick({ clientX, clientY, movementX: 0, movementY: 0, element: this.element });
            }
        }
        else if (this.clickTimer !== null) {
            if (this.onClick) {
                this.onClick({ clientX, clientY, movementX: 0, movementY: 0, element: this.element });
            }
            this.dblClickTimer = window.setTimeout(() => {
                this.dblClickTimer = null;
            }, this.dblClickDuration);
        }
        if (this.dragging) {
            this.onDragEnd({ clientX, clientY, movementX: 0, movementY: 0, moved, element: this.element });
        }
        this.clearClickTimer();
        this.clearDragStartTimer();
    }
}


/***/ }),

/***/ "./src/common/Dropdown.tsx":
/*!*********************************!*\
  !*** ./src/common/Dropdown.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dropdown": () => (/* binding */ Dropdown),
/* harmony export */   "DropdownComponent": () => (/* binding */ DropdownComponent)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _TooltipManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TooltipManager */ "./src/common/TooltipManager.ts");
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");




const Dropdown = ({ disabled, text, icon, name, value, tooltip, width, className, items, align, hideCaret, renderButton, onChange, }) => {
    const selectedItem = items.find((item) => item.value === value);
    if (!text && selectedItem) {
        text = selectedItem.text;
    }
    const style = width
        ? {
            width: width + 'px',
        }
        : {};
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_3__.classNames)('pwv-Dropdown', { 'pwv-disabled': disabled }, { 'pwv-Dropdown--alignLeft': !align || align === 'left' }, { 'pwv-Dropdown--alignRight': align === 'right' }, { 'pwv-Dropdown--alignCenter': align === 'center' }, className), style: style },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({ name: name }, _TooltipManager__WEBPACK_IMPORTED_MODULE_1__.tooltipManager.createTooltip(tooltip), { oncreate: DropdownComponent.create, onremove: DropdownComponent.remove, disabled: disabled }),
            renderButton ? (renderButton(value, text)) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-text" },
                icon && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: icon }),
                text)),
            !hideCaret && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-caret" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: _Icon__WEBPACK_IMPORTED_MODULE_2__.icons.dropdownCaret })))),
        !disabled && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-DropdownPanel" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("ul", null, items.map((item) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", { class: "pwv-DropdownItem", onclick: () => onChange && onChange(item.value) }, item.renderItem ? (item.renderItem(item)) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-item-text" }, item.text))))))))));
};
class DropdownComponent {
    constructor(btnElement) {
        this.button = btnElement;
        this.element = btnElement.parentElement;
        this.handleOnClick = this.handleOnClick.bind(this);
        this.setMaxPanelHeight = this.setMaxPanelHeight.bind(this);
        this.button.addEventListener('click', this.handleOnClick, false);
        _TooltipManager__WEBPACK_IMPORTED_MODULE_1__.tooltipManager.bindCssTooltip(this.button);
        window.addEventListener('resize', this.setMaxPanelHeight);
    }
    static create(btnElement) {
        ;
        btnElement.parentElement.dropdown = new DropdownComponent(btnElement);
    }
    static remove(btnElement) {
        ;
        btnElement.parentElement.dropdown.unmount();
    }
    unmount() {
        this.button.removeEventListener('click', this.handleOnClick);
        this.button.removeEventListener('resize', this.setMaxPanelHeight);
    }
    setMaxPanelHeight() {
        const dropdownPanel = this.element.querySelector('.pwv-DropdownPanel');
        if (dropdownPanel) {
            const maxHeight = window.innerHeight - dropdownPanel.getBoundingClientRect().top;
            if (dropdownPanel.scrollHeight > maxHeight) {
                dropdownPanel.style.maxHeight = `${maxHeight - 10}px`;
                dropdownPanel.classList.add('pwv-DropdownPanel--scroll');
            }
            else {
                dropdownPanel.style.maxHeight = '';
                dropdownPanel.classList.remove('pwv-DropdownPanel--scroll');
            }
        }
    }
    handleOnClick(e) {
        if (!this.element.classList.contains('pwv-Dropdown--open')) {
            this.element.classList.add('pwv-Dropdown--open');
            this.setMaxPanelHeight();
            const t = new Date().getTime();
            e.openDropdown = t;
            const closeDropdownPanel = (ev) => {
                if (ev.openDropdown !== t) {
                    window.removeEventListener('click', closeDropdownPanel);
                    this.element.classList.remove('pwv-Dropdown--open');
                }
            };
            window.addEventListener('click', closeDropdownPanel, false);
        }
    }
}


/***/ }),

/***/ "./src/common/DropdownMenu.tsx":
/*!*************************************!*\
  !*** ./src/common/DropdownMenu.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DropdownMenu": () => (/* binding */ DropdownMenu)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _TooltipManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TooltipManager */ "./src/common/TooltipManager.ts");
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");
/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Dropdown */ "./src/common/Dropdown.tsx");





const DropdownMenu = ({ icon, className, tooltip }, children) => {
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_3__.classNames)('pwv-Dropdown', className) },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({ class: "pwv-ToolbarButton" }, _TooltipManager__WEBPACK_IMPORTED_MODULE_1__.tooltipManager.createTooltip(tooltip), { oncreate: _Dropdown__WEBPACK_IMPORTED_MODULE_4__.DropdownComponent.create, onremove: _Dropdown__WEBPACK_IMPORTED_MODULE_4__.DropdownComponent.remove }), icon && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: icon })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-DropdownPanel" }, children)));
};


/***/ }),

/***/ "./src/common/DropdownSeparator.tsx":
/*!******************************************!*\
  !*** ./src/common/DropdownSeparator.tsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DropdownSeparator": () => (/* binding */ DropdownSeparator)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");

const DropdownSeparator = ({}) => {
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-DropdownSeparator" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null)));
};


/***/ }),

/***/ "./src/common/Icon.tsx":
/*!*****************************!*\
  !*** ./src/common/Icon.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Icon": () => (/* binding */ Icon),
/* harmony export */   "icons": () => (/* reexport safe */ _icons__WEBPACK_IMPORTED_MODULE_2__.icons)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons */ "./src/common/icons.ts");



const Icon = ({ icon, className, fill, bg, title }) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-icon', className), title: title },
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { viewBox: `0 0 ${icon.width} ${icon.height}` },
        icon.bg && bg && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: icon.bg, fill: bg }),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("path", { d: icon.path, fill: fill, "shape-rendering": "geometricPrecision", "stroke-width": "1px" }))));


/***/ }),

/***/ "./src/common/Loader.tsx":
/*!*******************************!*\
  !*** ./src/common/Loader.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Loader": () => (/* binding */ Loader)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");

const Loader = ({}) => {
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-Loader" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null)));
};


/***/ }),

/***/ "./src/common/RangeSlider.tsx":
/*!************************************!*\
  !*** ./src/common/RangeSlider.tsx ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RangeSlider": () => (/* binding */ RangeSlider)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dropdown */ "./src/common/Dropdown.tsx");
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");
/* harmony import */ var _TooltipManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TooltipManager */ "./src/common/TooltipManager.ts");





const RangeSlider = ({ min, max, value, icon, className, text, tooltip, label, disabled, onChange, }) => {
    const elmProps = {
        title: tooltip,
    };
    if (disabled) {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", Object.assign({}, _TooltipManager__WEBPACK_IMPORTED_MODULE_4__.tooltipManager.createTooltip(tooltip), { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_3__.classNames)('pwv-RangeSlider', 'pwv-ToolbarItem', 'pwv-Dropdown', 'pwv-disabled', className) }),
            label ||
                (icon && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-label" },
                    label,
                    icon && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: icon })))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-text" }, text),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-caret" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: _Icon__WEBPACK_IMPORTED_MODULE_2__.icons.dropdownCaret }))));
    }
    else {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_3__.classNames)('pwv-RangeSlider', 'pwv-commandbar-item', 'pwv-Dropdown', className) },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({}, _TooltipManager__WEBPACK_IMPORTED_MODULE_4__.tooltipManager.createTooltip(tooltip), { oncreate: _Dropdown__WEBPACK_IMPORTED_MODULE_1__.DropdownComponent.create, onremove: _Dropdown__WEBPACK_IMPORTED_MODULE_1__.DropdownComponent.remove }),
                label ||
                    (icon && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-label" },
                        label,
                        icon && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: icon })))),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-text" }, text),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-caret" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: _Icon__WEBPACK_IMPORTED_MODULE_2__.icons.dropdownCaret }))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-DropdownPanel" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { type: "range", min: min, max: max, value: value, oninput: (e) => {
                        const input = e.currentTarget;
                        const intVal = parseInt(input.value, undefined);
                        onChange(intVal);
                    }, onchange: (e) => {
                        e.preventDefault();
                        const input = e.currentTarget;
                        window.dispatchEvent(new Event('click'));
                    } }))));
    }
};


/***/ }),

/***/ "./src/common/StrokeStylePicker.tsx":
/*!******************************************!*\
  !*** ./src/common/StrokeStylePicker.tsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StrokeStylePicker": () => (/* binding */ StrokeStylePicker)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dropdown */ "./src/common/Dropdown.tsx");



const StrokeItem = ({ value }) => {
    const strokeStyle = value === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle.DASHED ? 'dashed' : 'solid';
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `pwv-stroke-style-picker-item pwv-stroke-style-${strokeStyle}` },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null)));
};
const StrokeButton = ({ value }) => {
    const strokeStyle = value === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle.DASHED ? 'dashed' : 'solid';
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `pwv-stroke-style-picker-button pwv-stroke-style-${strokeStyle}` },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null)));
};
const StrokeStylePicker = ({ disabled, value, tooltip, shapeType, onChange, }) => {
    const items = [_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle.SOLID, _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle.DASHED].map((item) => ({
        value: item,
        renderItem: (i) => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(StrokeItem, { value: item }),
    }));
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Dropdown__WEBPACK_IMPORTED_MODULE_2__.Dropdown, { className: `pwv-stroke-style-picker pwv-stroke-style-picker-${shapeType}`, align: "right", disabled: disabled, tooltip: tooltip, items: items, value: value, renderButton: (value) => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(StrokeButton, { value: value }), onChange: onChange }));
};


/***/ }),

/***/ "./src/common/StrokeWidthPicker.tsx":
/*!******************************************!*\
  !*** ./src/common/StrokeWidthPicker.tsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StrokeWidthPicker": () => (/* binding */ StrokeWidthPicker)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _Dropdown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dropdown */ "./src/common/Dropdown.tsx");


const StrokeItem = ({ value, noneStrokeText }) => {
    if (value === 0) {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-stroke-width-picker-item" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, noneStrokeText)));
    }
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-stroke-width-picker-item" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null,
            value,
            "pt"),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-stroke-width", style: { height: `${value}px` } })));
};
const StrokeWidthPicker = ({ disabled, noneStrokeText, strokeWidths, value, tooltip, onChange, }) => {
    const items = strokeWidths.map((item) => ({
        value: item,
        renderItem: (i) => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(StrokeItem, { value: i.value, noneStrokeText: noneStrokeText }),
    }));
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Dropdown__WEBPACK_IMPORTED_MODULE_1__.Dropdown, { className: "pwv-stroke-width-picker", align: "right", tooltip: tooltip, disabled: disabled, items: items, value: value, renderButton: (value) => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(StrokeItem, { value: value, noneStrokeText: noneStrokeText }), onChange: onChange }));
};


/***/ }),

/***/ "./src/common/Toolbar.tsx":
/*!********************************!*\
  !*** ./src/common/Toolbar.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Toolbar": () => (/* binding */ Toolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");


const Toolbar = ({ className, dense, allowWrap, alignCenter }, children) => {
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-Toolbar', { 'pwv-Toolbar--center': alignCenter }, { 'pwv-Toolbar--dense': dense }, { 'pwv-Toolbar--wrap': allowWrap }, className) }, children));
};


/***/ }),

/***/ "./src/common/ToolbarButton.tsx":
/*!**************************************!*\
  !*** ./src/common/ToolbarButton.tsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolbarButton": () => (/* binding */ ToolbarButton)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");
/* harmony import */ var _TooltipManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TooltipManager */ "./src/common/TooltipManager.ts");




const ToolbarButton = ({ icon, disabled, active, name, onClick, tooltip, className }, children) => {
    if (disabled) {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({ name: name, disabled: disabled, oncreate: _TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.bindCssTooltip }, _TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.createTooltip(tooltip), { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_2__.classNames)('pwv-ToolbarButton', 'pwv-ToolbarButton--disabled', className) }),
            icon && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: icon }),
            children.length > 0 && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-ToolbarButton__Text" }, children)));
    }
    else {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({ name: name, oncreate: _TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.bindCssTooltip }, _TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.createTooltip(tooltip), { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_2__.classNames)('pwv-ToolbarButton', className, {
                'pwv-ToolbarButton--selected': active,
            }), onclick: (e) => {
                onClick && onClick(e);
            } }),
            icon && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: icon }),
            children.length > 0 && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-ToolbarButton__Text" }, children)));
    }
};


/***/ }),

/***/ "./src/common/ToolbarFileButton.tsx":
/*!******************************************!*\
  !*** ./src/common/ToolbarFileButton.tsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolbarFileButton": () => (/* binding */ ToolbarFileButton)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");
/* harmony import */ var _TooltipManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TooltipManager */ "./src/common/TooltipManager.ts");




const ToolbarFileButton = ({ icon, accept, className, tooltip, disabled, name, onFileSelected, }) => {
    if (disabled) {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", Object.assign({ oncreate: _TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.bindCssTooltip }, _TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.createTooltip(tooltip), { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_2__.classNames)('pwv-ToolbarButton', 'pwv-ToolbarButton--disabled', className) }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: icon })));
    }
    else {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("label", Object.assign({ name: name, tabindex: "auto", oncreate: _TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.bindCssTooltip }, _TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.createTooltip(tooltip), { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_2__.classNames)('pwv-ToolbarButton', className) }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: icon }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { style: { display: 'none' }, type: "file", accept: accept, onchange: (e) => {
                    if (onFileSelected && e.currentTarget.files && e.currentTarget.files.length) {
                        const file = e.currentTarget.files[0];
                        onFileSelected(file);
                        e.currentTarget.value = '';
                    }
                }, oncreate: (input) => {
                    const id = 'fi_' + performance.now();
                    input.id = id;
                    const label = input.parentElement;
                    label.setAttribute('for', id);
                } })));
    }
};


/***/ }),

/***/ "./src/common/ToolbarItemGroup.tsx":
/*!*****************************************!*\
  !*** ./src/common/ToolbarItemGroup.tsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolbarItemGroup": () => (/* binding */ ToolbarItemGroup)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classNames */ "./src/common/classNames.ts");


const ToolbarItemGroup = ({ className, pushRight }, children) => {
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-ToolbarItemGroup', className, {
            'pwv-ToolbarItemGroup--pushRight': pushRight,
        }), oncreate: (element) => {
            if (pushRight) {
                element.parentNode.classList.add('pwv-Toolbar--paddingRight');
            }
        } }, children));
};


/***/ }),

/***/ "./src/common/ToolbarSeparator.tsx":
/*!*****************************************!*\
  !*** ./src/common/ToolbarSeparator.tsx ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolbarSeparator": () => (/* binding */ ToolbarSeparator)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");

const ToolbarSeparator = ({}) => {
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ToolbarSeparator" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null)));
};


/***/ }),

/***/ "./src/common/Tools.ts":
/*!*****************************!*\
  !*** ./src/common/Tools.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertCssToPdfPixel": () => (/* binding */ convertCssToPdfPixel),
/* harmony export */   "convertPdfToCssPixel": () => (/* binding */ convertPdfToCssPixel),
/* harmony export */   "createPdfTime": () => (/* binding */ createPdfTime),
/* harmony export */   "formatDate": () => (/* binding */ formatDate),
/* harmony export */   "getColorPalette": () => (/* binding */ getColorPalette),
/* harmony export */   "imageDataUrlToUint8Array": () => (/* binding */ imageDataUrlToUint8Array),
/* harmony export */   "padString": () => (/* binding */ padString),
/* harmony export */   "roundToTwo": () => (/* binding */ roundToTwo)
/* harmony export */ });
/* harmony import */ var _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pdf-viewer-api/enums */ "./src/pdf-viewer-api/enums.ts");

function convertPdfToCssPixel(pdfPixel) {
    const regex = /(\d*\.?\d+)/.exec(pdfPixel);
    const size = regex && regex.length > 1 ? parseFloat(regex[1]) : 12;
    return roundToTwo((size / 72) * 96) + 'px';
}
function convertCssToPdfPixel(cssPixel) {
    const regex = /(\d*\.?\d+)/.exec(cssPixel);
    const size = regex && regex.length > 1 ? parseFloat(regex[1]) : 12;
    return roundToTwo((size / 96) * 72) + 'pt';
}
function roundToTwo(num) {
    return Math.round(num * 100) / 100;
}
function getColorPalette(type, options) {
    if (type === _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.INK) {
        return options.annotation.colors.foregroundColors;
    }
    else {
        return options.annotation.colors.highlightColors;
    }
}
function createPdfTime() {
    const time = new Date();
    const year = time.getFullYear();
    let month = `${time.getMonth() + 1}`;
    month = padString(month, 2, '0');
    let day = `${time.getDate()}`;
    day = padString(day, 2, '0');
    let hour = `${time.getHours()}`;
    hour = padString(hour, 2, '0');
    let minutes = `${time.getMinutes()}`;
    minutes = padString(minutes, 2, '0');
    let seconds = `${time.getSeconds()}`;
    seconds = padString(seconds, 2, '0');
    let offsetString = time.getTimezoneOffset() < 0 ? '+' : '';
    const hourOffset = -1 * Math.floor(time.getTimezoneOffset() / 60);
    offsetString += padString(hourOffset.toString(), 2, '0') + `'`;
    const minuteOffset = -1 * Math.floor(time.getTimezoneOffset() % 60);
    offsetString += padString(minuteOffset.toString(), 2, '0') + `'`;
    const dateString = `(D:${year}${month}${day}${hour}${minutes}${seconds}${offsetString})`;
    return dateString;
}
const formatDate = (dateStr) => {
    if (dateStr.indexOf('(D:') === 0) {
        return `${dateStr.substring(9, 11)}.${dateStr.substring(7, 11)}.${dateStr.substring(3, 7)} ${dateStr.substring(11, 13)}:${dateStr.substring(13, 15)}`;
    }
    return `${dateStr.substring(8, 10)}.${dateStr.substring(6, 8)}.${dateStr.substring(2, 6)} ${dateStr.substring(10, 12)}:${dateStr.substring(12, 14)}`;
};
function padString(s, paddingSize, fill) {
    if (s.length < paddingSize) {
        s = `${fill.repeat(paddingSize - s.length)}${s}`;
    }
    return s;
}
function imageDataUrlToUint8Array(dataUrl) {
    const base64 = dataUrl.replace(/^data:[a-z]+\/[a-z]+;base64,/i, '');
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    const lookup = new Uint8Array(256);
    for (let i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
    }
    let bufferLength = base64.length * 0.75;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength);
    const bytes = new Uint8Array(arraybuffer);
    let p = 0;
    let encoded1 = 0;
    let encoded2 = 0;
    let encoded3 = 0;
    let encoded4 = 0;
    for (let i = 0; i < base64.length; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return bytes;
}


/***/ }),

/***/ "./src/common/TooltipManager.ts":
/*!**************************************!*\
  !*** ./src/common/TooltipManager.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tooltipManager": () => (/* binding */ tooltipManager)
/* harmony export */ });
let tooltipType;
const tooltipManager = {
    setType: (type) => {
        tooltipType = type;
    },
    bindCssTooltip: (element, text) => {
        if (tooltipType !== 'css') {
            return;
        }
        element.onmouseover = (e) => {
            const elm = e.currentTarget;
            let viewerElm = elm.closest('.pwv-ViewerCanvas');
            if (!viewerElm) {
                viewerElm = elm.closest('.pwv-WebViewer');
            }
            if (viewerElm) {
                elm.classList.remove('pwv-tooltip-top', 'pwv-tooltip-left', 'pwv-tooltip-right', 'pwv-tooltip-bottom');
                const elmRect = elm.getBoundingClientRect();
                const viewerRect = viewerElm.getBoundingClientRect();
                const top = elmRect.top - viewerRect.top;
                const left = elmRect.left - viewerRect.left;
                const right = viewerRect.right - elmRect.right;
                const bottom = viewerRect.bottom - elmRect.bottom;
                top < 45
                    ? element.classList.add('pwv-tooltip-bottom')
                    : element.classList.add('pwv-tooltip-top');
                if (left < 45) {
                    element.classList.add('pwv-tooltip-right');
                }
                else if (right < 45) {
                    element.classList.add('pwv-tooltip-left');
                }
            }
        };
    },
    createTooltip: (text) => {
        if (!text) {
            return undefined;
        }
        switch (tooltipType) {
            case 'title':
                return {
                    title: text,
                };
            case 'css':
                return {
                    'data-pwv-tooltip': text,
                };
            default:
                return undefined;
        }
    },
};


/***/ }),

/***/ "./src/common/TranslationManager.ts":
/*!******************************************!*\
  !*** ./src/common/TranslationManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "translationManager": () => (/* binding */ translationManager)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
let translations = {};
let translationRequested = false;
const translationManager = {
    language: '',
    addTranslations: (res) => {
        translations = Object.assign(Object.assign({}, translations), res);
    },
    getText: (key) => {
        const res = translations[key];
        if (!res) {
            switch (key) {
                case 'applicationError.title':
                    return 'Error';
                case 'applicationError.defaultMessage':
                    return 'Configuration Error';
                case 'applicationError.reload':
                    return '';
            }
            console.warn(`key not found ${key}`);
            return key;
        }
        return res;
    },
    loadTranslations: (language) => __awaiter(void 0, void 0, void 0, function* () {
        if (language !== translationManager.language ||
            (!translationRequested && Object.keys(translations).length === 0)) {
            translationManager.language = language;
            translationRequested = true;
            const translationFileUrl = window.Module.locateFile(`translations.${language}.json`);
            try {
                const res = yield fetch(translationFileUrl);
                if (res.ok) {
                    translations = yield res.json();
                }
                else {
                    throw new Error(`failed to load translation file '${translationFileUrl}`);
                }
            }
            catch (err) {
                console.error(`**************************************
Failed to load translations.${language}.js

%cThe PDF Web Viewer failed to load a required script resource. Either the "Base URL" (PDFTOOLS_FOURHEIGHTS_PDFVIEWING_BASEURL) is not configured correctly or the static assets have not been copied to the configured location. For more information please consult the documentation.

%cwindow.PDFTOOLS_FOURHEIGHTS_PDFVIEWING_BASEURL=${window.PDFTOOLS_FOURHEIGHTS_PDFVIEWING_BASEURL}
%c**************************************`, 'color: orange', 'color: gray', 'color: red');
            }
        }
    }),
};


/***/ }),

/***/ "./src/common/classNames.ts":
/*!**********************************!*\
  !*** ./src/common/classNames.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "classNames": () => (/* binding */ classNames)
/* harmony export */ });
const classNames = (...args) => {
    const classes = [];
    args.forEach((arg) => {
        if (typeof arg === 'string') {
            classes.push(arg);
        }
        else if (typeof arg === 'object') {
            const keys = Object.keys(arg);
            keys.forEach((k) => {
                if (arg[k]) {
                    classes.push(k);
                }
            });
        }
    });
    return classes.join(' ');
};


/***/ }),

/***/ "./src/common/icons.ts":
/*!*****************************!*\
  !*** ./src/common/icons.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "icons": () => (/* binding */ icons)
/* harmony export */ });
const icons = {
    openFile: {
        width: 576,
        height: 512,
        path: 'M527.95 224H480v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h385.057c28.068 0 54.135-14.733 68.599-38.84l67.453-112.464C588.24 264.812 565.285 224 527.95 224zM48 96h146.745l64 64H432c8.837 0 16 7.163 16 16v48H171.177c-28.068 0-54.135 14.733-68.599 38.84L32 380.47V112c0-8.837 7.163-16 16-16zm493.695 184.232l-67.479 112.464A47.997 47.997 0 0 1 433.057 416H44.823l82.017-136.696A48 48 0 0 1 168 256h359.975c12.437 0 20.119 13.568 13.72 24.232z',
    },
    saveFile: {
        width: 448,
        height: 512,
        path: 'M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM288 64v96H96V64h192zm128 368c0 8.822-7.178 16-16 16H48c-8.822 0-16-7.178-16-16V80c0-8.822 7.178-16 16-16h16v104c0 13.255 10.745 24 24 24h208c13.255 0 24-10.745 24-24V64.491a15.888 15.888 0 0 1 7.432 4.195l83.882 83.882A15.895 15.895 0 0 1 416 163.882V432zM224 232c-48.523 0-88 39.477-88 88s39.477 88 88 88 88-39.477 88-88-39.477-88-88-88zm0 144c-30.879 0-56-25.121-56-56s25.121-56 56-56 56 25.121 56 56-25.121 56-56 56z',
    },
    print: {
        width: 512,
        height: 512,
        path: 'M432 192h-16v-82.75c0-8.49-3.37-16.62-9.37-22.63L329.37 9.37c-6-6-14.14-9.37-22.63-9.37H126.48C109.64 0 96 14.33 96 32v160H80c-44.18 0-80 35.82-80 80v96c0 8.84 7.16 16 16 16h80v112c0 8.84 7.16 16 16 16h288c8.84 0 16-7.16 16-16V384h80c8.84 0 16-7.16 16-16v-96c0-44.18-35.82-80-80-80zM320 45.25L370.75 96H320V45.25zM128.12 32H288v64c0 17.67 14.33 32 32 32h64v64H128.02l.1-160zM384 480H128v-96h256v96zm96-128H32v-80c0-26.47 21.53-48 48-48h352c26.47 0 48 21.53 48 48v80zm-80-88c-13.25 0-24 10.74-24 24 0 13.25 10.75 24 24 24s24-10.75 24-24c0-13.26-10.75-24-24-24z',
    },
    docNavigation: {
        width: 512,
        height: 512,
        path: 'M464 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm16 400c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V192h448v240zM32 160V80c0-8.8 7.2-16 16-16h416c8.8 0 16 7.2 16 16v80H32z',
    },
    nextPage: {
        width: 448,
        height: 512,
        path: 'M216.464 36.465l-7.071 7.07c-4.686 4.686-4.686 12.284 0 16.971L387.887 239H12c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h375.887L209.393 451.494c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l211.051-211.05c4.686-4.686 4.686-12.284 0-16.971L233.434 36.465c-4.686-4.687-12.284-4.687-16.97 0z',
    },
    previousPage: {
        width: 448,
        height: 512,
        path: 'M231.536 475.535l7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L60.113 273H436c6.627 0 12-5.373 12-12v-10c0-6.627-5.373-12-12-12H60.113L238.607 60.506c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0L3.515 247.515c-4.686 4.686-4.686 12.284 0 16.971l211.051 211.05c4.686 4.686 12.284 4.686 16.97-.001z',
    },
    zoomIn: {
        width: 512,
        height: 512,
        path: 'M384 250v12c0 6.6-5.4 12-12 12h-98v98c0 6.6-5.4 12-12 12h-12c-6.6 0-12-5.4-12-12v-98h-98c-6.6 0-12-5.4-12-12v-12c0-6.6 5.4-12 12-12h98v-98c0-6.6 5.4-12 12-12h12c6.6 0 12 5.4 12 12v98h98c6.6 0 12 5.4 12 12zm120 6c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-32 0c0-119.9-97.3-216-216-216-119.9 0-216 97.3-216 216 0 119.9 97.3 216 216 216 119.9 0 216-97.3 216-216z',
    },
    zoomOut: {
        width: 512,
        height: 512,
        path: 'M140 274c-6.6 0-12-5.4-12-12v-12c0-6.6 5.4-12 12-12h232c6.6 0 12 5.4 12 12v12c0 6.6-5.4 12-12 12H140zm364-18c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-32 0c0-119.9-97.3-216-216-216-119.9 0-216 97.3-216 216 0 119.9 97.3 216 216 216 119.9 0 216-97.3 216-216z',
    },
    search: {
        width: 512,
        height: 512,
        path: 'M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395 312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5 0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17 0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208 32s176 78.7 176 176-78.7 176-176 176z',
    },
    fitActualSize: {
        width: 448,
        height: 512,
        path: 'M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H32v116c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zM300 32h124c13.3 0 24 10.7 24 24v124c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12V64H300c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12zm148 300v124c0 13.3-10.7 24-24 24H300c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h116V332c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12zM148 480H24c-13.3 0-24-10.7-24-24V332c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v116h116c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12z',
    },
    fitWidth: {
        width: 512,
        height: 512,
        path: 'M399.959 170.585c-4.686 4.686-4.686 12.284 0 16.971L451.887 239H60.113l51.928-51.444c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0l-84.485 84c-4.686 4.686-4.686 12.284 0 16.971l84.485 84c4.686 4.686 12.284 4.686 16.97 0l7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L60.113 273h391.773l-51.928 51.444c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l84.485-84c4.687-4.686 4.687-12.284 0-16.971l-84.485-84c-4.686-4.686-12.284-4.686-16.97 0l-7.07 7.071z',
    },
    fitPage: {
        width: 512,
        height: 512,
        path: 'M337.782 434.704l-73.297 73.782c-4.686 4.686-12.284 4.686-16.971 0l-73.296-73.782c-4.686-4.686-4.686-12.284 0-16.97l7.07-7.07c4.686-4.686 12.284-4.686 16.971 0L239 451.887h1V272H60.113v1l41.224 40.741c4.686 4.686 4.686 12.284 0 16.971l-7.071 7.07c-4.686 4.686-12.284 4.686-16.97 0L3.515 264.485c-4.686-4.686-4.686-12.284 0-16.971l73.782-73.297c4.686-4.686 12.284-4.686 16.971 0l7.071 7.071c4.686 4.686 4.686 12.284 0 16.971L60.113 239v1H240V60.113h-1l-40.741 41.224c-4.686 4.686-12.284 4.686-16.971 0l-7.07-7.071c-4.686-4.686-4.687-12.284 0-16.97l73.297-73.782c4.686-4.686 12.284-4.686 16.971 0l73.297 73.782c4.686 4.686 4.686 12.284 0 16.971l-7.071 7.071c-4.686 4.686-12.284 4.686-16.971 0L273 60.113h-1V240h179.887v-1l-41.224-40.741c-4.686-4.686-4.686-12.284 0-16.971l7.071-7.07c4.686-4.686 12.284-4.686 16.97 0l73.782 73.297c4.687 4.686 4.686 12.284 0 16.971l-73.782 73.297c-4.686 4.686-12.284 4.686-16.97 0l-7.071-7.07c-4.686-4.686-4.686-12.284 0-16.971L451.887 273v-1H272v179.887h1l40.741-41.224c4.686-4.686 12.284-4.686 16.971 0l7.07 7.071c4.686 4.685 4.686 12.283 0 16.97z',
    },
    edit: {
        width: 576,
        height: 512,
        path: 'M417.8 315.5l20-20c3.8-3.8 10.2-1.1 10.2 4.2V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h292.3c5.3 0 8 6.5 4.2 10.2l-20 20c-1.1 1.1-2.7 1.8-4.2 1.8H48c-8.8 0-16 7.2-16 16v352c0 8.8 7.2 16 16 16h352c8.8 0 16-7.2 16-16V319.7c0-1.6.6-3.1 1.8-4.2zm145.9-191.2L251.2 436.8l-99.9 11.1c-13.4 1.5-24.7-9.8-23.2-23.2l11.1-99.9L451.7 12.3c16.4-16.4 43-16.4 59.4 0l52.6 52.6c16.4 16.4 16.4 43 0 59.4zm-93.6 48.4L403.4 106 169.8 339.5l-8.3 75.1 75.1-8.3 233.5-233.6zm71-85.2l-52.6-52.6c-3.8-3.8-10.2-4-14.1 0L426 83.3l66.7 66.7 48.4-48.4c3.9-3.8 3.9-10.2 0-14.1z',
    },
    stickyNote: {
        width: 512,
        height: 512,
        path: 'M448 0H64C28.7 0 0 28.7 0 64v288c0 35.3 28.7 64 64 64h96v84c0 7.1 5.8 12 12 12 2.4 0 4.9-.7 7.1-2.4L304 416h144c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64zm32 352c0 17.6-14.4 32-32 32H293.3l-8.5 6.4L192 460v-76H64c-17.6 0-32-14.4-32-32V64c0-17.6 14.4-32 32-32h384c17.6 0 32 14.4 32 32v288zM280 240H136c-4.4 0-8 3.6-8 8v16c0 4.4 3.6 8 8 8h144c4.4 0 8-3.6 8-8v-16c0-4.4-3.6-8-8-8zm96-96H136c-4.4 0-8 3.6-8 8v16c0 4.4 3.6 8 8 8h240c4.4 0 8-3.6 8-8v-16c0-4.4-3.6-8-8-8z',
        bg: 'M 448,0 H 64 C 28.7,0 0,28.7 0,64 v 288 c 0,35.3 28.7,64 64,64 h 96 v 84 c 0,7.1 5.8,12 12,12 2.4,0 4.9,-0.7 7.1,-2.4 L 304,416 h 144 c 35.3,0 64,-28.7 64,-64 V 64 C 512,28.7 483.3,0 448,0 Z',
    },
    stickyNoteAdd: {
        width: 512,
        height: 512,
        path: 'M448 0H64C28.7 0 0 28.7 0 64v288c0 35.3 28.7 64 64 64h96v84c0 7.1 5.8 12 12 12 2.4 0 4.9-.7 7.1-2.4L304 416h144c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64zm32 352c0 17.6-14.4 32-32 32H293.3l-8.5 6.4L192 460v-76H64c-17.6 0-32-14.4-32-32V64c0-17.6 14.4-32 32-32h384c17.6 0 32 14.4 32 32v288zM344 192h-72v-72c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v72h-72c-4.4 0-8 3.6-8 8v16c0 4.4 3.6 8 8 8h72v72c0 4.4 3.6 8 8 8h16c4.4 0 8-3.6 8-8v-72h72c4.4 0 8-3.6 8-8v-16c0-4.4-3.6-8-8-8z',
    },
    stickyNoteEdit: {
        width: 512,
        height: 512,
        path: 'M448 0H64C28.7 0 0 28.7 0 64v288c0 35.3 28.7 64 64 64h96v84c0 7.1 5.8 12 12 12 2.4 0 4.9-.7 7.1-2.4L304 416h144c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64zm32 352c0 17.6-14.4 32-32 32H293.3l-8.5 6.4L192 460v-76H64c-17.6 0-32-14.4-32-32V64c0-17.6 14.4-32 32-32h384c17.6 0 32 14.4 32 32v288zM336 105.4c-12.5-12.5-32.8-12.5-45.2 0l-126.1 126c-2 2-3.4 4.5-4.2 7.3l-16 61.2c-1.4 5.5.1 11.3 4.2 15.4 3 3 7.1 4.7 11.3 4.7 1.3 0 2.7-.2 4-.5l61.2-16c2.8-.7 5.3-2.2 7.3-4.2l126.1-126.1c12.5-12.5 12.5-32.8 0-45.2L336 105.4zM213 273.6l-30.6 8 8-30.6 75-75 22.6 22.6-75 75zm97.6-97.6L288 153.4l25.4-25.4 22.6 22.6-25.4 25.4z',
    },
    stickyNoteRemove: {
        width: 640,
        height: 512,
        path: 'M637 485.2l-96.7-76.1-22.5-17.7-443.2-349-5.2-4.1L23 1.8C19.6-1 14.5-.4 11.8 3l-10 12.5C-1 19-.4 24 3 26.8l61 48L96 100l360.7 284 15.9 12.5L617 510.2c3.4 2.8 8.5 2.2 11.2-1.2l10-12.5c2.8-3.5 2.2-8.5-1.2-11.3zM368 384h-10.7l-8.5 6.4L256 460v-76H128c-17.6 0-32-14.4-32-32V161.1l-32-25.2V352c0 35.3 28.7 64 64 64h96v84c0 7.1 5.8 12 12 12 2.4 0 4.9-.7 7.1-2.4L368 416h51.7l-40.6-32H368zM512 32c17.6 0 32 14.4 32 32v286.9l28.2 22.2c2.3-6.6 3.8-13.7 3.8-21.1V64c0-35.3-28.7-64-64-64H128c-8.4 0-16.4 1.7-23.7 4.7L139 32h373z',
    },
    nextMatch: {
        width: 448,
        height: 512,
        path: 'M311.03 131.515l-7.071 7.07c-4.686 4.686-4.686 12.284 0 16.971L387.887 239H12c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h375.887l-83.928 83.444c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l116.485-116c4.686-4.686 4.686-12.284 0-16.971L328 131.515c-4.686-4.687-12.284-4.687-16.97 0z',
    },
    previousMatch: {
        width: 448,
        height: 512,
        path: 'M136.97 380.485l7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L60.113 273H436c6.627 0 12-5.373 12-12v-10c0-6.627-5.373-12-12-12H60.113l83.928-83.444c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0l-116.485 116c-4.686 4.686-4.686 12.284 0 16.971l116.485 116c4.686 4.686 12.284 4.686 16.97-.001z',
    },
    outlineOpen: {
        width: 320,
        height: 512,
        path: 'M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z',
    },
    outlineClosed: {
        width: 192,
        height: 512,
        path: 'M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z',
    },
    dropdownCaret: {
        width: 448,
        height: 512,
        path: 'M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z',
    },
    addLayer: {
        width: 512,
        height: 512,
        path: 'M504 96h-88V8c0-4.42-3.58-8-8-8h-16c-4.42 0-8 3.58-8 8v88h-88c-4.42 0-8 3.58-8 8v16c0 4.42 3.58 8 8 8h88v88c0 4.42 3.58 8 8 8h16c4.42 0 8-3.58 8-8v-88h88c4.42 0 8-3.58 8-8v-16c0-4.42-3.58-8-8-8zm-6.77 270.71l-99.72-42.87 99.72-42.87c8.35-3.6 12.19-13.23 8.58-21.52-3.65-8.29-13.32-12.13-21.74-8.48l-225.32 96.86c-1.81.77-3.74.77-5.48 0L45.23 258.4l193.45-83.16c8.35-3.59 12.19-13.23 8.58-21.52-3.65-8.28-13.26-12.13-21.74-8.48L14.81 235.81C5.81 239.66 0 248.52 0 258.4c0 9.87 5.81 18.74 14.77 22.58l99.73 42.87-99.7 42.85C5.81 370.55 0 379.42 0 389.31c0 9.87 5.81 18.74 14.77 22.58l225.32 96.84c5.06 2.17 10.48 3.28 15.9 3.28s10.84-1.09 15.9-3.28l225.29-96.83c9-3.85 14.81-12.72 14.81-22.59.01-9.89-5.8-18.76-14.76-22.6zM258.74 478.72c-1.81.77-3.74.77-5.48 0L45.23 389.29 156 341.68l84.1 36.15c5.06 2.17 10.48 3.28 15.9 3.28s10.84-1.09 15.9-3.28l84.12-36.16 110.78 47.62-208.06 89.43z',
    },
    eraser: {
        width: 512,
        height: 512,
        path: 'M497.942 273.941c18.745-18.745 18.745-49.137 0-67.882l-160-160c-18.744-18.744-49.136-18.746-67.883 0l-256 256c-18.745 18.745-18.745 49.137 0 67.882l96 96A48 48 0 0 0 144 480h356c6.627 0 12-5.373 12-12v-8c0-6.627-5.373-12-12-12H323.883l174.059-174.059zM292.686 68.687c6.243-6.243 16.374-6.254 22.628-.001l160 160c6.243 6.243 6.253 16.374 0 22.627L358.627 368.001 176 185.373 292.686 68.687zM144 448a15.895 15.895 0 0 1-11.314-4.686l-96-96c-6.243-6.243-6.253-16.374 0-22.627L153.373 208 336 390.628l-52.686 52.686A15.895 15.895 0 0 1 272 448H144z',
    },
    ok: {
        width: 448,
        height: 512,
        path: 'M413.505 91.951L133.49 371.966l-98.995-98.995c-4.686-4.686-12.284-4.686-16.971 0L6.211 284.284c-4.686 4.686-4.686 12.284 0 16.971l118.794 118.794c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-11.314-11.314c-4.686-4.686-12.284-4.686-16.97 0z',
    },
    alignCenter: {
        width: 448,
        height: 512,
        path: 'M352 52v24a6 6 0 0 1-6 6H102a6 6 0 0 1-6-6V52a6 6 0 0 1 6-6h244a6 6 0 0 1 6 6zM6 210h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6zm0 256h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6zm340-164H102a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6h244a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6z',
    },
    alignJustify: {
        width: 448,
        height: 512,
        path: 'M0 76V52a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6H6a6 6 0 0 1-6-6zm6 134h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6zm0 256h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6zm0-128h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6z',
    },
    alignLeft: {
        width: 448,
        height: 512,
        path: 'M288 52v24a6 6 0 0 1-6 6H6a6 6 0 0 1-6-6V52a6 6 0 0 1 6-6h276a6 6 0 0 1 6 6zM6 210h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6zm0 256h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6zm276-164H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6h276a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6z',
    },
    alignRight: {
        width: 448,
        height: 512,
        path: 'M160 76V52a6 6 0 0 1 6-6h276a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6H166a6 6 0 0 1-6-6zM6 210h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6zm0 256h436a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H6a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6zm160-128h276a6 6 0 0 0 6-6v-24a6 6 0 0 0-6-6H166a6 6 0 0 0-6 6v24a6 6 0 0 0 6 6z',
    },
    bold: {
        width: 320,
        height: 512,
        path: 'M249.139 242.128c33.922-18.988 53.22-53.503 53.22-95.748 0-42.421-19.499-80.713-49.665-97.55C232.561 37.505 207.478 32 176.01 32H12C5.373 32 0 37.373 0 44v8c0 6.627 5.373 12 12 12h19.95v384H12c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h169.68c19.934 0 45.622-1.177 67.493-10.348C292.198 451.781 320 406.247 320 353.65c0-52.496-28.196-96.372-70.861-111.522zM66.041 64.201H176.01c24.929 0 43.694 4.153 57.357 12.692 21.38 13.439 33.642 38.537 33.642 68.858 0 49.531-32.265 82.81-80.289 82.81H66.041V64.201zm167.194 375.685c-12.585 5.325-29.449 7.914-51.555 7.914H66.041V260.76h124.458c56.314 0 94.151 37.837 94.151 94.151 0 40.208-19.2 71.966-51.415 84.975z',
    },
    italic: {
        width: 256,
        height: 512,
        path: 'M102.791 64h45.215L73.143 448H23.762a12 12 0 0 0-11.764 9.632l-1.61 8C8.892 473.062 14.573 480 22.151 480h128.817a12 12 0 0 0 11.764-9.632l1.61-8c1.495-7.43-4.186-14.368-11.764-14.368h-45.215l74.864-384h50.011a12 12 0 0 0 11.764-9.632l1.61-8C247.108 38.938 241.427 32 233.849 32H104.401a12 12 0 0 0-11.764 9.632l-1.61 8C89.532 57.062 95.213 64 102.791 64z',
    },
    underline: {
        width: 448,
        height: 512,
        path: 'M0 500v-8c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v8c0 6.627-5.373 12-12 12H12c-6.627 0-12-5.373-12-12zM291.142 12v8c0 6.627 5.373 12 12 12h42.72v226.509c0 85.451-46.451 128.726-122.145 128.726-74.322 0-121.569-40.289-121.569-127.572V32h42.721c6.627 0 12-5.373 12-12v-8c0-6.627-5.373-12-12-12H26.659c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12H69.38v228.818c0 106.811 63.591 158.094 154.913 158.094 89.287 0 154.337-52.813 154.337-158.094V32h42.721c6.627 0 12-5.373 12-12v-8c0-6.627-5.373-12-12-12H303.142c-6.628 0-12 5.373-12 12z',
    },
    squiggly: {
        width: 448,
        height: 512,
        path: 'M 111.80004,416.25781 -0.09375,473.46875 v 38.51563 l 111.89379,-57.21094 112.14242,57.33789 112.14243,-57.33985 112.14244,57.33985 V 473.59375 L 336.08881,416.25781 223.94246,473.5957 Z M 291.142,12 v 8 c 0,6.627 5.373,12 12,12 h 42.72 v 226.509 c 0,85.451 -46.451,128.726 -122.145,128.726 -74.322,0 -121.569,-40.289 -121.569,-127.572 V 32 h 42.721 c 6.627,0 12,-5.373 12,-12 v -8 c 0,-6.627 -5.373,-12 -12,-12 H 26.659 c -6.627,0 -12,5.373 -12,12 v 8 c 0,6.627 5.373,12 12,12 H 69.38 v 228.818 c 0,106.811 63.591,158.094 154.913,158.094 89.287,0 154.337,-52.813 154.337,-158.094 V 32 h 42.721 c 6.627,0 12,-5.373 12,-12 v -8 c 0,-6.627 -5.373,-12 -12,-12 H 303.142 c -6.628,0 -12,5.373 -12,12 z',
    },
    strikethrough: {
        width: 512,
        height: 512,
        path: 'M500 272H12c-6.627 0-12-5.373-12-12v-8c0-6.627 5.373-12 12-12h488c6.627 0 12 5.373 12 12v8c0 6.627-5.373 12-12 12zm-199.246 16c34.104 17.688 58.216 40.984 58.216 83.01 0 57.657-45.969 87.221-104.86 87.221-43.044 0-101.711-17.734-101.711-60.762V388c0-6.627-5.373-12-12-12h-10.72c-6.627 0-12 5.373-12 12v15.77c0 60.082 76.565 87.291 136.431 87.291 78.593 0 140.211-46.632 140.211-123.832 0-35.712-11.87-60.522-30.603-79.229h-62.964zm-137.387-64h74.348c-43.357-17.896-75.865-37.601-75.865-84.203 0-52.844 43.64-79.03 96.041-79.03 32.008 0 90.37 12.598 90.37 44.38V116c0 6.627 5.373 12 12 12h10.721c6.627 0 12-5.373 12-12V96.327c0-44.421-64.45-68.391-125.091-68.391-72.526 0-131.392 41.225-131.392 115.011 0 38.214 14.813 63.053 36.868 81.053z',
    },
    fontColor: {
        width: 448,
        height: 512,
        path: 'M232.594 32h-17.187a11.998 11.998 0 0 0-11.239 7.796L51.473 448H28c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h88c6.627 0 12-5.373 12-12v-8c0-6.627-5.373-12-12-12H87.913l44.651-120.46h182.253L360.063 448H332c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h88c6.627 0 12-5.373 12-12v-8c0-6.627-5.373-12-12-12h-23.473L243.833 39.796A12 12 0 0 0 232.594 32zm-87.958 263.34l75.696-201.241c1.5-3.857 2.714-7.827 3.668-11.427.95 3.589 2.159 7.544 3.651 11.382l75.098 201.286H144.636z',
    },
    fillColor: {
        width: 576,
        height: 512,
        path: 'M512 320s-64 92.65-64 128c0 35.35 28.66 64 64 64s64-28.65 64-64-64-128-64-128zm0 160c-17.64 0-32-14.36-32-31.96.26-9.78 13.57-37.67 32.01-68.73 18.43 31.04 31.73 58.91 31.99 68.69 0 17.64-14.36 32-32 32zm-9.37-262.94L294.94 9.37C288.69 3.12 280.5 0 272.31 0s-16.38 3.12-22.62 9.37l-92.85 92.85L56.97 2.35c-3.12-3.12-8.19-3.12-11.31 0L34.34 13.66c-3.12 3.12-3.12 8.19 0 11.31l99.88 99.88-106.1 106.1c-37.49 37.49-37.49 98.26 0 135.75l117.19 117.19c18.75 18.74 43.31 28.12 67.87 28.12 24.57 0 49.13-9.37 67.87-28.12l221.57-221.57c12.5-12.5 12.5-32.76.01-45.26zm-244.2 244.2C246.34 473.34 230.27 480 213.18 480s-33.16-6.66-45.24-18.74l-117.2-117.2c-6.88-6.88-11.77-15.14-14.91-24.06h363.85L258.43 461.26zM431.68 288H33.06c2.2-12.96 8.2-24.94 17.69-34.43l106.09-106.11 87.85 87.85c6.25 6.25 16.38 6.25 22.62 0 6.25-6.25 6.25-16.38 0-22.62l-87.85-87.85L272.29 32h.02L480 239.68 431.68 288z',
    },
    drop: {
        width: 352,
        height: 512,
        path: 'M205.22 22.09C201.21 7.53 188.61 0 175.97 0c-12.35 0-24.74 7.2-29.19 22.09C100.01 179.85 0 222.72 0 333.91 0 432.35 78.72 512 176 512s176-79.65 176-178.09c0-111.75-99.79-153.34-146.78-311.82zM176 480c-79.4 0-144-65.54-144-146.09 0-48.36 23-81.32 54.84-126.94 29.18-41.81 65.34-93.63 89.18-170.91 23.83 77.52 60.06 129.31 89.3 171.08C297.06 252.52 320 285.3 320 333.91 320 414.46 255.4 480 176 480zm0-64c-44.12 0-80-35.89-80-80 0-8.84-7.16-16-16-16s-16 7.16-16 16c0 61.75 50.25 112 112 112 8.84 0 16-7.16 16-16s-7.16-16-16-16z',
    },
    checkbox: {
        width: 448,
        height: 512,
        path: 'M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm16 400c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V80c0-8.8 7.2-16 16-16h352c8.8 0 16 7.2 16 16v352z',
    },
    checkboxChecked: {
        width: 448,
        height: 512,
        path: 'M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zm0 32c8.823 0 16 7.178 16 16v352c0 8.822-7.177 16-16 16H48c-8.822 0-16-7.178-16-16V80c0-8.822 7.178-16 16-16h352m-34.301 98.293l-8.451-8.52c-4.667-4.705-12.265-4.736-16.97-.068l-163.441 162.13-68.976-69.533c-4.667-4.705-12.265-4.736-16.97-.068l-8.52 8.451c-4.705 4.667-4.736 12.265-.068 16.97l85.878 86.572c4.667 4.705 12.265 4.736 16.97.068l180.48-179.032c4.704-4.667 4.735-12.265.068-16.97z',
    },
    pageLayoutModeNone: {
        width: 512,
        height: 512,
        path: 'M 404.00446,340.39588 H 307.417 c -8.8907,0 -16.09791,-7.20735 -16.09791,-16.0979 V 226.90563 H 129.53513 c -9.33519,0 -16.90281,7.56764 -16.90281,16.90282 V 508.86602 H 82.046291 V 243.80845 c 0,-26.22737 21.261469,-47.48883 47.488839,-47.48883 h 185.16393 c 13.26225,0 25.94064,5.4538 35.06108,15.08212 l 76.00853,80.24116 c 5.66469,5.9802 8.82181,13.90391 8.82181,22.14106 v 195.63997 h -30.58602 z m -1.01739,-27.15345 -79.47231,-86.3368 h -1.60979 v 86.3368 z M 82.851029,3.1447104 H 113.43705 V 99.732162 c 0,9.335168 7.56762,16.902808 16.90282,16.902808 h 257.56652 c 9.33518,0 16.9028,-7.56764 16.9028,-16.902808 V 3.1447104 h 30.58603 V 99.732162 c 0,26.227348 -21.26147,47.488828 -47.48883,47.488828 H 130.33987 c -26.22737,0 -47.488841,-21.26148 -47.488841,-47.488828 z',
    },
    pageLayoutModeSinglePage: {
        width: 384,
        height: 512,
        path: 'M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zm-22.6 22.7c2.1 2.1 3.5 4.6 4.2 7.4H256V32.5c2.8.7 5.3 2.1 7.4 4.2l83.9 83.9zM336 480H48c-8.8 0-16-7.2-16-16V48c0-8.8 7.2-16 16-16h176v104c0 13.3 10.7 24 24 24h104v304c0 8.8-7.2 16-16 16z',
    },
    warning: {
        width: 576,
        height: 512,
        path: 'M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.054-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.952 83.154 0l239.94 416.028zm-27.658 15.991l-240-416c-6.16-10.678-21.583-10.634-27.718 0l-240 416C27.983 466.678 35.731 480 48 480h480c12.323 0 19.99-13.369 13.859-23.996zM288 372c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28zm-11.49-212h22.979c6.823 0 12.274 5.682 11.99 12.5l-7 168c-.268 6.428-5.556 11.5-11.99 11.5h-8.979c-6.433 0-11.722-5.073-11.99-11.5l-7-168c-.283-6.818 5.167-12.5 11.99-12.5zM288 372c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28z',
    },
    lock: {
        width: 448,
        height: 512,
        path: 'M224 420c-11 0-20-9-20-20v-64c0-11 9-20 20-20s20 9 20 20v64c0 11-9 20-20 20zm224-148v192c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V272c0-26.5 21.5-48 48-48h16v-64C64 71.6 136-.3 224.5 0 312.9.3 384 73.1 384 161.5V224h16c26.5 0 48 21.5 48 48zM96 224h256v-64c0-70.6-57.4-128-128-128S96 89.4 96 160v64zm320 240V272c0-8.8-7.2-16-16-16H48c-8.8 0-16 7.2-16 16v192c0 8.8 7.2 16 16 16h352c8.8 0 16-7.2 16-16z',
    },
    unlock: {
        width: 640,
        height: 512,
        path: 'M227 417c-11 0-20-9-20-20v-64c0-11 9-20 20-20s20 9 20 20v64c0 11-9 20-20 20zM480.5 0C392-.3 320 71.6 320 160v64H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48h-48v-62.6c0-70.7 56.7-129 127.3-129.4C550.2 31.6 608 89.2 608 160v84c0 6.6 5.4 12 12 12h8c6.6 0 12-5.4 12-12v-82.5C640 73.1 568.9.3 480.5 0zM400 256c8.8 0 16 7.2 16 16v192c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V272c0-8.8 7.2-16 16-16h352z',
    },
    history: {
        width: 512,
        height: 512,
        path: 'M20 24h10c6.627 0 12 5.373 12 12v94.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H164c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V36c0-6.627 5.373-12 12-12zm321.647 315.235l4.706-6.47c3.898-5.36 2.713-12.865-2.647-16.763L272 263.853V116c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v164.147l84.884 61.734c5.36 3.899 12.865 2.714 16.763-2.646z',
    },
    error: {
        width: 512,
        height: 512,
        path: 'M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z',
    },
    pdfFile: {
        width: 384,
        height: 512,
        path: 'M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zm-22.6 22.7c2.1 2.1 3.5 4.6 4.2 7.4H256V32.5c2.8.7 5.3 2.1 7.4 4.2l83.9 83.9zM336 480H48c-8.8 0-16-7.2-16-16V48c0-8.8 7.2-16 16-16h176v104c0 13.3 10.7 24 24 24h104v304c0 8.8-7.2 16-16 16zm-48-244v8c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm0 64v8c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm0 64v8c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12z',
    },
    fileError: {
        width: 384,
        height: 512,
        path: 'M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zm-22.6 22.7c2.1 2.1 3.5 4.6 4.2 7.4H256V32.5c2.8.7 5.3 2.1 7.4 4.2l83.9 83.9zM336 480H48c-8.8 0-16-7.2-16-16V48c0-8.8 7.2-16 16-16h176v104c0 13.3 10.7 24 24 24h104v304c0 8.8-7.2 16-16 16zm-73.3-127.9c4.7 4.7 4.7 12.3 0 17l-5.7 5.7c-4.7 4.7-12.3 4.7-17 0l-48-48.2-48.1 48.1c-4.7 4.7-12.3 4.7-17 0l-5.7-5.7c-4.7-4.7-4.7-12.3 0-17l48.1-48.1-48.1-48.1c-4.7-4.7-4.7-12.3 0-17l5.7-5.7c4.7-4.7 12.3-4.7 17 0l48.1 48.1 48.1-48.1c4.7-4.7 12.3-4.7 17 0l5.7 5.7c4.7 4.7 4.7 12.3 0 17L214.6 304l48.1 48.1z',
    },
    sidePaneThumbnails: {
        width: 512,
        height: 512,
        path: 'M 111.73 0.28125 C 85.231 0.28125 63.73 21.781 63.73 48.281 L 63.73 63.73 L 48.359 63.73 C 21.859 63.73 0.35938 85.231 0.35938 111.73 L 0.35938 463.73 C 0.35938 490.23 21.859 511.73 48.359 511.73 L 400.36 511.73 C 426.86 511.73 448.36 490.23 448.36 463.73 L 448.36 448.28 L 463.73 448.28 C 490.23 448.28 511.73 426.78 511.73 400.28 L 511.73 48.281 C 511.73 21.781 490.23 0.28125 463.73 0.28125 L 111.73 0.28125 z M 111.73 32.281 L 463.73 32.281 C 472.55 32.281 479.73 39.461 479.73 48.281 L 479.73 400.28 C 479.73 409.1 472.55 416.28 463.73 416.28 L 448.36 416.28 L 448.36 111.73 C 448.36 85.231 426.86 63.73 400.36 63.73 L 95.73 63.73 L 95.73 48.281 C 95.73 39.461 102.91 32.281 111.73 32.281 z M 48.359 95.73 L 400.36 95.73 C 409.18 95.73 416.36 102.91 416.36 111.73 L 416.36 463.73 C 416.36 472.55 409.18 479.73 400.36 479.73 L 48.359 479.73 C 39.539 479.73 32.359 472.55 32.359 463.73 L 32.359 111.73 C 32.359 102.91 39.539 95.73 48.359 95.73 z M 104.36 175.73 C 99.938 175.73 96.359 179.31 96.359 183.73 L 96.359 199.73 C 96.359 204.15 99.938 207.73 104.36 207.73 L 248.36 207.73 C 252.78 207.73 256.36 204.15 256.36 199.73 L 256.36 183.73 C 256.36 179.31 252.78 175.73 248.36 175.73 L 104.36 175.73 z M 104.36 271.73 C 99.938 271.73 96.359 275.31 96.359 279.73 L 96.359 295.73 C 96.359 300.15 99.938 303.73 104.36 303.73 L 344.36 303.73 C 348.78 303.73 352.36 300.15 352.36 295.73 L 352.36 279.73 C 352.36 275.31 348.78 271.73 344.36 271.73 L 104.36 271.73 z M 104.36 367.73 C 99.938 367.73 96.359 371.31 96.359 375.73 L 96.359 391.73 C 96.359 396.15 99.938 399.73 104.36 399.73 L 184.36 399.73 C 188.78 399.73 192.36 396.15 192.36 391.73 L 192.36 375.73 C 192.36 371.31 188.78 367.73 184.36 367.73 L 104.36 367.73 z',
    },
    sidePaneAnnotation: {
        width: 512,
        height: 512,
        path: 'M448 0H64C28.7 0 0 28.7 0 64v288c0 35.3 28.7 64 64 64h96v84c0 7.1 5.8 12 12 12 2.4 0 4.9-.7 7.1-2.4L304 416h144c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64zm32 352c0 17.6-14.4 32-32 32H293.3l-8.5 6.4L192 460v-76H64c-17.6 0-32-14.4-32-32V64c0-17.6 14.4-32 32-32h384c17.6 0 32 14.4 32 32v288zM280 240H136c-4.4 0-8 3.6-8 8v16c0 4.4 3.6 8 8 8h144c4.4 0 8-3.6 8-8v-16c0-4.4-3.6-8-8-8zm96-96H136c-4.4 0-8 3.6-8 8v16c0 4.4 3.6 8 8 8h240c4.4 0 8-3.6 8-8v-16c0-4.4-3.6-8-8-8z',
    },
    sidePaneOutline: {
        width: 512,
        height: 512,
        path: 'M88 56H40a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h48a16 16 0 0 0 16-16V72a16 16 0 0 0-16-16zm0 160H40a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h48a16 16 0 0 0 16-16v-48a16 16 0 0 0-16-16zm0 160H40a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h48a16 16 0 0 0 16-16v-48a16 16 0 0 0-16-16zm416 24H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8zm0-320H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8V88a8 8 0 0 0-8-8zm0 160H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8z',
    },
    annotation: {
        width: 512,
        height: 512,
        path: 'M256 64c123.5 0 224 79 224 176S379.5 416 256 416c-28.3 0-56.3-4.3-83.2-12.8l-15.2-4.8-13 9.2c-23 16.3-58.5 35.3-102.6 39.6 12-15.1 29.8-40.4 40.8-69.6l7.1-18.7-13.7-14.6C47.3 313.7 32 277.6 32 240c0-97 100.5-176 224-176m0-32C114.6 32 0 125.1 0 240c0 47.6 19.9 91.2 52.9 126.3C38 405.7 7 439.1 6.5 439.5c-6.6 7-8.4 17.2-4.6 26 3.8 8.8 12.4 14.5 22 14.5 61.5 0 110-25.7 139.1-46.3 29 9.1 60.2 14.3 93 14.3 141.4 0 256-93.1 256-208S397.4 32 256 32z',
        bg: 'M 256,32 C 114.6,32 0,125.1 0,240 0,287.6 19.9,331.2 52.9,366.3 38,405.7 7,439.1 6.5,439.5 c -6.6,7 -8.4,17.2 -4.6,26 3.8,8.8 12.4,14.5 22,14.5 61.5,0 110,-25.7 139.1,-46.3 29,9.1 60.2,14.3 93,14.3 141.4,0 256,-93.1 256,-208 C 512,125.1 397.4,32 256,32 Z',
    },
    highlighter: {
        width: 544,
        height: 512,
        path: 'M528.61 75.91l-60.49-60.52C457.91 5.16 444.45 0 430.98 0a52.38 52.38 0 0 0-34.75 13.15L110.59 261.8c-10.29 9.08-14.33 23.35-10.33 36.49l12.49 41.02-36.54 36.56c-6.74 6.75-6.74 17.68 0 24.43l.25.26L0 479.98 99.88 512l43.99-44.01.02.02c6.75 6.75 17.69 6.75 24.44 0l36.46-36.47 40.91 12.53c18.01 5.51 31.41-4.54 36.51-10.32l248.65-285.9c18.35-20.82 17.37-52.32-2.25-71.94zM91.05 475.55l-32.21-10.33 40.26-42.03 22.14 22.15-30.19 30.21zm167.16-62.99c-.63.72-1.4.94-2.32.94-.26 0-.54-.02-.83-.05l-40.91-12.53-18.39-5.63-39.65 39.67-46.85-46.88 39.71-39.72-5.6-18.38-12.49-41.02c-.34-1.13.01-2.36.73-3l44.97-39.15 120.74 120.8-39.11 44.95zm248.51-285.73L318.36 343.4l-117.6-117.66L417.4 37.15c4.5-3.97 17.55-9.68 28.1.88l60.48 60.52c7.65 7.65 8.04 20 .74 28.28z',
        bg: 'M 528.61,75.91 468.12,15.39 C 457.91,5.16 444.45,0 430.98,0 418.17896,-0.01016736 405.81733,4.6676871 396.23,13.15 L 110.59,261.8 c -10.29,9.08 -14.33,23.35 -10.33,36.49 l 12.49,41.02 -36.54,36.56 c -6.74,6.75 -6.74,17.68 0,24.43 l 0.25,0.26 L 0,479.98 99.88,512 l 43.99,-44.01 0.02,0.02 c 6.75,6.75 17.69,6.75 24.44,0 l 36.46,-36.47 40.91,12.53 c 18.01,5.51 31.41,-4.54 36.51,-10.32 l 248.65,-285.9 c 18.35,-20.82 17.37,-52.32 -2.25,-71.94 z',
    },
    rectangularHighlighter: {
        width: 512,
        height: 512,
        path: 'M486.4 128c14.14 0 25.6-11.46 25.6-25.6V25.6C512 11.46 500.54 0 486.4 0h-76.8C395.46 0 384 11.46 384 25.6V48H128V25.6C128 11.46 116.54 0 102.4 0H25.6C11.46 0 0 11.46 0 25.6v76.8C0 116.54 11.46 128 25.6 128H48v256H25.6C11.46 384 0 395.46 0 409.6v76.8C0 500.54 11.46 512 25.6 512h76.8c14.14 0 25.6-11.46 25.6-25.6V464h256v22.4c0 14.14 11.46 25.6 25.6 25.6h76.8c14.14 0 25.6-11.46 25.6-25.6v-76.8c0-14.14-11.46-25.6-25.6-25.6H464V128h22.4zM416 32h64v64h-64V32zM32 96V32h64v64H32zm64 384H32v-64h64v64zm384-64v64h-64v-64h64zm-48-32h-22.4c-14.14 0-25.6 11.46-25.6 25.6V432H128v-22.4c0-14.14-11.46-25.6-25.6-25.6H80V128h22.4c14.14 0 25.6-11.46 25.6-25.6V80h256v22.4c0 14.14 11.46 25.6 25.6 25.6H432v256z',
    },
    pencil: {
        width: 512,
        height: 512,
        path: 'M493.255 56.236l-37.49-37.49c-24.993-24.993-65.515-24.994-90.51 0L12.838 371.162.151 485.346c-1.698 15.286 11.22 28.203 26.504 26.504l114.184-12.687 352.417-352.417c24.992-24.994 24.992-65.517-.001-90.51zm-95.196 140.45L174 420.745V386h-48v-48H91.255l224.059-224.059 82.745 82.745zM126.147 468.598l-58.995 6.555-30.305-30.305 6.555-58.995L63.255 366H98v48h48v34.745l-19.853 19.853zm344.48-344.48l-49.941 49.941-82.745-82.745 49.941-49.941c12.505-12.505 32.748-12.507 45.255 0l37.49 37.49c12.506 12.506 12.507 32.747 0 45.255z',
        bg: 'm 493.255,56.236 -37.49,-37.49 c -24.993,-24.993 -65.515,-24.994 -90.51,0 L 12.838,371.162 0.151,485.346 c -1.698,15.286 11.22,28.203 26.504,26.504 L 140.839,499.163 493.256,146.746 c 24.992,-24.994 24.992,-65.517 -10e-4,-90.51 z',
    },
    freeText: {
        width: 512,
        height: 512,
        path: 'm 460,81 v 72 c 0,4.42 -3.58,8 -8,8 h -16 c -4.42,0 -8,-3.58 -8,-8 V 97 H 272 v 338 h 72 c 4.42,0 8,3.58 8,8 v 16 c 0,4.42 -3.58,8 -8,8 H 168 c -4.42,0 -8,-3.58 -8,-8 v -16 c 0,-4.42 3.58,-8 8,-8 h 72 V 97 H 84 v 56 c 0,4.42 -3.582,8 -8,8 H 60 c -4.418,0 -8,-3.58 -8,-8 V 81 c 0,-8.837 7.163,-16 16,-16 h 376 c 8.84,0 16,7.163 16,16 z',
        bg: 'M512 512H0V0h512v512z',
    },
    stamp: {
        width: 508,
        height: 512,
        path: 'm 333.71644,332.74589 h 121.26625 l 52.08896,87.08726 H 508.009 V 512.0005 H 0 V 419.83315 H 0.80598227 L 54.686486,332.74589 H 178.89175 V 241.68498 C 139.83419,229.2037 120.83357,188.0785 120.83357,122.28502 120.83357,50.03435 163.8049,8.54414 246.15327,0.3862 V 0 h 4.2226 14.81043 v 0.26345 c 83.1756,7.85642 126.58831,49.40078 126.58831,122.02157 0,65.79348 -19.00062,106.91868 -58.05817,119.39996 z m 0,26.85191 v 11.42093 l -0.57524,1.90136 c -7.77664,25.70458 -26.80014,40.76443 -54.91507,44.75071 -3.13022,0.44382 -6.37313,0.75038 -9.72577,0.91907 2e-5,0.0515 5e-5,0.10303 8e-5,0.15469 h -18.12457 -4.2226 c 0,-0.0231 0,-0.0462 0,-0.0693 -34.59286,-1.15044 -57.8689,-16.6105 -66.68629,-45.75514 l -0.57523,-1.90136 V 359.5978 H 70.109423 L 33.186454,419.83315 H 474.69705 l -35.1373,-60.23535 z m -72.20597,-332.75872 -5.41897,-0.0189 -4.95803,0.0158 C 180.53972,32.90225 147.68548,63.8059 147.68548,122.285 c 0,60.26373 16.08094,90.41551 46.87034,95.62098 l 11.18782,1.8915 v 147.12358 c 5.83066,16.85951 19.64352,24.97158 44.63223,24.97158 h 5.92822 5.92822 c 24.9887,0 38.80158,-8.11207 44.63222,-24.97158 V 219.79748 l 11.18782,-1.8915 c 30.7894,-5.20547 46.87035,-35.35725 46.87035,-95.62098 0,-58.46923 -32.84314,-89.37232 -103.41223,-95.44594 z M 26.96748,485.1486 H 481.04152 V 446.68506 H 26.96748 Z',
        bg: 'm 333.71644,332.74589 h 121.26625 l 52.08896,87.08726 H 508.009 V 512.0005 H 0 V 419.83315 H 0.80598227 L 54.686486,332.74589 H 178.89175 V 241.68498 C 139.83419,229.2037 120.83357,188.0785 120.83357,122.28502 120.83357,50.03435 163.8049,8.54414 246.15327,0.3862 V 0 h 4.2226 14.81043 v 0.26345 c 83.1756,7.85642 126.58831,49.40078 126.58831,122.02157 0,65.79348 -19.00062,106.91868 -58.05817,119.39996 z',
    },
    rotate: {
        width: 512,
        height: 512,
        path: 'M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z',
    },
    rotateLeft: {
        width: 512,
        height: 512,
        path: 'M20 8h10c6.627 0 12 5.373 12 12v110.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H180c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V20c0-6.627 5.373-12 12-12z',
    },
    rotateRight: {
        width: 512,
        height: 512,
        path: 'M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z',
    },
    close: {
        width: 320,
        height: 512,
        path: 'M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z',
    },
    options: {
        width: 512,
        height: 512,
        path: 'M482.696 299.276l-32.61-18.827a195.168 195.168 0 0 0 0-48.899l32.61-18.827c9.576-5.528 14.195-16.902 11.046-27.501-11.214-37.749-31.175-71.728-57.535-99.595-7.634-8.07-19.817-9.836-29.437-4.282l-32.562 18.798a194.125 194.125 0 0 0-42.339-24.48V38.049c0-11.13-7.652-20.804-18.484-23.367-37.644-8.909-77.118-8.91-114.77 0-10.831 2.563-18.484 12.236-18.484 23.367v37.614a194.101 194.101 0 0 0-42.339 24.48L105.23 81.345c-9.621-5.554-21.804-3.788-29.437 4.282-26.36 27.867-46.321 61.847-57.535 99.595-3.149 10.599 1.47 21.972 11.046 27.501l32.61 18.827a195.168 195.168 0 0 0 0 48.899l-32.61 18.827c-9.576 5.528-14.195 16.902-11.046 27.501 11.214 37.748 31.175 71.728 57.535 99.595 7.634 8.07 19.817 9.836 29.437 4.283l32.562-18.798a194.08 194.08 0 0 0 42.339 24.479v37.614c0 11.13 7.652 20.804 18.484 23.367 37.645 8.909 77.118 8.91 114.77 0 10.831-2.563 18.484-12.236 18.484-23.367v-37.614a194.138 194.138 0 0 0 42.339-24.479l32.562 18.798c9.62 5.554 21.803 3.788 29.437-4.283 26.36-27.867 46.321-61.847 57.535-99.595 3.149-10.599-1.47-21.972-11.046-27.501zm-65.479 100.461l-46.309-26.74c-26.988 23.071-36.559 28.876-71.039 41.059v53.479a217.145 217.145 0 0 1-87.738 0v-53.479c-33.621-11.879-43.355-17.395-71.039-41.059l-46.309 26.74c-19.71-22.09-34.689-47.989-43.929-75.958l46.329-26.74c-6.535-35.417-6.538-46.644 0-82.079l-46.329-26.74c9.24-27.969 24.22-53.869 43.929-75.969l46.309 26.76c27.377-23.434 37.063-29.065 71.039-41.069V44.464a216.79 216.79 0 0 1 87.738 0v53.479c33.978 12.005 43.665 17.637 71.039 41.069l46.309-26.76c19.709 22.099 34.689 47.999 43.929 75.969l-46.329 26.74c6.536 35.426 6.538 46.644 0 82.079l46.329 26.74c-9.24 27.968-24.219 53.868-43.929 75.957zM256 160c-52.935 0-96 43.065-96 96s43.065 96 96 96 96-43.065 96-96-43.065-96-96-96zm0 160c-35.29 0-64-28.71-64-64s28.71-64 64-64 64 28.71 64 64-28.71 64-64 64z',
    },
    delete: {
        width: 512,
        height: 512,
        path: 'M368 64l-33.6-44.8C325.3 7.1 311.1 0 296 0h-80c-15.1 0-29.3 7.1-38.4 19.2L144 64H40c-13.3 0-24 10.7-24 24v2c0 3.3 2.7 6 6 6h20.9l33.2 372.3C78.3 493 99 512 123.9 512h264.2c24.9 0 45.6-19 47.8-43.7L469.1 96H490c3.3 0 6-2.7 6-6v-2c0-13.3-10.7-24-24-24H368zM216 32h80c5 0 9.8 2.4 12.8 6.4L328 64H184l19.2-25.6c3-4 7.8-6.4 12.8-6.4zm188 433.4c-.7 8.3-7.6 14.6-15.9 14.6H123.9c-8.3 0-15.2-6.3-15.9-14.6L75 96h362l-33 369.4z',
    },
    copy: {
        width: 448,
        height: 512,
        path: 'M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM352 32.491a15.88 15.88 0 0 1 7.431 4.195l51.882 51.883A15.885 15.885 0 0 1 415.508 96H352V32.491zM288 464c0 8.822-7.178 16-16 16H48c-8.822 0-16-7.178-16-16V144c0-8.822 7.178-16 16-16h80v240c0 26.51 21.49 48 48 48h112v48zm128-96c0 8.822-7.178 16-16 16H176c-8.822 0-16-7.178-16-16V48c0-8.822 7.178-16 16-16h144v72c0 13.2 10.8 24 24 24h72v240z',
    },
    created: {
        width: 448,
        height: 512,
        path: 'M400 64c8.8 0 16 7.2 16 16v352c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V80c0-8.8 7.2-16 16-16h352m0-32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-60 206h-98v-98c0-6.6-5.4-12-12-12h-12c-6.6 0-12 5.4-12 12v98h-98c-6.6 0-12 5.4-12 12v12c0 6.6 5.4 12 12 12h98v98c0 6.6 5.4 12 12 12h12c6.6 0 12-5.4 12-12v-98h98c6.6 0 12-5.4 12-12v-12c0-6.6-5.4-12-12-12z',
    },
    pen: {
        width: 512,
        height: 512,
        path: 'M493.25 56.26l-37.51-37.51C443.25 6.25 426.87 0 410.49 0s-32.76 6.25-45.26 18.74L12.85 371.12.15 485.34C-1.45 499.72 9.88 512 23.95 512c.89 0 1.78-.05 2.69-.15l114.14-12.61 352.48-352.48c24.99-24.99 24.99-65.51-.01-90.5zM126.09 468.68l-93.03 10.31 10.36-93.17 263.89-263.89 82.77 82.77-263.99 263.98zm344.54-344.54l-57.93 57.93-82.77-82.77 57.93-57.93c6.04-6.04 14.08-9.37 22.63-9.37 8.55 0 16.58 3.33 22.63 9.37l37.51 37.51c12.47 12.48 12.47 32.78 0 45.26z',
    },
    rectangle: {
        width: 512,
        height: 512,
        path: 'M480 32v448H32V32h448m32-32H0v512h512V0z',
        bg: 'M 512,0 H 0 v 512 h 512 z',
    },
    circle: {
        width: 512,
        height: 512,
        path: 'M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm216 248c0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216z',
        bg: 'M 256,8 C 119,8 8,119 8,256 8,393 119,504 256,504 393,504 504,393 504,256 504,119 393,8 256,8 Z',
    },
    circleDashed: {
        width: 512,
        height: 512,
        path: 'M 217.9 10.91 C 177.84 17.083 140.95 32.842 109.64 55.766 L 132.58 78.705 C 157.62 61.229 186.56 48.91 217.9 43.344 L 217.9 10.91 z M 294.09 10.91 L 294.09 43.355 C 325.33 48.924 354.3 61.224 379.41 78.725 L 402.36 55.773 C 371.05 32.849 334.16 17.082 294.09 10.91 z M 55.77 109.64 C 32.851 140.96 17.095 177.84 10.922 217.9 L 43.365 217.9 C 48.935 186.67 61.234 157.71 78.729 132.6 L 55.77 109.64 z M 456.24 109.65 L 433.3 132.58 C 450.77 157.62 463.09 186.56 468.66 217.9 L 501.08 217.9 C 494.91 177.84 479.16 140.95 456.24 109.65 z M 10.92 294.09 C 17.096 334.15 32.846 371.05 55.771 402.36 L 78.707 379.43 C 61.228 354.38 48.91 325.43 43.342 294.09 L 10.92 294.09 z M 468.64 294.09 C 463.07 325.33 450.77 354.29 433.27 379.4 L 456.23 402.36 C 479.15 371.04 494.91 334.15 501.08 294.09 L 468.64 294.09 z M 132.6 433.28 L 109.65 456.23 C 140.96 479.15 177.84 494.92 217.9 501.09 L 217.9 468.64 C 186.67 463.07 157.71 450.77 132.6 433.28 z M 379.42 433.29 C 354.38 450.77 325.44 463.09 294.09 468.66 L 294.09 501.09 C 334.15 494.92 371.05 479.16 402.36 456.23 L 379.42 433.29 z',
    },
    shapes: {
        width: 512,
        height: 512,
        path: 'M480 288H320c-17.67 0-32 14.33-32 32v160c0 17.67 14.33 32 32 32h160c17.67 0 32-14.33 32-32V320c0-17.67-14.33-32-32-32zm0 192H320V320h160v160zM128 256C57.31 256 0 313.31 0 384s57.31 128 128 128 128-57.31 128-128-57.31-128-128-128zm0 224c-52.93 0-96-43.07-96-96 0-52.94 43.07-96 96-96 52.94 0 96 43.06 96 96 0 52.93-43.06 96-96 96zm378.98-278.86L400.07 18.29C392.95 6.1 380.47 0 368 0s-24.95 6.1-32.07 18.29L229.02 201.14c-14.26 24.38 3.56 54.86 32.07 54.86h213.82c28.51 0 46.33-30.48 32.07-54.86zm-27.6 20.39c-.94 1.64-2.45 2.47-4.47 2.47H261.09c-2.02 0-3.53-.83-4.47-2.47-1.21-2.12-.35-3.6.02-4.23L363.55 34.44c.95-1.62 2.44-2.44 4.45-2.44s3.5.82 4.45 2.44L479.36 217.3c.37.63 1.24 2.11.02 4.23z',
    },
    image: {
        width: 512,
        height: 512,
        path: 'M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm16 336c0 8.822-7.178 16-16 16H48c-8.822 0-16-7.178-16-16V112c0-8.822 7.178-16 16-16h416c8.822 0 16 7.178 16 16v288zM112 232c30.928 0 56-25.072 56-56s-25.072-56-56-56-56 25.072-56 56 25.072 56 56 56zm0-80c13.234 0 24 10.766 24 24s-10.766 24-24 24-24-10.766-24-24 10.766-24 24-24zm207.029 23.029L224 270.059l-31.029-31.029c-9.373-9.373-24.569-9.373-33.941 0l-88 88A23.998 23.998 0 0 0 64 344v28c0 6.627 5.373 12 12 12h360c6.627 0 12-5.373 12-12v-92c0-6.365-2.529-12.47-7.029-16.971l-88-88c-9.373-9.372-24.569-9.372-33.942 0zM416 352H96v-4.686l80-80 48 48 112-112 80 80V352z',
    },
    pageLayoutMode0: {
        width: 800,
        height: 512,
        path: 'M 287.48 56 C 266.77 56.079 249.97 72.872 249.97 93.57 L 249.97 418.51 C 249.97 439.21 266.77 456 287.48 456 L 512.52 456 C 533.23 456 550.03 439.21 550.03 418.51 L 550.03 159.1 C 550.03 149.18 546.04 139.58 539.01 132.55 L 473.45 67.016 C 466.42 59.984 456.88 56 446.96 56 L 287.48 56 z M 287.48 81.072 L 425 81.072 L 425 162.31 C 425 172.7 433.36 181.05 443.76 181.05 L 525.03 181.05 L 525.03 418.51 L 525.02 418.51 C 525.02 425.38 519.39 431.01 512.52 431.01 L 287.48 431.01 C 280.6 431.01 274.97 425.38 274.97 418.51 L 274.97 93.57 C 274.97 86.697 280.6 81.072 287.48 81.072 z M 450.01 81.465 C 452.2 82.012 454.15 83.104 455.79 84.744 L 521.35 150.28 C 522.99 151.92 524.09 153.87 524.63 156.06 L 450.01 156.06 L 450.01 81.465 z',
    },
    pageLayoutMode1: {
        width: 800,
        height: 512,
        path: 'M 249.97 -7.6191 L 249.97 162.51 C 249.97 183.21 266.77 200 287.48 200 L 512.52 200 C 533.23 200 550.03 183.21 550.03 162.51 L 550.03 -7.6191 L 525.03 -7.6191 L 525.03 162.51 L 525.02 162.51 C 525.02 169.38 519.4 175.01 512.52 175.01 L 287.48 175.01 C 280.6 175.01 274.98 169.38 274.98 162.51 L 274.98 -7.6191 L 249.97 -7.6191 z M 287.48 312 C 266.77 312.08 249.97 328.87 249.97 349.57 L 249.97 523.16 L 274.98 523.16 L 274.98 349.57 C 274.98 342.7 280.6 337.07 287.48 337.07 L 425.01 337.07 L 425.01 418.31 C 425.01 428.7 433.36 437.05 443.76 437.05 L 525.03 437.05 L 525.03 523.16 L 550.03 523.16 L 550.03 415.1 C 550.03 405.18 546.04 395.58 539.01 388.55 L 473.45 323.01 C 466.42 315.98 456.88 312 446.96 312 L 287.48 312 z M 450.01 337.46 C 452.2 338.01 454.15 339.1 455.79 340.74 L 521.35 406.28 C 522.99 407.92 524.09 409.87 524.63 412.06 L 450.01 412.06 L 450.01 337.46 z',
    },
    pageLayoutMode2: {
        width: 800,
        height: 512,
        path: 'M 49.971 0.5293 L 49.971 162.51 C 49.971 183.21 66.771 200 87.479 200 L 312.52 200 C 333.23 200 350.03 183.21 350.03 162.51 L 350.03 0.5293 L 325.02 0.5293 L 325.02 162.51 C 325.02 169.38 319.39 175.01 312.52 175.01 L 87.479 175.01 C 80.602 175.01 74.975 169.38 74.975 162.51 L 74.975 0.5293 L 49.971 0.5293 z M 449.97 0.53906 L 449.97 162.51 C 449.97 183.21 466.77 200 487.48 200 L 712.52 200 C 733.23 200 750.03 183.21 750.03 162.51 L 750.03 0.53906 L 725.03 0.53906 L 725.03 162.51 L 725.02 162.51 C 725.02 169.38 719.39 175.01 712.52 175.01 L 487.48 175.01 C 480.6 175.01 474.97 169.38 474.97 162.51 L 474.97 0.53906 L 449.97 0.53906 z M 87.479 312 C 66.772 312.08 49.971 328.87 49.971 349.57 L 49.971 511.69 L 74.975 511.69 L 74.975 349.57 C 74.975 342.7 80.602 337.07 87.479 337.07 L 225 337.07 L 225 418.31 C 225 428.7 233.36 437.05 243.76 437.05 L 325.02 437.05 L 325.02 511.69 L 350.03 511.69 L 350.03 415.1 C 350.03 405.18 346.04 395.58 339.01 388.55 L 273.45 323.01 C 266.42 315.98 256.88 312 246.96 312 L 87.479 312 z M 487.48 312 C 466.77 312.08 449.97 328.87 449.97 349.57 L 449.97 511.67 L 474.97 511.67 L 474.97 349.57 C 474.97 342.7 480.6 337.07 487.48 337.07 L 625 337.07 L 625 418.31 C 625 428.7 633.36 437.05 643.76 437.05 L 725.03 437.05 L 725.03 511.67 L 750.03 511.67 L 750.03 415.1 C 750.03 405.18 746.04 395.58 739.01 388.55 L 673.45 323.01 C 666.42 315.98 656.88 312 646.96 312 L 487.48 312 z M 250.01 337.46 C 252.2 338.01 254.15 339.1 255.79 340.74 L 321.35 406.28 C 322.99 407.92 324.09 409.87 324.63 412.06 L 250.01 412.06 L 250.01 337.46 z M 650.01 337.46 C 652.2 338.01 654.15 339.1 655.79 340.74 L 721.35 406.28 C 722.99 407.92 724.09 409.87 724.63 412.06 L 650.01 412.06 L 650.01 337.46 z',
    },
    pageLayoutMode3: {
        width: 800,
        height: 512,
        path: 'M 449.97 0.48047 L 449.97 162.51 C 449.97 183.21 466.77 200 487.48 200 L 712.52 200 C 733.23 200 750.03 183.21 750.03 162.51 L 750.03 0.48047 L 725.03 0.48047 L 725.03 162.51 L 725.02 162.51 C 725.02 169.38 719.39 175.01 712.52 175.01 L 487.48 175.01 C 480.6 175.01 474.97 169.38 474.97 162.51 L 474.97 0.48047 L 449.97 0.48047 z M 87.479 312 C 66.772 312.08 49.971 328.87 49.971 349.57 L 49.971 511.89 L 74.975 511.89 L 74.975 349.57 C 74.975 342.7 80.602 337.07 87.479 337.07 L 225 337.07 L 225 418.31 C 225 428.7 233.36 437.05 243.76 437.05 L 325.02 437.05 L 325.02 511.89 L 350.03 511.89 L 350.03 415.1 C 350.03 405.18 346.04 395.58 339.01 388.55 L 273.45 323.01 C 266.42 315.98 256.88 312 246.96 312 L 87.479 312 z M 487.48 312 C 466.77 312.08 449.97 328.87 449.97 349.57 L 449.97 511.93 L 474.97 511.93 L 474.97 349.57 C 474.97 342.7 480.6 337.07 487.48 337.07 L 625 337.07 L 625 418.31 C 625 428.7 633.36 437.05 643.76 437.05 L 725.03 437.05 L 725.03 511.93 L 750.03 511.93 L 750.03 415.1 C 750.03 405.18 746.04 395.58 739.01 388.55 L 673.45 323.01 C 666.42 315.98 656.88 312 646.96 312 L 487.48 312 z M 250.01 337.46 C 252.2 338.01 254.15 339.1 255.79 340.74 L 321.35 406.28 C 322.99 407.92 324.09 409.87 324.63 412.06 L 250.01 412.06 L 250.01 337.46 z M 650.01 337.46 C 652.2 338.01 654.15 339.1 655.79 340.74 L 721.35 406.28 C 722.99 407.92 724.09 409.87 724.63 412.06 L 650.01 412.06 L 650.01 337.46 z',
    },
    pageLayoutMode4: {
        width: 800,
        height: 512,
        path: 'M 87.479 55.998 C 66.772 56.077 49.971 72.871 49.971 93.57 L 49.971 418.51 C 49.971 439.2 66.771 456 87.479 456 L 312.52 456 C 333.23 456 350.03 439.2 350.03 418.51 L 350.03 159.1 C 350.03 149.18 346.04 139.58 339.01 132.55 L 273.45 67.014 C 266.42 59.983 256.88 55.998 246.96 55.998 L 87.479 55.998 z M 487.48 55.998 C 466.77 56.077 449.97 72.87 449.97 93.568 L 449.97 418.51 C 449.97 439.2 466.77 456 487.48 456 L 712.52 456 C 733.23 456 750.03 439.2 750.03 418.51 L 750.03 159.1 C 750.03 149.18 746.04 139.58 739.01 132.55 L 673.45 67.014 C 666.42 59.983 656.88 55.998 646.96 55.998 L 487.48 55.998 z M 87.479 81.072 L 225 81.072 L 225 162.31 C 225 172.7 233.36 181.05 243.76 181.05 L 325.02 181.05 L 325.02 418.5 C 325.02 425.38 319.39 431.01 312.52 431.01 L 87.479 431.01 C 80.602 431.01 74.975 425.38 74.975 418.51 L 74.975 93.57 C 74.975 86.697 80.602 81.072 87.479 81.072 z M 487.48 81.072 L 625 81.072 L 625 162.31 C 625 172.7 633.36 181.05 643.76 181.05 L 725.03 181.05 L 725.03 418.5 L 725.02 418.5 C 725.02 425.38 719.39 431.01 712.52 431.01 L 487.48 431.01 C 480.6 431.01 474.97 425.38 474.97 418.51 L 474.97 93.57 C 474.97 86.697 480.6 81.072 487.48 81.072 z M 250.01 81.463 C 252.2 82.01 254.15 83.104 255.79 84.744 L 321.35 150.28 C 322.99 151.92 324.09 153.87 324.63 156.06 L 250.01 156.06 L 250.01 81.463 z M 650.01 81.463 C 652.2 82.01 654.15 83.104 655.79 84.744 L 721.35 150.28 C 722.99 151.92 724.09 153.87 724.63 156.06 L 650.01 156.06 L 650.01 81.463 z',
    },
    pageLayoutMode5: {
        width: 800,
        height: 512,
        path: 'M739.01,132.548l-65.561-65.533C666.416,59.983,656.885,56,646.961,56H487.479c-20.707,0.079-37.508,16.872-37.508,37.57 v324.937c0,20.698,16.799,37.494,37.508,37.494h225.043c20.707,0,37.508-16.796,37.508-37.494V159.104 C750.029,149.184,746.041,139.578,739.01,132.548z M650.008,81.464c2.188,0.547,4.143,1.641,5.781,3.281l65.563,65.533 c1.643,1.641,2.734,3.593,3.279,5.779h-74.623V81.464z M725.025,418.505c-0.002,6.878-5.631,12.501-12.506,12.501H487.479 c-6.877,0-12.504-5.623-12.504-12.499V93.57c0-6.873,5.627-12.497,12.504-12.497h137.525v81.233 c0,10.389,8.361,18.745,18.756,18.745h81.266V418.505z',
    },
    closeFile: {
        width: 384,
        height: 512,
        path: 'M369.9,97.9,286,14A48,48,0,0,0,252.1-.1H48A48.16,48.16,0,0,0,0,48V464a48,48,0,0,0,48,48H336a48,48,0,0,0,48-48V131.9A48.23,48.23,0,0,0,369.9,97.9Zm-22.6,22.7a15.73,15.73,0,0,1,4.2,7.4H256V32.5a15.73,15.73,0,0,1,7.4,4.2ZM336,480H48a16,16,0,0,1-16-16V48A16,16,0,0,1,48,32H224V136a23.94,23.94,0,0,0,24,24H352V464A16,16,0,0,1,336,480ZM262.71,369.05l-5.66,5.66a12,12,0,0,1-17,0L192,326.63l-48.08,48.08a12,12,0,0,1-17,0l-5.66-5.66a12,12,0,0,1,0-17L169.37,304l-48.08-48.08a12,12,0,0,1,0-17l5.66-5.66a12,12,0,0,1,17,0L192,281.37l48.08-48.08a12,12,0,0,1,17,0l5.66,5.66a12,12,0,0,1,0,17L214.63,304l48.08,48.08A12,12,0,0,1,262.71,369.05Z',
    },
    bars: {
        width: 448,
        height: 512,
        path: 'M442 114H6a6 6 0 0 1-6-6V84a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6zm0 160H6a6 6 0 0 1-6-6v-24a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6zm0 160H6a6 6 0 0 1-6-6v-24a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6z',
    },
};


/***/ }),

/***/ "./src/common/utils.ts":
/*!*****************************!*\
  !*** ./src/common/utils.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getKeyboardCommands": () => (/* binding */ getKeyboardCommands)
/* harmony export */ });
const getKeyboardCommands = (e, shortcuts, excludeNodeTypes = ['INPUT', 'SELECT', 'TEXTAREA']) => {
    if (!shortcuts || excludeNodeTypes.includes(e.target.nodeName)) {
        return [];
    }
    let cmd = [];
    Object.keys(shortcuts).forEach((sc) => {
        const keybinding = shortcuts[sc];
        if (keybinding) {
            const key = e.key.length > 1 ? e.key : e.key.toLowerCase();
            if (key === keybinding.key &&
                e.altKey === Boolean(keybinding.altKey) &&
                e.ctrlKey === Boolean(keybinding.ctrlKey) &&
                e.shiftKey === Boolean(keybinding.shiftKey)) {
                cmd.push(sc);
            }
        }
    });
    return cmd;
};


/***/ }),

/***/ "./src/custom/history.ts":
/*!*******************************!*\
  !*** ./src/custom/history.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addHistoryEntry": () => (/* binding */ addHistoryEntry)
/* harmony export */ });
/* harmony import */ var _common_Tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Tools */ "./src/common/Tools.ts");

function addHistoryEntry(annotation, type, author, content, subject) {
    let data = {};
    if (annotation.privateData) {
        data = JSON.parse(annotation.privateData);
    }
    else {
        data = {
            'PDF Tools AG': {},
        };
    }
    if (!data.hasOwnProperty('PDF Tools AG')) {
        data['PDF Tools AG'] = {};
    }
    if (!data['PDF Tools AG'].hasOwnProperty('Private')) {
        data['PDF Tools AG'].Private = {};
    }
    if (!data['PDF Tools AG'].Private.hasOwnProperty('History')) {
        data['PDF Tools AG'].Private.History = [];
    }
    data['PDF Tools AG'].Private.LastModified = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_0__.createPdfTime)();
    const historyItem = {
        D: (0,_common_Tools__WEBPACK_IMPORTED_MODULE_0__.createPdfTime)(),
        T: `(${author})`,
    };
    if (type === 'create') {
        historyItem.Type = '/Create';
    }
    else if (type === 'edit') {
        historyItem.Type = '/Edit';
        historyItem.params = [];
        if (content !== null && annotation.content !== content) {
            historyItem.params.push('/Contents');
            historyItem.params.push(`(${content})`);
        }
        if (subject !== null && annotation.subject !== subject) {
            historyItem.params.push('/Subj');
            historyItem.params.push(`(${subject})`);
        }
        if (historyItem.params.length === 0) {
            return;
        }
    }
    else if (type === 'lock') {
        historyItem.Type = '/Lock';
    }
    else if (type === 'unlock') {
        historyItem.Type = '/Unlock';
    }
    else if (type === 'delete') {
        historyItem.Type = '/Delete';
        annotation.popup.isOpen = false;
    }
    if (historyItem) {
        data['PDF Tools AG'].Private.History.push(historyItem);
    }
    annotation.privateData = JSON.stringify(data);
}


/***/ }),

/***/ "./src/modules/CanvasLayer.ts":
/*!************************************!*\
  !*** ./src/modules/CanvasLayer.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasLayer": () => (/* binding */ CanvasLayer)
/* harmony export */ });
/* harmony import */ var _custom_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../custom/history */ "./src/custom/history.ts");

class CanvasLayer {
    constructor(module, name, containerElement, store, pdfApi, pdfViewerCanvas, options) {
        this.canvasContexts = [];
        this.htmlLayers = [];
        this.containerElement = containerElement;
        this.store = store;
        this.pdfApi = pdfApi;
        this.pdfViewerCanvas = pdfViewerCanvas;
        this.options = options;
        this.module = module;
        this.name = name;
        this.remove = this.remove.bind(this);
        this.onAnnotationCreated = this.onAnnotationCreated.bind(this);
    }
    resize(width, height) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width * devicePixelRatio;
        tempCanvas.height = height * devicePixelRatio;
        const tempContext = tempCanvas.getContext('2d');
        this.canvasContexts.forEach((ctx) => {
            tempContext.drawImage(ctx.canvas, 0, 0);
            ctx.canvas.style.width = width + 'px';
            ctx.canvas.style.height = height + 'px';
            ctx.canvas.width = width * devicePixelRatio;
            ctx.canvas.height = height * devicePixelRatio;
            ctx.drawImage(tempContext.canvas, 0, 0);
        });
    }
    remove() {
        this.module.removeCanvasLayer(this.name);
    }
    createHtmlLayer() {
        const element = document.createElement('div');
        this.htmlLayers.push(element);
        if (this.containerElement) {
            this.containerElement.appendChild(element);
        }
        return element;
    }
    createCanvas() {
        const element = document.createElement('canvas');
        element.style.position = 'absolute';
        element.style.top = '0';
        element.style.left = '0';
        element.style.right = '0';
        element.style.bottom = '0';
        const context = element.getContext('2d');
        this.canvasContexts.push(context);
        if (this.containerElement) {
            this.containerElement.appendChild(element);
            const rect = this.containerElement.getBoundingClientRect();
            context.canvas.width = rect.width * devicePixelRatio;
            context.canvas.height = rect.height * devicePixelRatio;
            context.canvas.style.width = rect.width + 'px';
            context.canvas.style.height = rect.height + 'px';
        }
        return context;
    }
    removeHtmlElements() {
        if (this.containerElement) {
            for (let i = 0; i < this.htmlLayers.length; i++) {
                this.containerElement.removeChild(this.htmlLayers[i]);
            }
            this.htmlLayers = [];
        }
    }
    removeCanvasElements() {
        if (this.containerElement) {
            for (let i = 0; i < this.canvasContexts.length; i++) {
                this.containerElement.removeChild(this.canvasContexts[i].canvas);
            }
            this.canvasContexts = [];
        }
    }
    onAnnotationCreated(annotation) {
        if (this.options.annotation.trackHistory) {
            (0,_custom_history__WEBPACK_IMPORTED_MODULE_0__.addHistoryEntry)(annotation, 'create', this.options.viewer.general.user);
            return this.pdfApi.updateItem(annotation);
        }
        return new Promise((resolve) => resolve(annotation));
    }
}


/***/ }),

/***/ "./src/modules/CanvasModule.ts":
/*!*************************************!*\
  !*** ./src/modules/CanvasModule.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasModule": () => (/* binding */ CanvasModule),
/* harmony export */   "CanvasModuleType": () => (/* binding */ CanvasModuleType)
/* harmony export */ });
var CanvasModuleType;
(function (CanvasModuleType) {
    CanvasModuleType[CanvasModuleType["Tool"] = 0] = "Tool";
    CanvasModuleType[CanvasModuleType["Layer"] = 1] = "Layer";
})(CanvasModuleType || (CanvasModuleType = {}));
class CanvasModule {
    constructor() {
        this.canvasLayers = {};
        this.store = null;
        this.pdfApi = null;
        this.pdfViewerCanvas = null;
        this.options = null;
        this.name = null;
        this.containerElement = null;
        this.createCanvasLayer = this.createCanvasLayer.bind(this);
        this.removeCanvasLayer = this.removeCanvasLayer.bind(this);
    }
    register(containerElement, store, pdfApi, pdfViewerCanvas, options) {
        this.containerElement = containerElement;
        this.store = store;
        this.pdfApi = pdfApi;
        this.pdfViewerCanvas = pdfViewerCanvas;
        this.options = options;
        return this.onRegister();
    }
    render(timestamp, state) {
        const keys = Object.keys(this.canvasLayers);
        for (let i = 0; i < keys.length; i++) {
            this.canvasLayers[keys[i]].render(timestamp, state);
        }
    }
    deactivate() {
        const keys = Object.keys(this.canvasLayers);
        for (let i = 0; i < keys.length; i++) {
            const name = keys[i];
            this.canvasLayers[name].onRemove();
            delete this.canvasLayers[name];
        }
    }
    resize(width, height) {
        const keys = Object.keys(this.canvasLayers);
        for (let i = 0; i < keys.length; i++) {
            this.canvasLayers[keys[i]].resize(width, height);
        }
    }
    getCanvasSize() {
        const rect = {
            width: 0,
            height: 0,
        };
        if (this.containerElement !== null) {
            const clientRect = this.containerElement.getBoundingClientRect();
            rect.width = clientRect.width;
            rect.height = clientRect.height;
        }
        return rect;
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            const keys = Object.keys(this.canvasLayers);
            const promises = [];
            for (let i = 0; i < keys.length; i++) {
                promises.push(this.canvasLayers[keys[i]].onSave());
            }
            Promise.all(promises)
                .then(() => {
                resolve();
            })
                .catch((error) => {
                reject('OnSave failed on a canvas layer: ' + error);
            });
        });
        return promise;
    }
    createCanvasLayer(name, canvasLayer, args) {
        if (this.containerElement &&
            this.store &&
            this.pdfApi &&
            this.pdfViewerCanvas &&
            this.options) {
            if (this.canvasLayers[name]) {
                throw new Error('duplicate canvas layer name');
            }
            const layer = new canvasLayer(this, name, this.containerElement, this.store, this.pdfApi, this.pdfViewerCanvas, this.options);
            this.canvasLayers[name] = layer;
            layer.onCreate(args);
        }
        else {
            throw new Error('canvas layer is not registered');
        }
    }
    removeCanvasLayer(name) {
        if (this.canvasLayers[name]) {
            this.canvasLayers[name].onRemove();
            delete this.canvasLayers[name];
        }
    }
}


/***/ }),

/***/ "./src/modules/eraser/EraserLayer.ts":
/*!*******************************************!*\
  !*** ./src/modules/eraser/EraserLayer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EraserLayer": () => (/* binding */ EraserLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api/ */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _EraserToolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EraserToolbar */ "./src/modules/eraser/EraserToolbar.tsx");




const moduleLayerName = 'EraserTool';
class EraserLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.context = null;
        this.eraserRadius = this.options.annotation.eraserRadius;
    }
    onCreate(args) {
        this.setEraserRadius = this.setEraserRadius.bind(this);
        this.remove = this.remove.bind(this);
        this.context = this.createCanvas();
        const toolbarElement = this.module.toolbarElement;
        (0,_EraserToolbar__WEBPACK_IMPORTED_MODULE_3__.createEraserToolbar)({
            radius: this.eraserRadius,
            onRadiusChanged: this.setEraserRadius,
            onCancel: this.remove,
        }, toolbarElement);
        this.store.viewer.beginModule(moduleLayerName);
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.endModule(moduleLayerName);
    }
    onSave() {
        return new Promise((resolve) => {
            return resolve();
        });
    }
    render(timestamp, state) {
        var _a;
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        const pointerPos = {
            x: state.pointer.x.devicePixels,
            y: state.pointer.y.devicePixels,
        };
        const pointerPdfPos = this.pdfApi.transformScreenPointToPdfPoint(pointerPos);
        const cursorStyle = pointerPdfPos.isOnPage ? _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.NONE : _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.NOT_ALLOWED;
        this.store.viewer.setCursorStyle(cursorStyle);
        const ctx = this.context;
        if (ctx) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            if (pointerPdfPos.isOnPage) {
                ctx.save();
                ctx.lineWidth = 1;
                if (this.eraserRadius >= 8) {
                    ctx.setLineDash([4 * devicePixelRatio, 4 * devicePixelRatio]);
                }
                ctx.beginPath();
                ctx.arc(pointerPos.x, pointerPos.y, (this.eraserRadius * devicePixelRatio) / 2, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
            }
        }
        if (!pointerPdfPos.isOnPage || state.pointer.action !== 'click') {
            return;
        }
        const inkAnnotations = (_a = this.pdfApi
            .getAnnotationsOnPoint(pointerPos)) === null || _a === void 0 ? void 0 : _a.filter((a) => a.itemType === _pdf_viewer_api___WEBPACK_IMPORTED_MODULE_1__.PdfItemType.INK);
        if (!inkAnnotations) {
            return;
        }
        const annot = this.deleteFirstInkLineCloseToPoint(inkAnnotations, pointerPdfPos.pdfPoint);
        if (annot) {
            this.updateInkAnnotation(annot);
        }
    }
    setEraserRadius(radius) {
        this.options.annotation.eraserRadius = radius;
        this.eraserRadius = radius;
    }
    deleteFirstInkLineCloseToPoint(inkAnnotations, pdfPoint) {
        if (!this.context) {
            return null;
        }
        const ctx = this.context;
        ctx.save();
        for (let inkAnnotation of inkAnnotations) {
            ctx.lineWidth = Math.max(inkAnnotation.border.width, this.eraserRadius * devicePixelRatio);
            ctx.lineCap = 'round';
            for (let inkLine of inkAnnotation.inkList) {
                const path = new Path2D();
                let isFirstPoint = true;
                for (let point of inkLine) {
                    if (isFirstPoint) {
                        path.moveTo(point.x, point.y);
                        isFirstPoint = false;
                    }
                    else {
                        path.lineTo(point.x, point.y);
                    }
                }
                const isPointInStroke = ctx.isPointInStroke(path, pdfPoint.pdfX, pdfPoint.pdfY);
                if (isPointInStroke) {
                    inkAnnotation.inkList.splice(inkAnnotation.inkList.indexOf(inkLine), 1);
                    return inkAnnotation;
                }
            }
        }
        ctx.restore();
        return null;
    }
    updateInkAnnotation(inkAnnotation) {
        return new Promise((resolve, reject) => {
            if (inkAnnotation.inkList.length) {
                this.pdfApi
                    .updateItem(inkAnnotation)
                    .then((item) => {
                    this.store.annotations.updateAnnotation(item);
                    resolve();
                })
                    .catch((err) => {
                    console.error(err);
                    reject();
                });
            }
            else {
                const id = inkAnnotation.id;
                this.pdfApi
                    .deleteItem(inkAnnotation)
                    .then(() => {
                    resolve();
                })
                    .catch((err) => {
                    console.error(err);
                    reject();
                });
            }
        });
    }
}


/***/ }),

/***/ "./src/modules/eraser/EraserModule.ts":
/*!********************************************!*\
  !*** ./src/modules/eraser/EraserModule.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EraserModule": () => (/* binding */ EraserModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _EraserLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EraserLayer */ "./src/modules/eraser/EraserLayer.ts");


class EraserModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.toolbarElement = null;
        this.name = EraserModule.moduleInfo.name;
        this.activate = this.activate.bind(this);
    }
    onRegister() {
        this.toolbarElement = document.createElement('div');
        return {
            toolbar: this.toolbarElement,
        };
    }
    activate() {
        if (!this.canvasLayers['add']) {
            this.createCanvasLayer('add', _EraserLayer__WEBPACK_IMPORTED_MODULE_1__.EraserLayer);
        }
        else {
            this.removeCanvasLayer('add');
        }
    }
}
EraserModule.moduleInfo = {
    name: 'EraserModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Tool,
    requiredFeatures: {
        annotate: true,
        fillFormFields: false,
    },
    translationKey: 'eraser.begin',
    icon: 'eraser',
};


/***/ }),

/***/ "./src/modules/eraser/EraserToolbar.tsx":
/*!**********************************************!*\
  !*** ./src/modules/eraser/EraserToolbar.tsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEraserToolbar": () => (/* binding */ createEraserToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_RangeSlider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/RangeSlider */ "./src/common/RangeSlider.tsx");








const createEraserToolbar = (props, element) => {
    const state = {
        radius: props.radius,
    };
    const actions = {
        setRadius: (radius) => ($state) => {
            props.onRadiusChanged(radius);
            return Object.assign(Object.assign({}, $state), { radius });
        },
        setCancel: () => ($state) => {
            return Object.assign({}, $state);
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(EraserToolbar, null);
    const EraserToolbar = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_RangeSlider__WEBPACK_IMPORTED_MODULE_7__.RangeSlider, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('eraser.eraserWidth'), min: 2, max: 50, step: 1, value: $state.radius, text: `${$state.radius}px`, icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.circleDashed, onChange: $actions.setRadius, className: "pwv-opacityslider" })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.close, onClick: props.onCancel }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/form-fields/CheckBoxWidget.ts":
/*!***************************************************!*\
  !*** ./src/modules/form-fields/CheckBoxWidget.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CheckBoxWidget": () => (/* binding */ CheckBoxWidget)
/* harmony export */ });
/* harmony import */ var _WidgetBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WidgetBase */ "./src/modules/form-fields/WidgetBase.ts");

class CheckBoxWidget extends _WidgetBase__WEBPACK_IMPORTED_MODULE_0__.WidgetBase {
    createFormField() {
        const formField = document.createElement('label');
        formField.classList.add('pwv-formField__CheckBox');
        formField.style.overflow = 'hidden';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = this.widget.selected;
        checkbox.style.position = 'absolute';
        checkbox.style.top = '-20px';
        checkbox.style.left = '-20px';
        formField.appendChild(checkbox);
        this.handleOnChange = this.handleOnChange.bind(this);
        this.handleOnKeyDown = this.handleOnKeyDown.bind(this);
        this.handleOnBlur = this.handleOnBlur.bind(this);
        formField.addEventListener('change', this.handleOnChange);
        formField.addEventListener('keydown', this.handleOnKeyDown);
        formField.addEventListener('blur', this.handleOnBlur);
        return formField;
    }
    onRemove() {
        this.editorElement.removeEventListener('change', this.handleOnChange);
        this.editorElement.removeEventListener('keydown', this.handleOnKeyDown);
        this.editorElement.removeEventListener('blur', this.handleOnBlur);
    }
    setFocus() {
        this.editorElement.focus();
    }
    handleOnKeyDown(e) {
        if (e.code === 'Tab') {
            this.onTab(e.shiftKey);
        }
        else if (e.code === 'Escape') {
            this.onBlur();
        }
    }
    handleOnBlur(e) {
        this.onBlur();
    }
    handleOnChange(e) {
        this.widget.push();
        this.saveWidget();
    }
}


/***/ }),

/***/ "./src/modules/form-fields/ComboBoxWidget.ts":
/*!***************************************************!*\
  !*** ./src/modules/form-fields/ComboBoxWidget.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComboBoxWidget": () => (/* binding */ ComboBoxWidget)
/* harmony export */ });
/* harmony import */ var _WidgetBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WidgetBase */ "./src/modules/form-fields/WidgetBase.ts");

class ComboBoxWidget extends _WidgetBase__WEBPACK_IMPORTED_MODULE_0__.WidgetBase {
    constructor() {
        super(...arguments);
        this.btnClearPressed = false;
        this.hasPendingChanges = false;
        this.saveThrottlingTimer = undefined;
    }
    createFormField() {
        this.inputOnFocus = this.inputOnFocus.bind(this);
        this.inputOnBlur = this.inputOnBlur.bind(this);
        this.inputOnInput = this.inputOnInput.bind(this);
        this.inputOnChange = this.inputOnChange.bind(this);
        this.inputOnKeyDown = this.inputOnKeyDown.bind(this);
        this.btnOnClick = this.btnOnClick.bind(this);
        this.btnOnMouseDown = this.btnOnMouseDown.bind(this);
        this.btnOnMouseUp = this.btnOnMouseUp.bind(this);
        const formField = document.createElement('div');
        formField.classList.add('pwv-formField__ComboBox');
        this.dataList = document.createElement('datalist');
        this.dataList.id = Math.random().toString(36).substring(2, 8);
        for (let i = 0; i < this.widget.options.size; i++) {
            const value = this.widget.options.get(i);
            const item = document.createElement('option');
            item.value = value;
            item.textContent = value;
            this.dataList.appendChild(item);
        }
        this.input = document.createElement('input');
        this.input.setAttribute('list', this.dataList.id);
        this.input.style.border = 'none';
        this.input.style.boxSizing = 'border-box';
        this.input.style.width = '100%';
        this.input.style.maxWidth = '100%';
        this.input.value =
            this.widget.chosen !== null
                ? this.widget.options.get(this.widget.chosen)
                : this.widget.customEntry;
        this.input.addEventListener('focus', this.inputOnFocus);
        this.input.addEventListener('blur', this.inputOnBlur);
        this.input.addEventListener('input', this.inputOnInput);
        this.input.addEventListener('change', this.inputOnChange);
        this.input.addEventListener('keydown', this.inputOnKeyDown);
        this.btnClear = document.createElement('button');
        this.btnClear.tabIndex = -1;
        const icon = document.createElement('span');
        icon.classList.add('pwv-icon');
        const iconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        iconSvg.setAttribute('viewBox', '0 0 320 512');
        const iconPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        iconPath.setAttribute('d', 'M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z');
        iconPath.setAttribute('stroke-width', '1px');
        iconPath.setAttribute('shape-rendering', 'optimizeQuality');
        iconSvg.appendChild(iconPath);
        icon.appendChild(iconSvg);
        this.btnClear.appendChild(icon);
        this.btnClear.addEventListener('mousedown', this.btnOnMouseDown);
        this.btnClear.addEventListener('mouseup', this.btnOnMouseUp);
        this.btnClear.addEventListener('mouseleave', this.btnOnMouseUp);
        this.btnClear.addEventListener('click', this.btnOnClick);
        formField.appendChild(this.input);
        formField.appendChild(this.dataList);
        formField.appendChild(this.btnClear);
        return formField;
    }
    onRemove() {
        if (this.saveThrottlingTimer) {
            window.clearTimeout(this.saveThrottlingTimer);
        }
        if (this.hasPendingChanges) {
            this.saveWidget();
        }
        this.input.removeEventListener('focus', this.inputOnFocus);
        this.input.removeEventListener('blur', this.inputOnBlur);
        this.input.removeEventListener('input', this.inputOnInput);
        this.input.removeEventListener('change', this.inputOnChange);
        this.input.removeEventListener('keydown', this.inputOnKeyDown);
        this.btnClear.removeEventListener('mousedown', this.btnOnMouseDown);
        this.btnClear.removeEventListener('mouseup', this.btnOnMouseUp);
        this.btnClear.removeEventListener('mouseleave', this.btnOnMouseUp);
        this.btnClear.removeEventListener('click', this.btnOnClick);
    }
    setFocus() {
        this.input.focus();
    }
    updateBtnVisibility() {
        if (this.btnClear) {
            this.btnClear.style.display = this.input.value === '' ? 'none' : 'flex';
        }
    }
    updateWidget() {
        const { value, list } = this.input;
        const options = list.options;
        const chosen = [...options].findIndex((i) => i.value === value);
        if (chosen >= 0) {
            this.widget.chosen = chosen;
        }
        else {
            this.widget.customEntry = value;
        }
        if (this.saveThrottlingTimer) {
            window.clearTimeout(this.saveThrottlingTimer);
        }
        this.saveThrottlingTimer = window.setTimeout(() => {
            this.saveWidget();
            this.hasPendingChanges = false;
        }, 500);
    }
    inputOnFocus(e) {
        this.updateBtnVisibility();
    }
    inputOnBlur(e) {
        if (!this.btnClearPressed) {
            this.saveWidget();
            this.hasPendingChanges = false;
            this.onBlur();
        }
    }
    inputOnInput(e) {
        this.updateBtnVisibility();
        this.updateWidget();
    }
    inputOnChange(e) {
        this.updateBtnVisibility();
    }
    inputOnKeyDown(e) {
        if (e.code === 'Tab') {
            this.onTab(e.shiftKey);
        }
        else if (e.code === 'Escape') {
            this.input.blur();
        }
    }
    btnOnClick(e) {
        this.input.value = '';
        this.updateWidget();
        this.updateBtnVisibility();
        this.input.focus();
    }
    btnOnMouseDown(e) {
        this.btnClearPressed = true;
    }
    btnOnMouseUp(e) {
        this.input.focus();
        this.btnClearPressed = false;
    }
}


/***/ }),

/***/ "./src/modules/form-fields/EditFormFieldLayer.ts":
/*!*******************************************************!*\
  !*** ./src/modules/form-fields/EditFormFieldLayer.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditFormFieldLayer": () => (/* binding */ EditFormFieldLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _CheckBoxWidget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CheckBoxWidget */ "./src/modules/form-fields/CheckBoxWidget.ts");
/* harmony import */ var _ComboBoxWidget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComboBoxWidget */ "./src/modules/form-fields/ComboBoxWidget.ts");
/* harmony import */ var _SelectListWidget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SelectListWidget */ "./src/modules/form-fields/SelectListWidget.ts");
/* harmony import */ var _ListBoxWidget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ListBoxWidget */ "./src/modules/form-fields/ListBoxWidget.ts");
/* harmony import */ var _RadioButtonWidget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RadioButtonWidget */ "./src/modules/form-fields/RadioButtonWidget.ts");
/* harmony import */ var _TextBoxWidget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TextBoxWidget */ "./src/modules/form-fields/TextBoxWidget.ts");








const moduleLayerName = 'EditFormField';
const stopPropagation = (e) => {
    e.stopPropagation();
};
class EditFormFieldLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.widgetAnnotation = null;
        this.formFieldElement = null;
        this.hasFocus = false;
        this.widgetEditor = null;
    }
    onCreate(args) {
        const { annotationId, action } = args;
        this.store.viewer.beginModule(moduleLayerName);
        this.widgetAnnotation = this.pdfApi.getItem(annotationId);
        this.selectNextFormField = this.selectNextFormField.bind(this);
        this.blur = this.blur.bind(this);
        this.formFieldElement = this.createHtmlLayer();
        this.formFieldElement.classList.add('pwv-formField');
        this.formFieldElement.addEventListener('mousedown', stopPropagation, false);
        this.formFieldElement.addEventListener('mousemove', stopPropagation, false);
        this.formFieldElement.addEventListener('mouseup', stopPropagation, false);
        this.formFieldElement.addEventListener('touchstart', stopPropagation, { passive: false });
        this.formFieldElement.addEventListener('touchmove', stopPropagation, { passive: true });
        this.formFieldElement.addEventListener('touchend', stopPropagation, { passive: true });
        this.updateFormFieldElementPosition();
        const widget = this.widgetAnnotation.widget;
        const widgetType = this.widgetAnnotation.widgetType;
        if (action === 'click' &&
            (widgetType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.WidgetType.CHECK_BOX || widgetType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.WidgetType.RADIO_BUTTON)) {
            widget.push();
            this.widgetAnnotation.pdfDocument.editAnnotation(widget);
        }
        const bb = widget.boundingBox;
        const paddingX = 4;
        const paddingY = 6;
        this.pdfApi.goToRectangle({
            page: bb.pageNumber,
            pdfX: bb.x - paddingX,
            pdfY: bb.y - paddingY,
            pdfW: bb.width + 2 * paddingX,
            pdfH: bb.height + 2 * paddingY,
        });
        const options = {
            widget: widget,
            widgetType: widgetType,
            pdfDocument: this.widgetAnnotation.pdfDocument,
            onTab: (shiftKey) => {
                this.selectNextFormField(shiftKey);
            },
            onBlur: () => {
                if (this.hasFocus) {
                    this.blur();
                }
            },
        };
        switch (options.widgetType) {
            case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.WidgetType.CHECK_BOX:
                this.widgetEditor = new _CheckBoxWidget__WEBPACK_IMPORTED_MODULE_2__.CheckBoxWidget(this.formFieldElement, options);
                break;
            case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.WidgetType.RADIO_BUTTON:
                this.widgetEditor = new _RadioButtonWidget__WEBPACK_IMPORTED_MODULE_6__.RadioButtonWidget(this.formFieldElement, options);
                break;
            case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.WidgetType.TEXT_BOX:
                this.widgetEditor = new _TextBoxWidget__WEBPACK_IMPORTED_MODULE_7__.TextBoxWidget(this.formFieldElement, options);
                break;
            case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.WidgetType.COMBO_BOX:
                {
                    if (widget.customEntryAllowed) {
                        this.widgetEditor = new _ComboBoxWidget__WEBPACK_IMPORTED_MODULE_3__.ComboBoxWidget(this.formFieldElement, options);
                    }
                    else {
                        this.widgetEditor = new _SelectListWidget__WEBPACK_IMPORTED_MODULE_4__.SelectListWidget(this.formFieldElement, options);
                    }
                }
                break;
            case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.WidgetType.LIST_BOX:
                this.widgetEditor = new _ListBoxWidget__WEBPACK_IMPORTED_MODULE_5__.ListBoxWidget(this.formFieldElement, options);
                break;
        }
        this.hasFocus = true;
    }
    cancel() {
        this.remove();
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            resolve();
        });
        return promise;
    }
    close() {
        this.remove();
    }
    onRemove() {
        var _a;
        this.hasFocus = false;
        (_a = this.widgetEditor) === null || _a === void 0 ? void 0 : _a.onRemove();
        this.removeHtmlElements();
        this.formFieldElement = null;
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        var _a;
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (this.formFieldElement) {
            if (state.canvas.canvasInvalidated || state.viewer.modeChanged) {
                this.updateFormFieldElementPosition();
            }
            if (state.pointer.action === 'click') {
                const pointerCssPos = {
                    x: state.pointer.x.cssPixels,
                    y: state.pointer.y.cssPixels,
                };
                const insideHorizontal = pointerCssPos.x > this.formFieldElement.offsetLeft &&
                    pointerCssPos.x < this.formFieldElement.offsetLeft + this.formFieldElement.offsetWidth;
                const insideVertical = pointerCssPos.y > this.formFieldElement.offsetTop &&
                    pointerCssPos.y < this.formFieldElement.offsetTop + this.formFieldElement.offsetHeight;
                if (!insideHorizontal || !insideVertical) {
                    this.blur();
                    const annotationsOnPoint = this.pdfApi.getAnnotationsOnPoint({
                        x: state.pointer.x.devicePixels,
                        y: state.pointer.y.devicePixels,
                    });
                    if (annotationsOnPoint && annotationsOnPoint.length) {
                        for (let i = 0; i < annotationsOnPoint.length; i++) {
                            const annotationOnPoint = annotationsOnPoint[i];
                            if (annotationOnPoint.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.WIDGET &&
                                !annotationOnPoint.widget.readOnly) {
                                this.pdfViewerCanvas.activateModule('FormFieldModule', {
                                    annotationId: annotationOnPoint.id,
                                    action: 'click',
                                });
                            }
                        }
                    }
                    return;
                }
            }
        }
        if (state.document.zoomChanged || state.viewer.modeChanged) {
            (_a = this.widgetEditor) === null || _a === void 0 ? void 0 : _a.setZoom(state.document.zoom);
        }
    }
    updateFormFieldElementPosition() {
        if (this.widgetAnnotation && this.formFieldElement) {
            const screenRect = this.pdfApi.transformPdfPageRectToScreenRect(this.widgetAnnotation.pdfRect);
            this.formFieldElement.style.left = `${screenRect.x / devicePixelRatio - 2}px`;
            this.formFieldElement.style.top = `${screenRect.y / devicePixelRatio - 2}px`;
            this.formFieldElement.style.width = `${screenRect.w / devicePixelRatio + 1}px`;
            this.formFieldElement.style.height = `${screenRect.h / devicePixelRatio + 1}px`;
        }
    }
    selectNextFormField(reverse) {
        if (this.widgetAnnotation) {
            const { annotations, document } = this.store.getState();
            const pageCount = this.pdfApi.getPageCount();
            const getNextFormFieldOnPage = (pageNumber, index) => {
                const list = annotations.byPage[pageNumber];
                for (let i = index; i < list.length; i++) {
                    const annotId = list[i];
                    const annotation = annotations.all[annotId];
                    if (annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.WIDGET &&
                        !annotation.widget.readOnly) {
                        return annotation;
                    }
                }
                if (pageCount === 1 && index === 0) {
                    return null;
                }
                const nextPage = pageCount > pageNumber ? pageNumber + 1 : 1;
                return getNextFormFieldOnPage(nextPage, 0);
            };
            const getPreviewsFormFieldOnPage = (pageNumber, index) => {
                const list = annotations.byPage[pageNumber];
                const start = index < 0 ? list.length - 1 : index;
                for (let i = start; i >= 0; i--) {
                    const annotId = list[i];
                    const annotation = annotations.all[annotId];
                    if (annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.WIDGET &&
                        !annotation.widget.readOnly) {
                        return annotation;
                    }
                }
                if (pageNumber === 1) {
                    return null;
                }
                return getPreviewsFormFieldOnPage(pageNumber - 1, -1);
            };
            const currentWidgetIndex = annotations.byPage[this.widgetAnnotation.page].findIndex((a) => { var _a; return a === ((_a = this.widgetAnnotation) === null || _a === void 0 ? void 0 : _a.id); });
            let currentPage = this.widgetAnnotation.page;
            let nextFormField = null;
            if (reverse) {
                if (currentWidgetIndex === 0) {
                    if (currentPage === 1) {
                        nextFormField = this.widgetAnnotation;
                    }
                    else {
                        nextFormField = getPreviewsFormFieldOnPage(this.widgetAnnotation.page - 1, -1);
                    }
                }
                else {
                    nextFormField = getPreviewsFormFieldOnPage(this.widgetAnnotation.page, currentWidgetIndex - 1);
                }
            }
            else {
                nextFormField = getNextFormFieldOnPage(this.widgetAnnotation.page, currentWidgetIndex + 1);
            }
            if (nextFormField) {
                this.blur();
                this.pdfViewerCanvas.activateModule('FormFieldModule', {
                    annotationId: nextFormField.id,
                    action: 'select',
                });
            }
        }
    }
    blur() {
        if (this.hasFocus) {
            this.hasFocus = false;
            this.remove();
        }
    }
}


/***/ }),

/***/ "./src/modules/form-fields/FormFieldModule.ts":
/*!****************************************************!*\
  !*** ./src/modules/form-fields/FormFieldModule.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FormFieldModule": () => (/* binding */ FormFieldModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _EditFormFieldLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditFormFieldLayer */ "./src/modules/form-fields/EditFormFieldLayer.ts");


class FormFieldModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.name = FormFieldModule.moduleInfo.name;
    }
    onRegister() {
        return {};
    }
    activate(args) {
        if (!this.canvasLayers['edit']) {
            this.onEdit(args);
        }
    }
    onEdit(args) {
        this.createCanvasLayer('edit', _EditFormFieldLayer__WEBPACK_IMPORTED_MODULE_1__.EditFormFieldLayer, args);
    }
}
FormFieldModule.moduleInfo = {
    name: 'FormFieldModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Layer,
    requiredFeatures: {
        annotate: false,
        fillFormFields: true,
    },
};


/***/ }),

/***/ "./src/modules/form-fields/ListBoxWidget.ts":
/*!**************************************************!*\
  !*** ./src/modules/form-fields/ListBoxWidget.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ListBoxWidget": () => (/* binding */ ListBoxWidget)
/* harmony export */ });
/* harmony import */ var _WidgetBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WidgetBase */ "./src/modules/form-fields/WidgetBase.ts");

class ListBoxWidget extends _WidgetBase__WEBPACK_IMPORTED_MODULE_0__.WidgetBase {
    createFormField() {
        const formField = document.createElement('select');
        formField.setAttribute('required', 'true');
        if (this.widget.multiSelectAllowed) {
            formField.setAttribute('multiple', 'true');
        }
        else {
            formField.setAttribute('size', `${this.widget.options.size}`);
        }
        formField.classList.add('pwv-formField__ListBox');
        const values = Array.from(this.widget.chosen.values());
        for (let i = 0; i < this.widget.options.size; i++) {
            const value = this.widget.options.get(i);
            const item = document.createElement('option');
            item.value = i.toString();
            item.textContent = value;
            formField.appendChild(item);
            item.selected = values.includes(i);
        }
        this.handleOnChange = this.handleOnChange.bind(this);
        this.handleOnKeyDown = this.handleOnKeyDown.bind(this);
        this.handleOnBlur = this.handleOnBlur.bind(this);
        formField.addEventListener('change', this.handleOnChange);
        formField.addEventListener('keydown', this.handleOnKeyDown);
        formField.addEventListener('blur', this.handleOnBlur);
        formField.addEventListener('wheel', (e) => {
            e.stopPropagation();
        });
        return formField;
    }
    onRemove() {
        this.editorElement.removeEventListener('change', this.handleOnChange);
        this.editorElement.removeEventListener('keydown', this.handleOnKeyDown);
        this.editorElement.removeEventListener('blur', this.handleOnBlur);
    }
    setFocus() {
        this.editorElement.focus();
    }
    handleOnKeyDown(e) {
        if (e.code === 'Tab') {
            this.onTab(e.shiftKey);
        }
        else if (e.code === 'Escape') {
            this.onBlur();
        }
    }
    handleOnBlur(e) {
        this.onBlur();
    }
    handleOnChange(e) {
        let selectedOptions = [];
        if (!e.target.value) {
            const value = Array.from(this.widget.chosen.values()).shift();
            selectedOptions = [value];
            e.target.value = value;
        }
        else {
            selectedOptions = [...e.target.options]
                .filter((o) => o.selected)
                .map((o) => parseInt(o.value));
            if (!this.widget.multiSelectAllowed) {
                const value = selectedOptions[0];
                selectedOptions = [value];
                e.target.value = value;
            }
        }
        this.widget.chosen.clear();
        selectedOptions.forEach((o) => this.widget.chosen.add(o));
        this.saveWidget();
    }
}


/***/ }),

/***/ "./src/modules/form-fields/RadioButtonWidget.ts":
/*!******************************************************!*\
  !*** ./src/modules/form-fields/RadioButtonWidget.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RadioButtonWidget": () => (/* binding */ RadioButtonWidget)
/* harmony export */ });
/* harmony import */ var _WidgetBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WidgetBase */ "./src/modules/form-fields/WidgetBase.ts");

class RadioButtonWidget extends _WidgetBase__WEBPACK_IMPORTED_MODULE_0__.WidgetBase {
    createFormField() {
        const formField = document.createElement('label');
        formField.classList.add('pwv-formField__RadioButton');
        formField.style.overflow = 'hidden';
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.checked = this.widget.selected;
        radio.style.position = 'absolute';
        radio.style.top = '-20px';
        radio.style.left = '-20px';
        formField.appendChild(radio);
        this.handleOnChange = this.handleOnChange.bind(this);
        this.handleOnKeyDown = this.handleOnKeyDown.bind(this);
        this.handleOnBlur = this.handleOnBlur.bind(this);
        formField.addEventListener('change', this.handleOnChange);
        formField.addEventListener('keydown', this.handleOnKeyDown);
        formField.addEventListener('blur', this.handleOnBlur);
        return formField;
    }
    onRemove() {
        this.editorElement.removeEventListener('change', this.handleOnChange);
        this.editorElement.removeEventListener('keydown', this.handleOnKeyDown);
        this.editorElement.removeEventListener('blur', this.handleOnBlur);
    }
    setFocus() {
        this.editorElement.focus();
    }
    handleOnKeyDown(e) {
        if (e.code === 'Tab') {
            this.onTab(e.shiftKey);
        }
        else if (e.code === 'Escape') {
            this.onBlur();
        }
    }
    handleOnBlur(e) {
        this.onBlur();
    }
    handleOnChange(e) {
        this.widget.push();
        this.saveWidget();
    }
}


/***/ }),

/***/ "./src/modules/form-fields/SelectListWidget.ts":
/*!*****************************************************!*\
  !*** ./src/modules/form-fields/SelectListWidget.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectListWidget": () => (/* binding */ SelectListWidget)
/* harmony export */ });
/* harmony import */ var _WidgetBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WidgetBase */ "./src/modules/form-fields/WidgetBase.ts");

class SelectListWidget extends _WidgetBase__WEBPACK_IMPORTED_MODULE_0__.WidgetBase {
    createFormField() {
        const formField = document.createElement('select');
        formField.classList.add('pwv-formField__SelectList');
        for (let i = 0; i < this.widget.options.size; i++) {
            const value = this.widget.options.get(i);
            const item = document.createElement('option');
            item.value = i.toString();
            item.textContent = value;
            formField.appendChild(item);
        }
        formField.value = this.widget.chosen;
        this.handleOnChange = this.handleOnChange.bind(this);
        this.handleOnKeyDown = this.handleOnKeyDown.bind(this);
        this.handleOnBlur = this.handleOnBlur.bind(this);
        formField.addEventListener('change', this.handleOnChange);
        formField.addEventListener('keydown', this.handleOnKeyDown);
        formField.addEventListener('blur', this.handleOnBlur);
        return formField;
    }
    onRemove() {
    }
    setFocus() {
        this.editorElement.focus();
    }
    handleOnKeyDown(e) {
        if (e.code === 'Tab') {
            this.onTab(e.shiftKey);
        }
        else if (e.code === 'Escape') {
            this.onBlur();
        }
    }
    handleOnBlur(e) {
        this.onBlur();
    }
    handleOnChange(e) {
        this.widget.chosen = parseInt(e.target.value);
        this.saveWidget();
    }
}


/***/ }),

/***/ "./src/modules/form-fields/TextBoxWidget.ts":
/*!**************************************************!*\
  !*** ./src/modules/form-fields/TextBoxWidget.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextBoxWidget": () => (/* binding */ TextBoxWidget)
/* harmony export */ });
/* harmony import */ var _WidgetBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WidgetBase */ "./src/modules/form-fields/WidgetBase.ts");

class TextBoxWidget extends _WidgetBase__WEBPACK_IMPORTED_MODULE_0__.WidgetBase {
    createFormField() {
        const formField = this.widget.multilineAllowed
            ? document.createElement('textarea')
            : document.createElement('input');
        formField.classList.add('pwv-formField__TextBox');
        if (this.widget.text) {
            formField.value = this.widget.text;
        }
        if (this.widget.maxLength && this.widget.maxLength >= 0) {
            formField.maxLength = this.widget.maxLength;
        }
        if (this.widget.comb) {
            formField.style.letterSpacing = '1em';
        }
        this.handleOnChange = this.handleOnChange.bind(this);
        this.handleOnKeyDown = this.handleOnKeyDown.bind(this);
        this.handleOnBlur = this.handleOnBlur.bind(this);
        formField.addEventListener('input', this.handleOnChange);
        formField.addEventListener('keydown', this.handleOnKeyDown);
        formField.addEventListener('blur', this.handleOnBlur);
        return formField;
    }
    onRemove() {
    }
    setFocus() {
        this.editorElement.focus();
    }
    handleOnKeyDown(e) {
        if (e.code === 'Tab') {
            this.onTab(e.shiftKey);
        }
        else if (e.code === 'Escape') {
            this.onBlur();
        }
    }
    handleOnBlur(e) {
        this.onBlur();
    }
    handleOnChange(e) {
        try {
            this.widget.text = e.target.value;
        }
        catch (err) {
            console.warn(err);
        }
        this.saveWidget();
    }
}


/***/ }),

/***/ "./src/modules/form-fields/WidgetBase.ts":
/*!***********************************************!*\
  !*** ./src/modules/form-fields/WidgetBase.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WidgetBase": () => (/* binding */ WidgetBase)
/* harmony export */ });
class WidgetBase {
    constructor(element, options) {
        this.element = element;
        this.widgetType = options.widgetType;
        this.widget = options.widget;
        this.pdfDocument = options.pdfDocument;
        this.onTab = options.onTab;
        this.onBlur = options.onBlur;
        this.editorElement = this.createFormField();
        this.editorElement.classList.add('pwv-formField__Element');
        this.element.appendChild(this.editorElement);
        window.setTimeout(() => {
            this.setFocus();
        }, 1);
    }
    saveWidget() {
        this.pdfDocument
            .editAnnotation(this.widget)
            .then(() => { })
            .catch((err) => {
            console.warn(err);
        });
    }
    setZoom(zoom) {
        this.editorElement.style.transform = `scale(${zoom})`;
        this.editorElement.style.width = this.element.clientWidth / zoom + 'px';
        this.editorElement.style.height = this.element.clientHeight / zoom + 'px';
    }
}


/***/ }),

/***/ "./src/modules/freetext-annotation/AddFreetextAnnotationLayer.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/freetext-annotation/AddFreetextAnnotationLayer.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddFreetextAnnotationLayer": () => (/* binding */ AddFreetextAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/document */ "./src/pdf-viewer-canvas/state/document.ts");
/* harmony import */ var _AddFreetextAnnotationToolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AddFreetextAnnotationToolbar */ "./src/modules/freetext-annotation/AddFreetextAnnotationToolbar.tsx");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const moduleLayerName = 'AddFreetextAnnotation';
class AddFreetextAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.context = null;
        this.colors = [];
        this.selectedColor = '';
        this.borderWidths = [];
        this.pointerDown = false;
        this.startPoint = null;
        this.page = 0;
    }
    onCreate() {
        this.setColor = this.setColor.bind(this);
        this.setBorderWidth = this.setBorderWidth.bind(this);
        this.close = this.close.bind(this);
        this.context = this.createCanvas();
        this.colors = this.options.annotation.colors.backgroundColors;
        this.selectedColor =
            this.options.annotation.colors.freetextBackgroundColor ||
                this.options.annotation.colors.defaultBackgroundColor;
        this.borderWidths = [0, 1, 2, 3, 4];
        const toolbarElement = this.module.toolbarElement;
        (0,_AddFreetextAnnotationToolbar__WEBPACK_IMPORTED_MODULE_4__.createAddFreetextAnnotationToolbar)({
            colors: this.colors,
            selectedColor: this.selectedColor,
            borderWidths: this.borderWidths,
            selectedBorderWidth: this.options.annotation.freetextBorderWidth || this.options.annotation.defaultBorderWidth,
            onColorChanged: this.setColor,
            onBorderWidthChanged: this.setBorderWidth,
            onClose: this.close,
        }, toolbarElement);
        this.store.viewer.beginModule(moduleLayerName);
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            resolve();
        });
        return promise;
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.DEFAULT);
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (this.context) {
            const update = state.viewer.modeChanged ||
                state.pointer.positionChanged ||
                state.pointer.action ||
                state.document.zoomChanged;
            if (update) {
                const ctx = this.context;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const pointerPos = { x: state.pointer.x.devicePixels, y: state.pointer.y.devicePixels };
                const pointerPdfPos = this.pdfApi.transformScreenPointToPdfPoint(pointerPos);
                if (pointerPdfPos.isOnPage) {
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.CROSSHAIR);
                }
                else {
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.NOT_ALLOWED);
                }
                if (state.pointer.isDown) {
                    if (!this.pointerDown) {
                        this.startPoint = pointerPos;
                        this.pointerDown = true;
                        if (this.page === 0 && pointerPdfPos.isOnPage) {
                            this.page = pointerPdfPos.pdfPoint.page;
                        }
                    }
                    if (this.startPoint) {
                        const rect = (0,_pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_3__.getRectFromSelection)(state.document, {
                            x: this.startPoint.x,
                            y: this.startPoint.y,
                        }, {
                            x: pointerPos.x,
                            y: pointerPos.y,
                        }, this.page);
                        if (rect) {
                            const lineWidth = 2 * devicePixelRatio;
                            ctx.save();
                            ctx.strokeStyle = this.options.viewer.general.textSelectionColor;
                            ctx.fillStyle = this.options.viewer.general.textSelectionColor;
                            ctx.lineWidth = lineWidth;
                            ctx.setLineDash([lineWidth, lineWidth]);
                            ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                            ctx.globalAlpha = 0.33;
                            ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                            ctx.restore();
                        }
                    }
                }
                else if (this.pointerDown && this.startPoint) {
                    const rect = (0,_pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_3__.getRectFromSelection)(state.document, {
                        x: this.startPoint.x,
                        y: this.startPoint.y,
                    }, {
                        x: pointerPos.x,
                        y: pointerPos.y,
                    }, this.page);
                    if (rect) {
                        this.createFreeTextAnnotation(rect);
                        this.pointerDown = false;
                        this.startPoint = null;
                        this.remove();
                    }
                }
            }
        }
    }
    setColor(color) {
        this.selectedColor = color;
        this.options.annotation.colors.freetextBackgroundColor = color;
    }
    setBorderWidth(borderWidth) {
        this.options.annotation.freetextBorderWidth = borderWidth;
    }
    close() {
        this.remove();
    }
    createFreeTextAnnotation(rect) {
        return __awaiter(this, void 0, void 0, function* () {
            const pdfRect = this.pdfApi.transformScreenRectToPdfRect(rect, this.page);
            const { pdfY, pdfH, pdfW, pdfX, page } = pdfRect;
            const pageSize = yield this.pdfApi.getPagePdfSize(page);
            const minWidth = 60;
            const minHeight = 40;
            const isRotated = this.pdfApi.getRotation() % 180 !== 0;
            pdfRect.pdfW = isRotated ? Math.max(minHeight, pdfW) : Math.max(minWidth, pdfW);
            pdfRect.pdfH = isRotated ? Math.max(minWidth, pdfH) : Math.max(minHeight, pdfH);
            pdfRect.pdfX = Math.min(pdfX, pageSize.width - pdfRect.pdfW);
            pdfRect.pdfY = Math.min(pdfY, pageSize.height - pdfRect.pdfH);
            const annotation = {
                itemType: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.FREE_TEXT,
                color: this.selectedColor === 'transparent' ? '#00000000' : this.selectedColor,
                author: this.options.viewer.general.user,
                page: pdfRect.page,
                pdfRect,
                border: {
                    width: this.options.annotation.freetextBorderWidth || this.options.annotation.defaultBorderWidth,
                    style: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle.SOLID,
                },
                richtext: `<?xml version="1.0"?><body xmlns="http://www.w3.org/1999/xhtml" xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/" xfa:APIVersion="Acrobat:19.12.0" xfa:spec="2.0.2" style="color:${this.options.annotation.colors.freetextFontColor};"></body>`,
                fontName: 'Arial',
                fontColor: this.options.annotation.fonts.freetextFontColor,
                fontSize: this.options.annotation.fonts.freetextFontSize,
            };
            this.pdfApi.createItem(annotation).then((item) => {
                this.onAnnotationCreated(item).then((item) => {
                    const module = this.module;
                    module.onEdit(item.id);
                });
            });
        });
    }
}


/***/ }),

/***/ "./src/modules/freetext-annotation/AddFreetextAnnotationToolbar.tsx":
/*!**************************************************************************!*\
  !*** ./src/modules/freetext-annotation/AddFreetextAnnotationToolbar.tsx ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddFreetextAnnotationToolbar": () => (/* binding */ createAddFreetextAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");
/* harmony import */ var _common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/StrokeWidthPicker */ "./src/common/StrokeWidthPicker.tsx");









const createAddFreetextAnnotationToolbar = (props, element) => {
    const state = {
        colors: props.colors,
        selectedColor: props.selectedColor,
        borderWidths: props.borderWidths,
        selectedBorderWidth: props.selectedBorderWidth,
    };
    const actions = {
        setColor: (color) => ($state) => {
            props.onColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedColor: color });
        },
        setBorderWith: (borderWidth) => ($state) => {
            props.onBorderWidthChanged(borderWidth);
            return Object.assign(Object.assign({}, $state), { selectedBorderWidth: borderWidth });
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(AddFreetextAnnotationToolbar, null);
    const AddFreetextAnnotationToolbar = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_7__.ColorPicker, { colors: $state.colors, color: $state.selectedColor, icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.fillColor, mode: "buttons", onChange: $actions.setColor }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_8__.StrokeWidthPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.borderWidth'), noneStrokeText: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('border.none'), strokeWidths: $state.borderWidths, value: $state.selectedBorderWidth, onChange: $actions.setBorderWith })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.close, onClick: props.onClose }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/freetext-annotation/EditFreetextAnnotationLayer.ts":
/*!************************************************************************!*\
  !*** ./src/modules/freetext-annotation/EditFreetextAnnotationLayer.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditFreetextAnnotationLayer": () => (/* binding */ EditFreetextAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");
/* harmony import */ var _EditFreetextAnnotationToolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditFreetextAnnotationToolbar */ "./src/modules/freetext-annotation/EditFreetextAnnotationToolbar.tsx");
/* harmony import */ var _RichTextEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RichTextEditor */ "./src/modules/freetext-annotation/RichTextEditor.ts");
/* harmony import */ var _common_Tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/Tools */ "./src/common/Tools.ts");
/* harmony import */ var _custom_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../custom/history */ "./src/custom/history.ts");






const moduleLayerName = 'EditFreetextAnnotation';
class EditFreetextAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.freetextAnnotation = null;
        this.editorElement = null;
        this.richTextEditor = null;
        this.toolbarView = null;
        this.color = this.options.annotation.fonts.freetextFontColor;
        this.fontSize = `${this.options.annotation.fonts.defaultFontSize}pt`;
        this.borderWidth = 1;
        this.fontSizeCSS = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_4__.convertPdfToCssPixel)(`${this.options.annotation.fonts.defaultFontSize}`);
        this.fontName = this.options.annotation.fonts.freetextFontFamily;
    }
    onCreate(annotationId) {
        this.store.viewer.beginModule(moduleLayerName);
        this.freetextAnnotation = this.pdfApi.getItem(annotationId);
        this.updateFreeTextAnnotation = this.updateFreeTextAnnotation.bind(this);
        this.close = this.close.bind(this);
        this.editorElement = this.createHtmlLayer();
        this.editorElement.style.position = 'absolute';
        this.editorElement.style.zIndex = '4';
        const annotationOptions = this.options.annotation;
        this.color = annotationOptions.colors.freetextFontColor;
        this.borderWidth = this.freetextAnnotation.border.width;
        this.fontName = annotationOptions.fonts.freetextFontFamily;
        this.fontSize = `${annotationOptions.fonts.freetextFontSize}`;
        this.fontSizeCSS = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_4__.convertPdfToCssPixel)(`${annotationOptions.fonts.freetextFontSize}`);
        if (this.freetextAnnotation.richText) {
            const colorRes = /.*color:(.*?);/.exec(this.freetextAnnotation.richText);
            const fontNameRes = /.*font-family:(.*?);/.exec(this.freetextAnnotation.richText);
            const fontSizeRes = /.*font-size:(.*?)[;|\"]/.exec(this.freetextAnnotation.richText);
            if (colorRes && colorRes.length > 1) {
                this.color = colorRes[1];
            }
            if (fontNameRes && fontNameRes.length > 1) {
                this.fontName = fontNameRes[1];
            }
            if (fontSizeRes && fontSizeRes.length > 1) {
                this.fontSize = fontSizeRes[1];
                this.fontSizeCSS = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_4__.convertPdfToCssPixel)(this.fontSize);
            }
        }
        else {
            this.color = this.freetextAnnotation.color;
            this.fontName = this.freetextAnnotation.fontName;
            this.fontSizeCSS = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_4__.convertPdfToCssPixel)(this.freetextAnnotation.fontSize);
        }
        this.richTextEditor = new _RichTextEditor__WEBPACK_IMPORTED_MODULE_3__.RichTextEditor(this.editorElement, {
            content: this.freetextAnnotation.content,
            richText: this.freetextAnnotation.richText,
            backgroundColor: this.freetextAnnotation.color,
            borderWidth: this.freetextAnnotation.border.width,
            fontName: this.fontName,
            fontColor: this.color,
            fontSizeCSS: this.fontSizeCSS,
        });
        const toolbarElement = this.module.toolbarElement;
        this.toolbarView = (0,_EditFreetextAnnotationToolbar__WEBPACK_IMPORTED_MODULE_2__.createEditFreetextAnnotationToolbar)({
            annotation: this.freetextAnnotation,
            backgroundColors: [...annotationOptions.colors.backgroundColors],
            borderWidths: [0, 1, 2, 3, 4],
            fontColors: [...annotationOptions.colors.foregroundColors],
            fontFamilies: annotationOptions.fonts.fontFamilies,
            fontSizes: annotationOptions.fonts.fontSizes,
            selectedFont: this.fontName,
            selectedBackgroundColor: this.freetextAnnotation.color,
            selectedFontColor: this.color,
            selectedFontSize: this.fontSize,
            selectedBorderWidth: this.borderWidth,
            allowLockAnnotations: this.options.viewer.permissions.allowLockAnnotations,
            hideAnnotationSubject: this.options.annotation.hideAnnotationSubject || false,
            onCmd: this.richTextEditor.executeCommand,
            onClose: this.close,
        }, toolbarElement);
    }
    onSave() {
        return new Promise((resolve, reject) => {
            this.updateFreeTextAnnotation().then(() => {
                this.remove();
                resolve();
            });
        });
    }
    close() {
        this.updateFreeTextAnnotation().then(() => {
            this.remove();
        });
    }
    onRemove() {
        this.removeHtmlElements();
        this.editorElement = null;
        this.freetextAnnotation = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (this.editorElement && state.pointer.action === 'click') {
            const insideHorizontal = state.pointer.x.cssPixels > this.editorElement.offsetLeft &&
                state.pointer.x.cssPixels < this.editorElement.offsetLeft + this.editorElement.offsetWidth;
            const insideVertical = state.pointer.y.cssPixels > this.editorElement.offsetTop &&
                state.pointer.y.cssPixels < this.editorElement.offsetTop + this.editorElement.offsetHeight;
            if (!insideHorizontal || !insideVertical) {
                this.updateFreeTextAnnotation();
                this.remove();
                return;
            }
        }
        if (this.editorElement && this.freetextAnnotation && this.richTextEditor) {
            const updatePosition = state.canvas.canvasInvalidated || state.viewer.modeChanged;
            if (updatePosition) {
                const screenRect = this.pdfApi.transformPdfPageRectToScreenRect(this.freetextAnnotation.pdfRect);
                this.editorElement.style.left = `${screenRect.x / devicePixelRatio}px`;
                this.editorElement.style.top = `${screenRect.y / devicePixelRatio}px`;
                const width = screenRect.w / devicePixelRatio;
                const height = screenRect.h / devicePixelRatio;
                const rotation = (this.freetextAnnotation.rotation + state.document.rotation) % 360;
                this.editorElement.style.transform = `rotate(${rotation}deg)`;
                if (rotation == 90) {
                    this.editorElement.style.width = `${height}px`;
                    this.editorElement.style.height = `${width}px`;
                    this.editorElement.style.transformOrigin = `${width / 2}px ${width / 2}px`;
                }
                else if (rotation == 180) {
                    this.editorElement.style.width = `${width}px`;
                    this.editorElement.style.height = `${height}px`;
                    this.editorElement.style.transformOrigin = `${width / 2}px ${height / 2}px`;
                }
                else if (rotation == 270) {
                    this.editorElement.style.width = `${height}px`;
                    this.editorElement.style.height = `${width}px`;
                    this.editorElement.style.transformOrigin = `${height / 2}px ${height / 2}px`;
                }
                else {
                    this.editorElement.style.width = `${width}px`;
                    this.editorElement.style.height = `${height}px`;
                }
            }
            if (state.document.zoomChanged || state.viewer.modeChanged) {
                this.richTextEditor.setZoom(state.document.zoom);
            }
        }
    }
    updateFreeTextAnnotation() {
        const promise = new Promise((resolve, reject) => {
            if (this.richTextEditor && this.freetextAnnotation) {
                const richTextObj = this.richTextEditor.getEditorValues();
                const subject = this.toolbarView
                    ? this.toolbarView.getState().updatedSubject
                    : this.freetextAnnotation.subject;
                if (this.options.annotation.trackHistory) {
                    (0,_custom_history__WEBPACK_IMPORTED_MODULE_5__.addHistoryEntry)(this.freetextAnnotation, 'edit', this.options.viewer.general.user, richTextObj.content, subject);
                }
                const fontColor = new _common_Color__WEBPACK_IMPORTED_MODULE_1__.Color(richTextObj.fontColor);
                const backgroundColor = richTextObj.backgroundColor === ''
                    ? null
                    : new _common_Color__WEBPACK_IMPORTED_MODULE_1__.Color(richTextObj.backgroundColor);
                this.freetextAnnotation.content = richTextObj.content;
                this.freetextAnnotation.subject = subject;
                this.freetextAnnotation.richText = richTextObj.richText;
                this.freetextAnnotation.fontColor = fontColor.toHexRgb();
                this.freetextAnnotation.fontName =
                    richTextObj.fontName !== null ? richTextObj.fontName : 'Helvetica';
                this.freetextAnnotation.fontSize = richTextObj.fontSizeCSS
                    ? (0,_common_Tools__WEBPACK_IMPORTED_MODULE_4__.convertCssToPdfPixel)(richTextObj.fontSizeCSS)
                    : this.freetextAnnotation.fontSize;
                this.freetextAnnotation.color = backgroundColor !== null ? backgroundColor.toRgba() : null;
                this.freetextAnnotation.border.width = richTextObj.borderWidth;
                this.pdfApi
                    .updateItem(this.freetextAnnotation)
                    .then((item) => {
                    this.store.annotations.updateAnnotation(item);
                    resolve();
                })
                    .catch((err) => {
                    console.error(err);
                    reject();
                });
            }
        });
        return promise;
    }
}


/***/ }),

/***/ "./src/modules/freetext-annotation/EditFreetextAnnotationToolbar.tsx":
/*!***************************************************************************!*\
  !*** ./src/modules/freetext-annotation/EditFreetextAnnotationToolbar.tsx ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEditFreetextAnnotationToolbar": () => (/* binding */ createEditFreetextAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_Dropdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/Dropdown */ "./src/common/Dropdown.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/StrokeWidthPicker */ "./src/common/StrokeWidthPicker.tsx");










const createEditFreetextAnnotationToolbar = (props, element) => {
    const state = {
        annotation: props.annotation,
        updatedSubject: props.annotation.subject,
        backgroundColors: props.backgroundColors,
        borderWidths: props.borderWidths,
        selectedBorderWidth: props.selectedBorderWidth,
        fontColors: props.fontColors,
        fontFamilies: props.fontFamilies,
        fontSizes: props.fontSizes,
        selectedFont: props.selectedFont,
        selectedBackgroundColor: props.selectedBackgroundColor,
        selectedFontColor: props.selectedFontColor,
        selectedFontSize: props.selectedFontSize,
        hasRangeSelection: false,
    };
    const actions = {
        getState: () => ($state) => $state,
        setBorderWith: (borderWidth) => ($state) => {
            props.onCmd({ cmd: 'setBorderWidth', args: borderWidth });
            return Object.assign(Object.assign({}, $state), { selectedBorderWidth: borderWidth });
        },
        executeCommand: (cmd) => ($state) => {
            props.onCmd(cmd);
            return $state;
        },
        setFontFamily: (fontName) => ($state) => {
            props.onCmd({ cmd: 'setFont', args: fontName });
            return Object.assign(Object.assign({}, $state), { selectedFont: fontName });
        },
        setFontSize: (fontSize) => ($state) => {
            props.onCmd({ cmd: 'setFontSize', args: fontSize });
            return Object.assign(Object.assign({}, $state), { selectedFontSize: `${fontSize}pt` });
        },
        setFontColor: (color) => ($state) => {
            props.onCmd({ cmd: 'setFontColor', args: color });
            return Object.assign(Object.assign({}, $state), { selectedFontColor: color });
        },
        setBackgroundColor: (color) => ($state) => {
            props.onCmd({ cmd: 'setFillColor', args: color });
            return Object.assign(Object.assign({}, $state), { selectedBackgroundColor: color });
        },
        setSubject: (subject) => ($state) => {
            return Object.assign(Object.assign({}, $state), { annotation: $state.annotation, updatedSubject: subject });
        },
        hasRangeSelectionChanged: (hasRangeSelection) => ($state) => (Object.assign(Object.assign({}, $state), { hasRangeSelection })),
        close: () => ($state) => {
            props.onClose();
            return $state;
        },
    };
    const App = () => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(EditFreetextAnnotationToolbar, { hideAnnotationSubject: props.hideAnnotationSubject }));
    const EditFreetextAnnotationToolbar = ({ hideAnnotationSubject }) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Dropdown__WEBPACK_IMPORTED_MODULE_5__.Dropdown, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.fontFamily'), text: $state.selectedFont, value: $state.selectedFont, width: 150, items: $state.fontFamilies.map((font) => ({
                    text: font,
                    value: font,
                })), onChange: $actions.setFontFamily }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Dropdown__WEBPACK_IMPORTED_MODULE_5__.Dropdown, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.fontSize'), text: $state.selectedFontSize, value: $state.selectedFontSize, width: 85, align: "right", items: $state.fontSizes.map((size, index) => ({
                    text: `${size}pt`,
                    value: size,
                })), onChange: $actions.setFontSize }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_8__.ToolbarSeparator, null)),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.fontColor'), colors: $state.fontColors, icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.fontColor, color: $state.selectedFontColor, onChange: $actions.setFontColor }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.bgColor'), colors: $state.backgroundColors, icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.fillColor, color: $state.selectedBackgroundColor, onChange: $actions.setBackgroundColor }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_9__.StrokeWidthPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.borderWidth'), noneStrokeText: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('border.none'), strokeWidths: $state.borderWidths, value: $state.selectedBorderWidth, onChange: $actions.setBorderWith }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_8__.ToolbarSeparator, null)),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.alignLeft'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.alignLeft, onClick: () => {
                    $actions.executeCommand({ cmd: 'justifyLeft' });
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.alignCenter'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.alignCenter, onClick: () => {
                    $actions.executeCommand({ cmd: 'justifyCenter' });
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.alignRight'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.alignRight, onClick: () => {
                    $actions.executeCommand({ cmd: 'justifyRight' });
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_8__.ToolbarSeparator, null)),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.bold'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.bold, onClick: () => {
                    $actions.executeCommand({ cmd: 'bold' });
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.italic'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.italic, onClick: () => {
                    $actions.executeCommand({ cmd: 'italic' });
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.underline'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.underline, onClick: () => {
                    $actions.executeCommand({ cmd: 'underline' });
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_8__.ToolbarSeparator, null)),
        props.allowLockAnnotations && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText($state.annotation.isLocked() ? 'annotFreeText.unlock' : 'annotFreeText.lock'), icon: $state.annotation.isLocked() ? _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.lock : _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.unlock, onClick: () => {
                    $state.annotation.setLock(!$state.annotation.isLocked());
                    $actions.close();
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_8__.ToolbarSeparator, null))),
        !hideAnnotationSubject && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'pwv-freetext-subject' },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { id: 'pwv-freetext-subject-' + $state.annotation.id, placeholder: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeText.subjectPlaceholder'), onchange: (e) => {
                        $actions.setSubject(e.currentTarget.value);
                    }, value: $state.updatedSubject })))),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.ok, onClick: $actions.close }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/freetext-annotation/FreetextAnnotationModule.ts":
/*!*********************************************************************!*\
  !*** ./src/modules/freetext-annotation/FreetextAnnotationModule.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FreetextAnnotationModule": () => (/* binding */ FreetextAnnotationModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _AddFreetextAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddFreetextAnnotationLayer */ "./src/modules/freetext-annotation/AddFreetextAnnotationLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _EditFreetextAnnotationLayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EditFreetextAnnotationLayer */ "./src/modules/freetext-annotation/EditFreetextAnnotationLayer.ts");






class FreetextAnnotationModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.annotationbarElement = null;
        this.toolbarElement = null;
        this.name = FreetextAnnotationModule.moduleInfo.name;
        this.onEdit = this.onEdit.bind(this);
    }
    onRegister() {
        this.toolbarElement = document.createElement('div');
        return {
            toolbar: this.toolbarElement,
            contextbar: {
                itemTypes: [_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.FREE_TEXT],
                icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.edit,
                tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('annotFreeText.edit'),
                onCmd: (annotationId) => {
                    this.onEdit(annotationId);
                },
            },
        };
    }
    activate(annotationId) {
        if (annotationId) {
            this.onEdit(annotationId);
        }
        else {
            if (!this.canvasLayers['add']) {
                if (this.store) {
                    this.store.viewer.deselectAnnotation();
                }
                this.createCanvasLayer('add', _AddFreetextAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__.AddFreetextAnnotationLayer);
            }
            else {
                this.removeCanvasLayer('add');
            }
        }
    }
    onEdit(annotationId) {
        this.createCanvasLayer('edit', _EditFreetextAnnotationLayer__WEBPACK_IMPORTED_MODULE_5__.EditFreetextAnnotationLayer, annotationId);
    }
}
FreetextAnnotationModule.moduleInfo = {
    name: 'FreetextAnnotationModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Tool,
    requiredFeatures: {
        annotate: true,
        fillFormFields: false,
    },
    translationKey: 'annotFreeText.add',
    icon: 'freeText',
};


/***/ }),

/***/ "./src/modules/freetext-annotation/RichTextEditor.ts":
/*!***********************************************************!*\
  !*** ./src/modules/freetext-annotation/RichTextEditor.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RichTextEditor": () => (/* binding */ RichTextEditor)
/* harmony export */ });
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");
/* harmony import */ var _common_Tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/Tools */ "./src/common/Tools.ts");


class RichTextEditor {
    constructor(element, content) {
        this.hasRangeSelection = false;
        this.executeCommand = this.executeCommand.bind(this);
        this.handleOnPaste = this.handleOnPaste.bind(this);
        this.handleSelectionChange = this.handleSelectionChange.bind(this);
        this.content = content;
        this.element = element;
        this.element.style.background = 'white';
        this.element.classList.add('pwv-freetexteditor');
        this.editorElement = document.createElement('iframe');
        this.editorElement.width = '100%';
        this.editorElement.height = '100%';
        this.editorElement.frameBorder = '0';
        this.editorElement.style.transformOrigin = '0 0';
        this.element.appendChild(this.editorElement);
        this.editorDocument = this.editorElement.contentDocument;
        this.editorDocument.open();
        this.editorDocument.close();
        let text = content.richText;
        text = text.replace(/\&#(10|13|x0A|x0D);/gi, '<br>');
        text = text.replace(/<p\s*([^>]*)>/gi, '<div $1>');
        text = text.replace(/<\/p>\s*<br\/*>/gi, '</div>');
        text = text.replace(/<br\/*>\s*<\/p>\s*/gi, '</div>');
        text = text.replace(/<\/p>/gi, '</div>');
        text = text.replace(/\r?\n|\r/g, '');
        const m = /.*(<body.*<\/body>).*/gi.exec(text);
        this.editorDocument.body.outerHTML =
            m && m.length > 1
                ? m[1]
                : '<?xml version="1.0"?><body xmlns="http://www.w3.org/1999/xhtml" xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/" xfa:APIVersion="Acrobat:19.12.0" xfa:spec="2.0.2"><p></p></body>';
        if (this.editorDocument.body.children.length === 0) {
            this.editorDocument.body.innerHTML = '<div><br/></div>';
        }
        else {
            this.editorDocument.body.childNodes.forEach((node) => {
                if (node.nodeName === 'DIV' && node.childNodes.length === 0) {
                    const br = document.createElement('br');
                    node.appendChild(br);
                }
            });
        }
        this.editorDocument.body.addEventListener('input', (e) => {
            if (this.editorDocument.body.innerHTML === '' ||
                this.editorDocument.body.innerHTML === '<br>') {
                this.editorDocument.body.innerHTML = '<div><br/></div>';
            }
        });
        this.editorDocument.body.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
            }
            else if (e.key === 'Enter') {
                this.editorDocument.execCommand('formatBlock', false, 'div');
            }
        });
        this.editorDocument.head.insertAdjacentHTML('beforeend', `<style>
        body  {
          padding: 1px;
          line-height: 1.2;
          margin: 0;
          height: 100%;
          box-sizing: border-box;
          white-space: pre-wrap:
          overflow: hidden;
        } 
        p {
          margin: 0;
        }
      </style>`);
        this.editorDocument.body.style.fontFamily = content.fontName;
        this.editorDocument.body.style.color = content.fontColor;
        this.editorDocument.body.style.fontSize = content.fontSizeCSS;
        this.editorDocument.body.style.backgroundColor = content.backgroundColor;
        this.editorDocument.body.style.borderColor = '#000000';
        this.editorDocument.body.style.borderStyle = 'solid';
        this.editorDocument.body.style.borderWidth = `${content.borderWidth}px`;
        this.editorDocument.designMode = 'on';
        this.editorDocument.addEventListener('paste', this.handleOnPaste, false);
        this.editorDocument.addEventListener('selectionchange', this.handleSelectionChange, false);
        this.editorDocument.addEventListener('mousewheel', (e) => {
            e.preventDefault();
            e.cancelBubble = true;
        }, { passive: false });
        this.editorDocument.body.setAttribute('tabindex', '1');
        window.setTimeout(() => {
            var _a;
            let range = this.editorDocument.createRange();
            range.setStart(this.editorDocument.body, 0);
            range.setEnd(this.editorDocument.body, this.editorDocument.body.children.length);
            range.collapse();
            (_a = this.editorDocument.getSelection()) === null || _a === void 0 ? void 0 : _a.addRange(range);
            this.editorDocument.body.focus();
        }, 1);
    }
    setZoom(zoom) {
        this.editorElement.style.transform = `scale(${zoom})`;
        this.editorElement.width = this.element.clientWidth / zoom + 'px';
        this.editorElement.height = this.element.clientHeight / zoom + 'px';
    }
    getEditorValues() {
        const richText = '<?xml version="1.0"?>' + this.cleanupRichText(this.editorDocument.body.outerHTML);
        const pureContent = this.getContent(richText);
        return Object.assign(Object.assign({}, this.content), { content: pureContent ? pureContent : '', backgroundColor: this.editorDocument.body.style.backgroundColor, fontColor: this.editorDocument.body.style.color, fontName: this.editorDocument.body.style.fontFamily, fontSizeCSS: this.editorDocument.body.style.fontSize, richText });
    }
    executeCommand(cmd) {
        switch (cmd.cmd) {
            case 'setFont': {
                this.content.fontName = cmd.args;
                this.editorDocument.body.style.fontFamily = cmd.args;
                break;
            }
            case 'setFontColor': {
                this.content.fontColor = cmd.args;
                this.editorDocument.body.style.color = cmd.args;
                break;
            }
            case 'setBorderWidth': {
                this.content.borderWidth = cmd.args;
                this.editorDocument.body.style.borderWidth = `${cmd.args}px`;
                break;
            }
            case 'setFontSize': {
                const size = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_1__.convertPdfToCssPixel)(cmd.args);
                this.content.fontSizeCSS = size;
                this.editorDocument.body.style.fontSize = size;
                break;
            }
            case 'setFillColor': {
                this.content.backgroundColor = cmd.args;
                this.editorDocument.body.style.backgroundColor = cmd.args;
                break;
            }
            default: {
                this.editorDocument.execCommand(cmd.cmd, false, cmd.args);
            }
        }
    }
    cleanupRichText(richText) {
        let text = richText;
        text = text.replace(/<div><br><\/div>/gi, '&#13;');
        text = text.replace(/<div\s*([^>]*)\>/gi, '<p $1>');
        text = text.replace(/<\/div\>/gi, '</p>&#13;');
        text = text.replace(/<p\s*>/gi, '<p>');
        text = text.replace(/\<br\>/gi, '&#13;');
        text = text.replace(/(\n|\r)/gi, '');
        text = text.replace(/<u>/gi, '<span style="text-decoration:underline;">');
        text = text.replace(/<\/u>/gi, '</span>');
        text = text.replace(/\&nbsp\;/gi, ' ');
        text = text.replace(/overflow\:.*?\;/gi, '');
        text = text.replace(/background-color\:.*?\;/gi, '');
        text = text.replace(/border\:.*?\;/gi, '');
        text = text.replace(/border-color\:.*?\;/gi, '');
        text = text.replace(/border-style\:.*?\;/gi, '');
        text = text.replace(/border-width\:.*?\;/gi, '');
        text = text.replace(/font-size\:\s*(\d*\.?\d+)px\s*\;/gi, (_, size) => {
            size = parseFloat(size);
            size = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_1__.roundToTwo)((size / 96) * 72);
            return 'font-size:' + size + 'pt;';
        });
        text = text.replace(/rgb\((.+?)\)/gi, (rgb) => {
            return new _common_Color__WEBPACK_IMPORTED_MODULE_0__.Color(rgb).toHexRgb();
        });
        text = text.replace(/style="(.*?)"/gi, (styles) => {
            return styles.replace(/\s*/gi, '');
        });
        return text;
    }
    getContent(richText) {
        const parser = new DOMParser();
        const node = parser.parseFromString(richText, 'text/html').documentElement;
        let nodes = node ? node.querySelector('*') : null;
        if (nodes) {
            while (true) {
                nodes = nodes.nextSibling;
                if (nodes) {
                    if (nodes.nodeName.toLocaleLowerCase() === 'body') {
                        return nodes.innerText;
                    }
                }
                else {
                    break;
                }
            }
        }
        return null;
    }
    handleOnPaste(e) {
        e.preventDefault();
        const text = e.clipboardData.getData('text/plain');
        if (text) {
            this.executeCommand({
                cmd: 'insertText',
                args: text,
            });
        }
    }
    handleSelectionChange(e) { }
}


/***/ }),

/***/ "./src/modules/highlight-annotation/AddHighlightAnnotationLayer.ts":
/*!*************************************************************************!*\
  !*** ./src/modules/highlight-annotation/AddHighlightAnnotationLayer.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddHighlightAnnotationLayer": () => (/* binding */ AddHighlightAnnotationLayer),
/* harmony export */   "HighlightTool": () => (/* binding */ HighlightTool)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _pdf_viewer_canvas_view_layers_canvasShapes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pdf-viewer-canvas/view-layers/canvasShapes */ "./src/pdf-viewer-canvas/view-layers/canvasShapes.ts");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");
/* harmony import */ var _AddHighlightAnnotationToolbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AddHighlightAnnotationToolbar */ "./src/modules/highlight-annotation/AddHighlightAnnotationToolbar.tsx");
/* harmony import */ var _pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/document */ "./src/pdf-viewer-canvas/state/document.ts");







var HighlightTool;
(function (HighlightTool) {
    HighlightTool[HighlightTool["HIGHLIGHT"] = 0] = "HIGHLIGHT";
    HighlightTool[HighlightTool["RECTANGULAR_HIGHLIGHT"] = 1] = "RECTANGULAR_HIGHLIGHT";
    HighlightTool[HighlightTool["UNDERLINE"] = 2] = "UNDERLINE";
    HighlightTool[HighlightTool["SQUIGGLY"] = 3] = "SQUIGGLY";
    HighlightTool[HighlightTool["STRIKE_OUT"] = 4] = "STRIKE_OUT";
})(HighlightTool || (HighlightTool = {}));
const moduleLayerName = 'AddHighlightAnnotation';
class AddHighlightAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.colors = [];
        this.selectedColor = '';
        this.selectedTool = HighlightTool.HIGHLIGHT;
        this.pdfStartPoint = null;
        this.screenStartPoint = null;
        this.pointerDown = false;
        this.page = 0;
        this.selecting = false;
        this.selection = null;
    }
    onCreate() {
        this.setColor = this.setColor.bind(this);
        this.close = this.close.bind(this);
        this.setTool = this.setTool.bind(this);
        this.context = this.createCanvas();
        const annotationOptions = this.options.annotation;
        this.colors = annotationOptions.colors.highlightColors;
        this.selectedColor = annotationOptions.colors.highlightAnnotationColor;
        const toolbarElement = this.module.toolbarElement;
        (0,_AddHighlightAnnotationToolbar__WEBPACK_IMPORTED_MODULE_5__.createAddHighlightAnnotationToolbar)({
            colors: this.colors,
            selectedColor: this.selectedColor,
            selectedTool: this.selectedTool,
            onColorChanged: this.setColor,
            onToolChanged: this.setTool,
            onClose: this.close,
        }, toolbarElement);
        this.store.viewer.beginModule(moduleLayerName);
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            resolve();
        });
        return promise;
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (this.context) {
            if (this.selectedTool === HighlightTool.RECTANGULAR_HIGHLIGHT) {
                const ctx = this.context;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const pointerPos = {
                    x: state.pointer.x.devicePixels,
                    y: state.pointer.y.devicePixels,
                };
                const pointerPdfPos = this.pdfApi.transformScreenPointToPdfPoint(pointerPos);
                if (pointerPdfPos.isOnPage) {
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.CROSSHAIR);
                }
                else {
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.NOT_ALLOWED);
                }
                if (state.pointer.isDown) {
                    if (!this.pointerDown) {
                        this.screenStartPoint = pointerPos;
                        this.pointerDown = true;
                        if (this.page === 0 && pointerPdfPos.isOnPage) {
                            this.page = pointerPdfPos.pdfPoint.page;
                        }
                    }
                    if (this.screenStartPoint) {
                        const rect = (0,_pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_6__.getRectFromSelection)(state.document, {
                            x: this.screenStartPoint.x,
                            y: this.screenStartPoint.y,
                        }, {
                            x: pointerPos.x,
                            y: pointerPos.y,
                        }, this.page);
                        if (rect) {
                            const lineWidth = 2 * devicePixelRatio;
                            ctx.save();
                            ctx.strokeStyle = this.options.viewer.general.textSelectionColor;
                            ctx.fillStyle = this.options.viewer.general.textSelectionColor;
                            ctx.lineWidth = lineWidth;
                            ctx.setLineDash([lineWidth, lineWidth]);
                            ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                            ctx.globalAlpha = 0.33;
                            ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                            ctx.restore();
                        }
                    }
                }
                else if (this.pointerDown && this.screenStartPoint) {
                    const rect = (0,_pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_6__.getRectFromSelection)(state.document, {
                        x: this.screenStartPoint.x,
                        y: this.screenStartPoint.y,
                    }, {
                        x: pointerPos.x,
                        y: pointerPos.y,
                    }, this.page);
                    if (rect) {
                        this.createRectangularHighlightAnnotation(rect);
                        this.pointerDown = false;
                        this.screenStartPoint = null;
                        this.page = 0;
                    }
                }
            }
            else {
                let drawSelection = state.canvas.canvasInvalidated;
                if (state.pointer.positionChanged) {
                    const pointerPos = {
                        x: state.pointer.x.devicePixels,
                        y: state.pointer.y.devicePixels,
                    };
                    const pointerPdfPos = this.pdfApi.transformScreenPointToPdfPoint(pointerPos);
                    let currentTextFragment = null;
                    if (pointerPdfPos.isOnPage) {
                        currentTextFragment = this.pdfApi.getTextFragmentOnPoint(pointerPos);
                        if (currentTextFragment) {
                            this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.TEXT);
                        }
                        else {
                            this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.DEFAULT);
                        }
                    }
                    else {
                        this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.DEFAULT);
                    }
                    if (state.pointer.stateChanged) {
                        if (state.pointer.isDown) {
                            if (pointerPdfPos.isOnPage) {
                                if (currentTextFragment) {
                                    const startPdfPos = pointerPdfPos;
                                    this.selecting = true;
                                    this.selection = null;
                                    this.pdfStartPoint = startPdfPos.pdfPoint;
                                    drawSelection = true;
                                }
                            }
                        }
                        else {
                            if (this.selecting) {
                                const ctx = this.context;
                                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                                this.createHighlightAnnotation();
                                this.selecting = false;
                            }
                        }
                    }
                    if (this.selecting &&
                        this.pdfStartPoint &&
                        this.pdfStartPoint !== pointerPdfPos.pdfPoint) {
                        const endPoint = this.pdfApi.getClosestPointOnPdfByScreenPoint(pointerPos);
                        this.selection = this.pdfApi.getTextSelection(this.pdfStartPoint, endPoint);
                    }
                    drawSelection = true;
                }
                if (drawSelection && this.selection) {
                    const ctx = this.context;
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    const screenSelection = [];
                    for (let i = 0; i < this.selection.quadrilaterals.length; i++) {
                        const path = this.pdfApi.transformQuadrilateralToViewport(this.selection.quadrilaterals[i]);
                        screenSelection.push(path);
                    }
                    (0,_pdf_viewer_canvas_view_layers_canvasShapes__WEBPACK_IMPORTED_MODULE_3__.renderTextSelection)(ctx, devicePixelRatio * state.document.zoom, this.options.viewer.general.textSelectionColor, screenSelection);
                }
            }
        }
    }
    setColor(color) {
        this.selectedColor = color;
        this.options.annotation.colors.highlightAnnotationColor = color;
    }
    setTool(tool) {
        this.selectedTool = tool;
    }
    close() {
        this.remove();
    }
    getPdfItemTypeForTool() {
        switch (this.selectedTool) {
            case HighlightTool.HIGHLIGHT:
                return _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.HIGHLIGHT;
            case HighlightTool.RECTANGULAR_HIGHLIGHT:
                return _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.HIGHLIGHT;
            case HighlightTool.UNDERLINE:
                return _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.UNDERLINE;
            case HighlightTool.SQUIGGLY:
                return _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.SQUIGGLY;
            case HighlightTool.STRIKE_OUT:
                return _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.STRIKE_OUT;
            default:
                throw new Error('unknown Highlight tool');
        }
    }
    createRectangularHighlightAnnotation(rect) {
        const pdfRect = this.pdfApi.transformScreenRectToPdfRect(rect, this.page);
        const colorObj = new _common_Color__WEBPACK_IMPORTED_MODULE_4__.Color(this.selectedColor);
        colorObj.setOpacity(this.options.annotation.highlightOpacity);
        const color = colorObj.toRgba();
        const quadrilaterals = [];
        quadrilaterals.push({
            pageNumber: this.page,
            bottomLeft: { x: pdfRect.pdfX, y: pdfRect.pdfY },
            bottomRight: { x: pdfRect.pdfX + pdfRect.pdfW, y: pdfRect.pdfY },
            topLeft: { x: pdfRect.pdfX, y: pdfRect.pdfY + pdfRect.pdfH },
            topRight: { x: pdfRect.pdfX + pdfRect.pdfW, y: pdfRect.pdfY + pdfRect.pdfH },
        });
        const args = {
            itemType: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.HIGHLIGHT,
            page: this.page,
            pdfRect,
            color,
            author: this.options.viewer.general.user,
            quadrilaterals,
        };
        this.pdfApi.createItem(args).then((item) => {
            this.onAnnotationCreated(item);
        });
    }
    createHighlightAnnotation() {
        if (this.pdfApi && this.store) {
            const pdfItemType = this.getPdfItemTypeForTool();
            const selection = this.selection;
            this.selection = null;
            if (selection) {
                const selByPage = [];
                for (let i = 0; i < selection.quadrilaterals.length; i++) {
                    const quadrilateral = selection.quadrilaterals[i];
                    if (!selByPage[quadrilateral.pageNumber]) {
                        selByPage[quadrilateral.pageNumber] = [];
                    }
                    selByPage[quadrilateral.pageNumber].push(quadrilateral);
                }
                let color = this.selectedColor;
                if (pdfItemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.HIGHLIGHT) {
                    const colorObj = new _common_Color__WEBPACK_IMPORTED_MODULE_4__.Color(color);
                    colorObj.setOpacity(this.options.annotation.highlightOpacity);
                    color = colorObj.toRgba();
                }
                for (let i = 0; i < selByPage.length; i++) {
                    if (selByPage[i]) {
                        const quadrilaterals = selByPage[i];
                        const args = {
                            itemType: pdfItemType,
                            page: i,
                            pdfRect: {
                                pdfX: 0,
                                pdfY: 0,
                                pdfW: 0,
                                pdfH: 0,
                                page: i,
                            },
                            color,
                            author: this.options.viewer.general.user,
                            quadrilaterals,
                        };
                        this.pdfApi.createItem(args).then((item) => {
                            this.onAnnotationCreated(item);
                        });
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/modules/highlight-annotation/AddHighlightAnnotationToolbar.tsx":
/*!****************************************************************************!*\
  !*** ./src/modules/highlight-annotation/AddHighlightAnnotationToolbar.tsx ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddHighlightAnnotationToolbar": () => (/* binding */ createAddHighlightAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");
/* harmony import */ var _AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AddHighlightAnnotationLayer */ "./src/modules/highlight-annotation/AddHighlightAnnotationLayer.ts");









const createAddHighlightAnnotationToolbar = (props, element) => {
    const state = {
        colors: props.colors,
        selectedTool: props.selectedTool,
        selectedColor: props.selectedColor,
    };
    const actions = {
        setColor: (color) => ($state) => {
            props.onColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedColor: color });
        },
        setTool: (tool) => ($state) => {
            props.onToolChanged(tool);
            return Object.assign(Object.assign({}, $state), { selectedTool: tool });
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(AddHighlightAnnotationToolbar, null);
    const AddHighlightAnnotationToolbar = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_7__.ColorPicker, { colors: $state.colors, color: $state.selectedColor, icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.fillColor, mode: "buttons", onChange: $actions.setColor }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__.ToolbarSeparator, null)),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotHighlight.highlight'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.highlighter, active: $state.selectedTool === _AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.HIGHLIGHT, onClick: () => {
                    $actions.setTool(_AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.HIGHLIGHT);
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotHighlight.underline'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.underline, active: $state.selectedTool === _AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.UNDERLINE, onClick: () => {
                    $actions.setTool(_AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.UNDERLINE);
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotHighlight.squiggly'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.squiggly, active: $state.selectedTool === _AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.SQUIGGLY, onClick: () => {
                    $actions.setTool(_AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.SQUIGGLY);
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotHighlight.strikeOut'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.strikethrough, active: $state.selectedTool === _AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.STRIKE_OUT, onClick: () => {
                    $actions.setTool(_AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.STRIKE_OUT);
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotHighlight.rectangularHighlight'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.rectangularHighlighter, active: $state.selectedTool === _AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.RECTANGULAR_HIGHLIGHT, onClick: () => {
                    $actions.setTool(_AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_8__.HighlightTool.RECTANGULAR_HIGHLIGHT);
                } })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.close, onClick: props.onClose }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/highlight-annotation/EditHighlightAnnotationLayer.ts":
/*!**************************************************************************!*\
  !*** ./src/modules/highlight-annotation/EditHighlightAnnotationLayer.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditHighlightAnnotationLayer": () => (/* binding */ EditHighlightAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");
/* harmony import */ var _EditHighlightAnnotationToolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditHighlightAnnotationToolbar */ "./src/modules/highlight-annotation/EditHighlightAnnotationToolbar.tsx");



const moduleLayerName = 'EditHighlightAnnotation';
class EditHighlightAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.highlightAnnotation = null;
        this.colors = [];
        this.selectedColor = '';
    }
    onCreate(annotationId) {
        this.highlightAnnotation = this.pdfApi.getItem(annotationId);
        this.setColor = this.setColor.bind(this);
        this.close = this.close.bind(this);
        this.context = this.createCanvas();
        const annotationOptions = this.options.annotation;
        this.colors = annotationOptions.colors.highlightColors;
        this.selectedColor = annotationOptions.colors.highlightAnnotationColor;
        const toolbarElement = this.module.toolbarElement;
        (0,_EditHighlightAnnotationToolbar__WEBPACK_IMPORTED_MODULE_2__.createEditHighlightAnnotationToolbar)({
            colors: this.colors,
            selectedColor: this.selectedColor,
            onColorChanged: this.setColor,
            onClose: this.close,
        }, toolbarElement);
        this.store.viewer.beginModule(moduleLayerName);
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            resolve();
        });
        return promise;
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        var _a;
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.close();
            return;
        }
        if (state.pointer.action === 'click' || state.pointer.action === 'dblclick') {
            const highlightAnnotation = (_a = this.pdfApi
                .getAnnotationsOnPoint({
                x: state.pointer.x.devicePixels,
                y: state.pointer.y.devicePixels,
            })) === null || _a === void 0 ? void 0 : _a.find((a) => this.highlightAnnotation && a.id === this.highlightAnnotation.id);
            if (!highlightAnnotation) {
                this.close();
                return;
            }
        }
        if (this.context && this.highlightAnnotation) {
            const ctx = this.context;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const rect = this.pdfApi.transformPdfPageRectToScreenRect(this.highlightAnnotation.pdfRect);
            const lineWidth = 2 * devicePixelRatio;
            ctx.save();
            ctx.strokeStyle = this.options.viewer.general.textSelectionColor;
            ctx.lineWidth = lineWidth;
            ctx.setLineDash([lineWidth, lineWidth]);
            ctx.strokeRect(rect.x - lineWidth, rect.y - lineWidth, rect.w + 2 * lineWidth, rect.h + 2 * lineWidth);
            ctx.restore();
        }
    }
    setColor(color) {
        if (this.highlightAnnotation && this.highlightAnnotation.color) {
            const newColor = new _common_Color__WEBPACK_IMPORTED_MODULE_1__.Color(color);
            const currentColor = new _common_Color__WEBPACK_IMPORTED_MODULE_1__.Color(this.highlightAnnotation.color);
            newColor.setOpacity(currentColor.a);
            this.highlightAnnotation.color = newColor.toRgba();
            this.updateHighlightAnnotation();
        }
    }
    close() {
        this.remove();
    }
    updateHighlightAnnotation() {
        const promise = new Promise((resolve, reject) => {
            if (this.pdfApi && this.highlightAnnotation) {
                this.pdfApi
                    .updateItem(this.highlightAnnotation)
                    .then((item) => {
                    resolve();
                })
                    .catch((error) => {
                    console.warn(error);
                });
            }
            else {
                reject();
            }
        });
        return promise;
    }
}


/***/ }),

/***/ "./src/modules/highlight-annotation/EditHighlightAnnotationToolbar.tsx":
/*!*****************************************************************************!*\
  !*** ./src/modules/highlight-annotation/EditHighlightAnnotationToolbar.tsx ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEditHighlightAnnotationToolbar": () => (/* binding */ createEditHighlightAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");







const createEditHighlightAnnotationToolbar = (props, element) => {
    const state = {
        colors: props.colors,
        selectedColor: props.selectedColor,
    };
    const actions = {
        setColor: (color) => ($state) => {
            props.onColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedColor: color });
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(EditHighlightAnnotationToolbar, null);
    const EditHighlightAnnotationToolbar = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_1__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { colors: $state.colors, color: $state.selectedColor, icon: _common_icons__WEBPACK_IMPORTED_MODULE_4__.icons.fillColor, mode: "buttons", onChange: $actions.setColor })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_5__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_4__.icons.close, onClick: props.onClose }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/highlight-annotation/HighlightAnnotationModule.ts":
/*!***********************************************************************!*\
  !*** ./src/modules/highlight-annotation/HighlightAnnotationModule.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HighlightAnnotationModule": () => (/* binding */ HighlightAnnotationModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddHighlightAnnotationLayer */ "./src/modules/highlight-annotation/AddHighlightAnnotationLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _EditHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EditHighlightAnnotationLayer */ "./src/modules/highlight-annotation/EditHighlightAnnotationLayer.ts");






class HighlightAnnotationModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.toolbarElement = null;
        this.name = HighlightAnnotationModule.moduleInfo.name;
        this.activate = this.activate.bind(this);
    }
    onRegister() {
        this.toolbarElement = document.createElement('div');
        return {
            toolbar: this.toolbarElement,
            contextbar: {
                itemTypes: [
                    _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.HIGHLIGHT,
                    _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.UNDERLINE,
                    _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.SQUIGGLY,
                    _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.STRIKE_OUT,
                ],
                icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.edit,
                tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('annotHighlight.edit'),
                onCmd: (annotationId) => {
                    this.onEdit(annotationId);
                },
            },
        };
    }
    activate() {
        if (!this.canvasLayers['add']) {
            this.createCanvasLayer('add', _AddHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__.AddHighlightAnnotationLayer);
        }
        else {
            this.removeCanvasLayer('add');
        }
    }
    onEdit(annotationId) {
        this.createCanvasLayer('edit', _EditHighlightAnnotationLayer__WEBPACK_IMPORTED_MODULE_5__.EditHighlightAnnotationLayer, annotationId);
    }
}
HighlightAnnotationModule.moduleInfo = {
    name: 'HighlightAnnotationModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Tool,
    requiredFeatures: {
        annotate: true,
        fillFormFields: false,
    },
    translationKey: 'annotHighlight.add',
    icon: 'highlighter',
};


/***/ }),

/***/ "./src/modules/image-annotations/ImageAnnotationModule.ts":
/*!****************************************************************!*\
  !*** ./src/modules/image-annotations/ImageAnnotationModule.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageAnnotationModule": () => (/* binding */ ImageAnnotationModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_Tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Tools */ "./src/common/Tools.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class ImageAnnotationModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.toolbarElement = null;
        this.fileInput = null;
        this.name = ImageAnnotationModule.moduleInfo.name;
        this.createImage = this.createImage.bind(this);
        this.onFileSelected = this.onFileSelected.bind(this);
        this.createImageStampAnnotation = this.createImageStampAnnotation.bind(this);
    }
    onRegister() {
        this.toolbarElement = document.createElement('div');
        this.fileInput = document.createElement('input');
        this.fileInput.setAttribute('type', 'file');
        this.fileInput.setAttribute('accept', '.jpg, .jpeg, .jpe, .jif, .jfif, .jfi, .jp2, .j2k, .jpf, .jpm, .jpg2, .j2c, .jpc, .jpx, .mj2 .tif, tiff, .png, .gif, .bmp');
        this.fileInput.style.position = 'absolute';
        this.fileInput.style.left = '-5000px';
        this.fileInput.onchange = (e) => {
            if (e.currentTarget.files && e.currentTarget.files.length) {
                const file = e.currentTarget.files[0];
                this.onFileSelected(file);
                e.currentTarget.value = '';
            }
        };
        this.toolbarElement.append(this.fileInput);
        return {
            toolbar: this.toolbarElement,
        };
    }
    activate(file) {
        if (file) {
            this.onFileSelected(file);
        }
        else if (this.fileInput) {
            this.fileInput.click();
        }
    }
    createImage(dataUrl) {
        const image = new Image();
        image.onload = () => {
            const imageInfo = {
                width: image.width,
                height: image.height,
                stampImage: (0,_common_Tools__WEBPACK_IMPORTED_MODULE_2__.imageDataUrlToUint8Array)(image.src),
            };
            this.createImageStampAnnotation(imageInfo);
        };
        image.src = dataUrl;
    }
    onFileSelected(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const reader = new FileReader();
            const _this = this;
            reader.onload = function (e) {
                _this.createImage(e.target.result);
            };
            reader.readAsDataURL(file);
        });
    }
    createImageStampAnnotation(imageInfo) {
        if (this.pdfApi !== null && this.store !== null && this.options !== null) {
            const state = this.store.getState();
            const document = state.document;
            const canvasRect = this.getCanvasSize();
            const screenCenter = {
                x: canvasRect.width / 2,
                y: canvasRect.height / 2,
            };
            let page = this.pdfApi.getPageNumber();
            const screenRect = {
                x: 0,
                y: 0,
                w: canvasRect.width,
                h: canvasRect.height,
            };
            const pageScreenRect = this.pdfApi.getPageScreenRect(page);
            const x1 = Math.max(screenRect.x, pageScreenRect.x);
            const y1 = Math.max(screenRect.y, pageScreenRect.y);
            const x2 = Math.min(screenRect.w, pageScreenRect.x + pageScreenRect.w);
            const y2 = Math.min(screenRect.h, pageScreenRect.y + pageScreenRect.h);
            const boundingRect = {
                x: x1,
                y: y1,
                w: x2 - x1,
                h: y2 - y1,
            };
            const pageBoundingBox = this.pdfApi.transformScreenRectToPdfRect(boundingRect, page);
            const imagepPdfRect = {
                pdfX: 0,
                pdfY: 0,
                pdfW: imageInfo.width * 0.24,
                pdfH: imageInfo.height * 0.24,
                page,
            };
            if (imagepPdfRect.pdfW > pageBoundingBox.pdfW) {
                const f = (pageBoundingBox.pdfW / imagepPdfRect.pdfW) * 0.97;
                imagepPdfRect.pdfW = imagepPdfRect.pdfW * f;
                imagepPdfRect.pdfH = imagepPdfRect.pdfH * f;
            }
            if (imagepPdfRect.pdfH > pageBoundingBox.pdfH) {
                const f = (pageBoundingBox.pdfH / imagepPdfRect.pdfH) * 0.97;
                imagepPdfRect.pdfW = imagepPdfRect.pdfW * f;
                imagepPdfRect.pdfH = imagepPdfRect.pdfH * f;
            }
            imagepPdfRect.pdfX = (pageBoundingBox.pdfW - imagepPdfRect.pdfW) / 2 + pageBoundingBox.pdfX;
            imagepPdfRect.pdfY = (pageBoundingBox.pdfH - imagepPdfRect.pdfH) / 2 + pageBoundingBox.pdfY;
            this.pdfApi.registerStampImage(imageInfo.stampImage).then((imageId) => {
                if (this.pdfApi !== null && this.options !== null) {
                    const annotation = {
                        itemType: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.STAMP,
                        imageId,
                        page,
                        color: this.options.annotation.colors.defaultHighlightColor,
                        pdfRect: imagepPdfRect,
                        author: this.options.viewer.general.user,
                    };
                    this.pdfApi
                        .createItem(annotation)
                        .then((annot) => {
                        const pdfViewerCanvasApi = this.pdfViewerCanvas;
                        pdfViewerCanvasApi.dispatchEvent('itemSelected', annot);
                    })
                        .catch((err) => {
                        console.error(err);
                    });
                }
            });
        }
    }
}
ImageAnnotationModule.moduleInfo = {
    name: 'ImageAnnotationModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Tool,
    requiredFeatures: {
        annotate: true,
        fillFormFields: false,
    },
    translationKey: 'annotImage.add',
    icon: 'image',
};


/***/ }),

/***/ "./src/modules/index.ts":
/*!******************************!*\
  !*** ./src/modules/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasLayer": () => (/* reexport safe */ _CanvasLayer__WEBPACK_IMPORTED_MODULE_11__.CanvasLayer),
/* harmony export */   "CanvasModule": () => (/* reexport safe */ _CanvasModule__WEBPACK_IMPORTED_MODULE_12__.CanvasModule),
/* harmony export */   "CanvasModuleType": () => (/* reexport safe */ _CanvasModule__WEBPACK_IMPORTED_MODULE_12__.CanvasModuleType),
/* harmony export */   "EraserModule": () => (/* reexport safe */ _eraser_EraserModule__WEBPACK_IMPORTED_MODULE_8__.EraserModule),
/* harmony export */   "FormFieldModule": () => (/* reexport safe */ _form_fields_FormFieldModule__WEBPACK_IMPORTED_MODULE_10__.FormFieldModule),
/* harmony export */   "FreetextAnnotationModule": () => (/* reexport safe */ _freetext_annotation_FreetextAnnotationModule__WEBPACK_IMPORTED_MODULE_0__.FreetextAnnotationModule),
/* harmony export */   "HighlightAnnotationModule": () => (/* reexport safe */ _highlight_annotation_HighlightAnnotationModule__WEBPACK_IMPORTED_MODULE_1__.HighlightAnnotationModule),
/* harmony export */   "ImageAnnotationModule": () => (/* reexport safe */ _image_annotations_ImageAnnotationModule__WEBPACK_IMPORTED_MODULE_6__.ImageAnnotationModule),
/* harmony export */   "InkAnnotationModule": () => (/* reexport safe */ _ink_annotation_InkAnnotationModule__WEBPACK_IMPORTED_MODULE_2__.InkAnnotationModule),
/* harmony export */   "PopupModule": () => (/* reexport safe */ _popup_PopupModule__WEBPACK_IMPORTED_MODULE_3__.PopupModule),
/* harmony export */   "PrintServiceModule": () => (/* reexport safe */ _print_service_PrintServiceModule__WEBPACK_IMPORTED_MODULE_9__.PrintServiceModule),
/* harmony export */   "ShapeAnnotationModule": () => (/* reexport safe */ _shape_annotations_ShapeAnnotationModule__WEBPACK_IMPORTED_MODULE_7__.ShapeAnnotationModule),
/* harmony export */   "StampAnnotationModule": () => (/* reexport safe */ _stamp_annotation_StampAnnotationModule__WEBPACK_IMPORTED_MODULE_4__.StampAnnotationModule),
/* harmony export */   "TextAnnotationModule": () => (/* reexport safe */ _text_annotation_TextAnnotationModule__WEBPACK_IMPORTED_MODULE_5__.TextAnnotationModule)
/* harmony export */ });
/* harmony import */ var _freetext_annotation_FreetextAnnotationModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./freetext-annotation/FreetextAnnotationModule */ "./src/modules/freetext-annotation/FreetextAnnotationModule.ts");
/* harmony import */ var _highlight_annotation_HighlightAnnotationModule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./highlight-annotation/HighlightAnnotationModule */ "./src/modules/highlight-annotation/HighlightAnnotationModule.ts");
/* harmony import */ var _ink_annotation_InkAnnotationModule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ink-annotation/InkAnnotationModule */ "./src/modules/ink-annotation/InkAnnotationModule.ts");
/* harmony import */ var _popup_PopupModule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./popup/PopupModule */ "./src/modules/popup/PopupModule.ts");
/* harmony import */ var _stamp_annotation_StampAnnotationModule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stamp-annotation/StampAnnotationModule */ "./src/modules/stamp-annotation/StampAnnotationModule.ts");
/* harmony import */ var _text_annotation_TextAnnotationModule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./text-annotation/TextAnnotationModule */ "./src/modules/text-annotation/TextAnnotationModule.ts");
/* harmony import */ var _image_annotations_ImageAnnotationModule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./image-annotations/ImageAnnotationModule */ "./src/modules/image-annotations/ImageAnnotationModule.ts");
/* harmony import */ var _shape_annotations_ShapeAnnotationModule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shape-annotations/ShapeAnnotationModule */ "./src/modules/shape-annotations/ShapeAnnotationModule.ts");
/* harmony import */ var _eraser_EraserModule__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./eraser/EraserModule */ "./src/modules/eraser/EraserModule.ts");
/* harmony import */ var _print_service_PrintServiceModule__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./print-service/PrintServiceModule */ "./src/modules/print-service/PrintServiceModule.ts");
/* harmony import */ var _form_fields_FormFieldModule__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./form-fields/FormFieldModule */ "./src/modules/form-fields/FormFieldModule.ts");
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./CanvasModule */ "./src/modules/CanvasModule.ts");















/***/ }),

/***/ "./src/modules/ink-annotation/AddInkAnnotationLayer.ts":
/*!*************************************************************!*\
  !*** ./src/modules/ink-annotation/AddInkAnnotationLayer.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddInkAnnotationLayer": () => (/* binding */ AddInkAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _AddInkAnnotationToolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AddInkAnnotationToolbar */ "./src/modules/ink-annotation/AddInkAnnotationToolbar.tsx");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");





const moduleLayerName = 'AddInkAnnotation';
class AddInkAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.context = null;
        this.drawing = false;
        this.lines = [];
        this.page = null;
        this.zoom = null;
        this.inkWidth = 1;
        this.penColors = [];
        this.penWidths = [];
        this.penColor = '';
        this.penOpacity = 1;
        this.boundingBox = null;
        this.toolbar = null;
        this.handlePointerMove = (e) => {
            if (!e.isPrimary) {
                this.handlePointerUp(e);
                return;
            }
            const x = e.offsetX * devicePixelRatio;
            const y = e.offsetY * devicePixelRatio;
            const pdfPoint = this.pdfApi.getClosestPointOnPdfByScreenPoint({ x, y }, this.page);
            this.lines[this.lines.length - 1].push(pdfPoint);
            if (this.context) {
                const screenPoint = this.pdfApi.transformPdfPointToScreenPoint(pdfPoint);
                this.context.lineTo(screenPoint.x, screenPoint.y);
                this.context.stroke();
            }
        };
        this.handlePointerUp = (e) => {
            if (this.context) {
                const { canvas } = this.context;
                canvas.removeEventListener('pointermove', this.handlePointerMove);
                canvas.removeEventListener('pointerup', this.handlePointerUp);
                canvas.removeEventListener('pointercancel', this.handlePointerUp);
            }
            this.endLine();
        };
    }
    onCreate() {
        this.setPenColor = this.setPenColor.bind(this);
        this.setPenSize = this.setPenSize.bind(this);
        this.setPenOpacity = this.setPenOpacity.bind(this);
        this.add = this.add.bind(this);
        this.undo = this.undo.bind(this);
        this.save = this.save.bind(this);
        const annotationOptions = this.options.annotation;
        this.context = this.createCanvas();
        this.penColors = annotationOptions.colors.foregroundColors;
        this.penWidths = annotationOptions.strokeWidths;
        this.inkWidth = annotationOptions.inkWidth;
        this.setPenColor(annotationOptions.colors.inkColor);
        this.setPenOpacity(annotationOptions.colors.inkOpacity);
        this.store.viewer.beginModule(moduleLayerName);
        const toolbarElement = this.module.toolbarElement;
        this.toolbar = (0,_AddInkAnnotationToolbar__WEBPACK_IMPORTED_MODULE_3__.createAddInkAnnotationToolbar)({
            penColors: this.penColors,
            penWidths: this.penWidths,
            selectedPenColor: annotationOptions.colors.inkColor,
            selectedPenSize: annotationOptions.inkWidth,
            penOpacity: annotationOptions.colors.inkOpacity,
            onPenColorChanged: this.setPenColor,
            onPenSizeChanged: this.setPenSize,
            onPenOpacityChanged: this.setPenOpacity,
            onSave: this.save,
            onUndo: this.undo,
            onAdd: this.add,
            onCancel: this.remove,
        }, toolbarElement);
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            this.createInkAnnotation()
                .then(() => {
                this.remove();
                resolve();
            })
                .catch(() => {
                reject();
            });
        });
        return promise;
    }
    onRemove() {
        if (this.lines && this.lines.length > 0) {
            this.createInkAnnotation().then(() => {
                this.onRemove();
            });
        }
        else {
            this.removeCanvasElements();
            this.context = null;
            const toolbarElement = this.module.toolbarElement;
            toolbarElement.innerHTML = '';
            this.store.viewer.endModule(moduleLayerName);
        }
    }
    render(timestamp, state) {
        if (this.drawing) {
            return;
        }
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (this.zoom === null || state.document.zoomChanged) {
            this.zoom = state.document.zoom;
            this.drawLines();
        }
        if (state.scroll.leftPositionChanged || state.scroll.topPositionChanged) {
            this.drawLines();
        }
        const pointerPos = {
            x: state.pointer.x.devicePixels,
            y: state.pointer.y.devicePixels,
        };
        const pdfPoint = this.pdfApi.transformScreenPointToPdfPoint(pointerPos);
        if (state.pointer.stateChanged) {
            if (state.pointer.isDown) {
                const page = pdfPoint.isOnPage ? pdfPoint.pdfPoint.page : null;
                if (this.page === null && page) {
                    this.page = page;
                }
                if (typeof this.page === 'number' && this.page === page) {
                    const pdfPointRes = this.pdfApi.getClosestPointOnPdfByScreenPoint(pointerPos, this.page);
                    if (pdfPointRes) {
                        this.startLine(pointerPos, pdfPointRes);
                    }
                }
            }
        }
        if (state.pointer.positionChanged) {
            if (pdfPoint.isOnPage && (this.page === null || pdfPoint.pdfPoint.page === this.page)) {
                this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.CROSSHAIR);
            }
            else {
                this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.NOT_ALLOWED);
            }
        }
    }
    startLine(point, pdfPoint) {
        var _a;
        this.lines.push([pdfPoint]);
        this.pdfViewerCanvas.suspendCanvasEvents();
        this.drawing = true;
        if (this.context) {
            const { canvas } = this.context;
            canvas.addEventListener('pointermove', this.handlePointerMove);
            canvas.addEventListener('pointerup', this.handlePointerUp);
            canvas.addEventListener('pointercancel', this.handlePointerUp);
            this.drawLines();
            const ctx = this.context;
            ctx.save();
            ctx.strokeStyle = this.penColor;
            ctx.lineWidth = this.inkWidth * devicePixelRatio * ((_a = this.zoom) !== null && _a !== void 0 ? _a : 1);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.moveTo(point.x, point.y);
        }
    }
    endLine() {
        var _a, _b;
        this.drawing = false;
        this.pdfViewerCanvas.resumeCanvasEvents();
        (_a = this.context) === null || _a === void 0 ? void 0 : _a.restore();
        this.drawBoundingBox();
        (_b = this.toolbar) === null || _b === void 0 ? void 0 : _b.setLineCount(this.lines.length);
    }
    drawLines() {
        if (this.context) {
            const ctx = this.context;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const annotationOptions = this.options.annotation;
            ctx.save();
            ctx.strokeStyle = this.penColor;
            ctx.lineWidth = this.inkWidth * devicePixelRatio * this.zoom;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            this.lines.forEach((pointList) => {
                ctx.beginPath();
                const p1 = this.pdfApi.transformPdfPointToScreenPoint(pointList[0]);
                ctx.moveTo(p1.x, p1.y);
                for (let i = 0; i < pointList.length; i++) {
                    const p = this.pdfApi.transformPdfPointToScreenPoint(pointList[i]);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
            });
            ctx.restore();
        }
    }
    drawBoundingBox() {
        if (this.context && this.lines && this.lines.length > 0) {
            const pdfRect = {
                pdfX: 0,
                pdfY: 0,
                pdfW: 0,
                pdfH: 0,
                page: this.page ? this.page : 0,
            };
            let x1 = 1000000000;
            let x2 = 0;
            let y1 = 1000000000;
            let y2 = 0;
            this.lines.forEach((pointList) => {
                const line = [];
                for (let i = 0; i < pointList.length; i++) {
                    const p = pointList[i];
                    if (p.pdfX < x1) {
                        x1 = p.pdfX;
                    }
                    if (p.pdfX > x2) {
                        x2 = p.pdfX;
                    }
                    if (p.pdfY < y1) {
                        y1 = p.pdfY;
                    }
                    if (p.pdfY > y2) {
                        y2 = p.pdfY;
                    }
                }
            });
            pdfRect.pdfX = x1;
            pdfRect.pdfY = y1;
            pdfRect.pdfW = x2 - x1;
            pdfRect.pdfH = y2 - y1;
            const rect = this.pdfApi.transformPdfPageRectToScreenRect(pdfRect);
            const ctx = this.context;
            ctx.save();
            ctx.strokeStyle = this.options.viewer.general.textSelectionColor;
            ctx.lineWidth = 1 * devicePixelRatio;
            ctx.setLineDash([2 * devicePixelRatio, 3 * devicePixelRatio]);
            const p = this.inkWidth * devicePixelRatio;
            const p2 = p * 2;
            ctx.strokeRect(rect.x - p, rect.y - p, rect.w + p2, rect.h + p2);
            ctx.restore();
        }
    }
    setPenColor(color) {
        this.options.annotation.colors.inkColor = color;
        this.penColor = color;
        this.drawLines();
        this.drawBoundingBox();
    }
    setPenOpacity(opacity) {
        this.options.annotation.colors.inkOpacity = opacity;
        this.penOpacity = opacity;
        if (this.context) {
            this.context.canvas.style.opacity = `${opacity / 100}`;
        }
        this.drawLines();
        this.drawBoundingBox();
    }
    setPenSize(size) {
        this.inkWidth = size;
        this.options.annotation.inkWidth = size;
        this.drawLines();
        this.drawBoundingBox();
    }
    save() {
        this.createInkAnnotation();
        this.remove();
    }
    add() {
        this.createInkAnnotation();
        this.drawLines();
    }
    undo() {
        if (this.lines && this.lines.length > 0) {
            this.lines.pop();
            if (this.lines.length === 0) {
                this.page = null;
                this.boundingBox = null;
            }
            else {
                this.boundingBox = this.getBoundingBox();
            }
            if (this.toolbar) {
                this.toolbar.setLineCount(this.lines.length);
            }
            this.store.canvas.setCanvasInvalidated(true);
            this.drawLines();
            this.drawBoundingBox();
        }
    }
    createInkAnnotation() {
        const promise = new Promise((resolve, reject) => {
            if (this.pdfApi) {
                if (this.page && this.lines && this.lines.length > 0) {
                    const inkList = [];
                    let x1 = 1000000000;
                    let x2 = 0;
                    let y1 = 1000000000;
                    let y2 = 0;
                    this.lines.forEach((pointList) => {
                        const line = [];
                        for (let i = 0; i < pointList.length; i++) {
                            const p = pointList[i];
                            if (p.pdfX < x1) {
                                x1 = p.pdfX;
                            }
                            if (p.pdfX > x2) {
                                x2 = p.pdfX;
                            }
                            if (p.pdfY < y1) {
                                y1 = p.pdfY;
                            }
                            if (p.pdfY > y2) {
                                y2 = p.pdfY;
                            }
                            line.push(p.pdfX);
                            line.push(p.pdfY);
                        }
                        inkList.push(line);
                    });
                    const rgbaColor = new _common_Color__WEBPACK_IMPORTED_MODULE_4__.Color(this.options.annotation.colors.inkColor);
                    rgbaColor.setOpacity(this.options.annotation.colors.inkOpacity / 100);
                    const inkAnnotation = {
                        itemType: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.INK,
                        page: this.page,
                        pdfRect: {
                            pdfX: x1,
                            pdfY: y1,
                            pdfW: x2 - x1,
                            pdfH: y2 - y1,
                            page: this.page,
                        },
                        color: rgbaColor.toRgba(),
                        author: this.options.viewer.general.user,
                        border: {
                            style: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle.SOLID,
                            width: this.options.annotation.inkWidth,
                        },
                        inkList,
                    };
                    this.lines = [];
                    this.page = null;
                    this.boundingBox = null;
                    if (this.toolbar) {
                        this.toolbar.setLineCount(0);
                    }
                    this.pdfApi
                        .createItem(inkAnnotation)
                        .then((item) => {
                        this.onAnnotationCreated(item);
                        resolve();
                    })
                        .catch((error) => {
                        console.warn(error);
                    });
                }
                else {
                    resolve();
                }
            }
            else {
                reject();
            }
        });
        return promise;
    }
    getBoundingBox() {
        const pdfRect = {
            pdfX: 0,
            pdfY: 0,
            pdfW: 0,
            pdfH: 0,
            page: this.page ? this.page : 0,
        };
        if (this.lines && this.lines.length > 0) {
            let x1 = 1000000000;
            let x2 = 0;
            let y1 = 1000000000;
            let y2 = 0;
            this.lines.forEach((pointList) => {
                const line = [];
                for (let i = 0; i < pointList.length; i++) {
                    const p = pointList[i];
                    if (p.pdfX < x1) {
                        x1 = p.pdfX;
                    }
                    if (p.pdfX > x2) {
                        x2 = p.pdfX;
                    }
                    if (p.pdfY < y1) {
                        y1 = p.pdfY;
                    }
                    if (p.pdfY > y2) {
                        y2 = p.pdfY;
                    }
                }
            });
            pdfRect.pdfX = x1;
            pdfRect.pdfY = y1;
            pdfRect.pdfW = x2 - x1;
            pdfRect.pdfH = y2 - y1;
        }
        return pdfRect;
    }
}


/***/ }),

/***/ "./src/modules/ink-annotation/AddInkAnnotationToolbar.tsx":
/*!****************************************************************!*\
  !*** ./src/modules/ink-annotation/AddInkAnnotationToolbar.tsx ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddInkAnnotationToolbar": () => (/* binding */ createAddInkAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/StrokeWidthPicker */ "./src/common/StrokeWidthPicker.tsx");
/* harmony import */ var _common_RangeSlider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/RangeSlider */ "./src/common/RangeSlider.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");










const createAddInkAnnotationToolbar = (props, element) => {
    const state = {
        penColors: props.penColors,
        penWidths: props.penWidths,
        selectedPenColor: props.selectedPenColor,
        selectedPenSize: props.selectedPenSize,
        penOpacity: props.penOpacity,
        lineCount: 0,
    };
    const actions = {
        setPenColor: (color) => ($state) => {
            props.onPenColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedPenColor: color });
        },
        setPenSize: (width) => ($state) => {
            props.onPenSizeChanged(width);
            return Object.assign(Object.assign({}, $state), { selectedPenSize: width });
        },
        setPenOpacity: (opacity) => ($state) => {
            props.onPenOpacityChanged(opacity);
            return Object.assign(Object.assign({}, $state), { penOpacity: opacity });
        },
        setLineCount: (lineCount) => ($state) => (Object.assign(Object.assign({}, $state), { lineCount })),
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(AddInkAnnotationToolbar, null);
    const AddInkAnnotationToolbar = ({}) => ($state, $actions) => {
        const strokeWidths = $state.penWidths.filter((w) => w > 0);
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { allowWrap: true, alignCenter: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_9__.ColorPicker, { colors: $state.penColors, color: $state.selectedPenColor, icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.fillColor, allowRgba: false, mode: "buttons", onChange: $actions.setPenColor })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_RangeSlider__WEBPACK_IMPORTED_MODULE_8__.RangeSlider, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeDrawing.opacity'), min: 10, max: 100, step: 1, value: $state.penOpacity, text: `${$state.penOpacity}%`, icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.drop, onChange: $actions.setPenOpacity, className: "pwv-opacityslider" }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_7__.StrokeWidthPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeDrawing.strokeWidth'), noneStrokeText: '', strokeWidths: strokeWidths, value: $state.selectedPenSize, onChange: $actions.setPenSize })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__.ToolbarSeparator, null),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeDrawing.undo'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.eraser, onClick: props.onUndo, disabled: $state.lineCount < 1 }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeDrawing.addNew'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.addLayer, onClick: props.onAdd, disabled: $state.lineCount < 1 })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__.ToolbarSeparator, null),
                $state.lineCount < 1 ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.close, onClick: props.onCancel })) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.ok, onClick: props.onSave })))));
    };
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/ink-annotation/EditInkAnnotationLayer.ts":
/*!**************************************************************!*\
  !*** ./src/modules/ink-annotation/EditInkAnnotationLayer.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditInkAnnotationLayer": () => (/* binding */ EditInkAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _EditInkAnnotationToolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditInkAnnotationToolbar */ "./src/modules/ink-annotation/EditInkAnnotationToolbar.tsx");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");




const moduleLayerName = 'EditInkAnnotation';
class EditInkAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.inkAnnotation = null;
        this.context = null;
        this.penColors = [];
        this.penWidths = [];
        this.toolbar = null;
        this.updatePending = false;
        this.unsavedChanges = false;
    }
    onCreate(annotationId) {
        var _a;
        this.inkAnnotation = this.pdfApi.getItem(annotationId);
        this.setPenColor = this.setPenColor.bind(this);
        this.setPenSize = this.setPenSize.bind(this);
        this.setPenOpacity = this.setPenOpacity.bind(this);
        this.close = this.close.bind(this);
        const annotationOptions = this.options.annotation;
        this.penColors = annotationOptions.colors.foregroundColors;
        this.penWidths = annotationOptions.strokeWidths;
        this.context = this.createCanvas();
        const color = new _common_Color__WEBPACK_IMPORTED_MODULE_3__.Color(this.inkAnnotation.color || annotationOptions.colors.inkColor);
        const penSize = ((_a = this.inkAnnotation) === null || _a === void 0 ? void 0 : _a.border.width) || annotationOptions.inkWidth;
        const toolbarElement = this.module.toolbarElement;
        this.toolbar = (0,_EditInkAnnotationToolbar__WEBPACK_IMPORTED_MODULE_2__.createEditInkAnnotationToolbar)({
            penColors: this.penColors,
            penWidths: this.penWidths,
            selectedPenColor: color.toHexRgb(),
            selectedPenSize: penSize,
            penOpacity: color.a * 100,
            onPenColorChanged: this.setPenColor,
            onPenSizeChanged: this.setPenSize,
            onPenOpacityChanged: this.setPenOpacity,
            onCancel: this.remove,
        }, toolbarElement);
        this.store.viewer.beginModule(moduleLayerName);
    }
    onSave() {
        return new Promise((resolve) => resolve);
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        var _a;
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (state.pointer.action === 'click' || state.pointer.action === 'dblclick') {
            const inkAnnotation = (_a = this.pdfApi
                .getAnnotationsOnPoint({
                x: state.pointer.x.devicePixels,
                y: state.pointer.y.devicePixels,
            })) === null || _a === void 0 ? void 0 : _a.find((a) => this.inkAnnotation && a.id === this.inkAnnotation.id);
            if (!inkAnnotation) {
                this.close();
                return;
            }
        }
        if (this.context && this.inkAnnotation) {
            const ctx = this.context;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const rect = this.pdfApi.transformPdfPageRectToScreenRect(this.inkAnnotation.pdfRect);
            const lineWidth = 2 * devicePixelRatio;
            ctx.save();
            ctx.strokeStyle = this.options.viewer.general.textSelectionColor;
            ctx.lineWidth = lineWidth;
            ctx.setLineDash([lineWidth, lineWidth]);
            ctx.strokeRect(rect.x - lineWidth, rect.y - lineWidth, rect.w + 2 * lineWidth, rect.h + 2 * lineWidth);
            ctx.restore();
        }
    }
    close() {
        this.remove();
    }
    setPenColor(color) {
        if (this.inkAnnotation && this.inkAnnotation.color) {
            const newColor = new _common_Color__WEBPACK_IMPORTED_MODULE_3__.Color(color);
            const currentColor = new _common_Color__WEBPACK_IMPORTED_MODULE_3__.Color(this.inkAnnotation.color);
            newColor.setOpacity(currentColor.a);
            this.inkAnnotation.color = newColor.toHexRgba();
            this.updateInkAnnotation();
        }
    }
    setPenSize(size) {
        if (this.inkAnnotation) {
            this.inkAnnotation.border = {
                style: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle.SOLID,
                width: size,
            };
            this.updateInkAnnotation();
        }
    }
    setPenOpacity(opacity) {
        if (this.inkAnnotation && this.inkAnnotation.color) {
            const rgbaColor = new _common_Color__WEBPACK_IMPORTED_MODULE_3__.Color(this.inkAnnotation.color);
            rgbaColor.setOpacity(opacity / 100);
            this.inkAnnotation.color = rgbaColor.toHexRgba();
            this.updateInkAnnotation();
        }
    }
    updateInkAnnotation() {
        if (this.pdfApi && this.inkAnnotation) {
            if (this.updatePending) {
                this.unsavedChanges = true;
            }
            else {
                this.updatePending = true;
                this.pdfApi
                    .updateItem(this.inkAnnotation)
                    .then((item) => {
                    this.updatePending = false;
                    if (this.unsavedChanges) {
                        this.unsavedChanges = false;
                        this.updateInkAnnotation();
                    }
                })
                    .catch((error) => {
                    console.warn(error);
                });
            }
        }
    }
}


/***/ }),

/***/ "./src/modules/ink-annotation/EditInkAnnotationToolbar.tsx":
/*!*****************************************************************!*\
  !*** ./src/modules/ink-annotation/EditInkAnnotationToolbar.tsx ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEditInkAnnotationToolbar": () => (/* binding */ createEditInkAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/StrokeWidthPicker */ "./src/common/StrokeWidthPicker.tsx");
/* harmony import */ var _common_RangeSlider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/RangeSlider */ "./src/common/RangeSlider.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");










const createEditInkAnnotationToolbar = (props, element) => {
    const state = {
        penColors: props.penColors,
        penWidths: props.penWidths,
        selectedPenColor: props.selectedPenColor,
        selectedPenSize: props.selectedPenSize,
        penOpacity: props.penOpacity,
    };
    const actions = {
        setPenColor: (color) => ($state) => {
            props.onPenColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedPenColor: color });
        },
        setPenSize: (width) => ($state) => {
            props.onPenSizeChanged(width);
            return Object.assign(Object.assign({}, $state), { selectedPenSize: width });
        },
        setPenOpacity: (opacity) => ($state) => {
            props.onPenOpacityChanged(opacity);
            return Object.assign(Object.assign({}, $state), { penOpacity: opacity });
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(EditInkAnnotationToolbar, null);
    const EditInkAnnotationToolbar = ({}) => ($state, $actions) => {
        const strokeWidths = $state.penWidths.filter((w) => w > 0);
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { allowWrap: true, alignCenter: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_9__.ColorPicker, { colors: $state.penColors, color: $state.selectedPenColor, icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.fillColor, allowRgba: false, mode: "buttons", onChange: $actions.setPenColor })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_RangeSlider__WEBPACK_IMPORTED_MODULE_8__.RangeSlider, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeDrawing.opacity'), min: 10, max: 100, step: 1, value: $state.penOpacity, text: `${Math.round($state.penOpacity)}%`, icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.drop, onChange: $actions.setPenOpacity, className: "pwv-opacityslider" }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_7__.StrokeWidthPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotFreeDrawing.strokeWidth'), noneStrokeText: '', strokeWidths: strokeWidths, value: $state.selectedPenSize, onChange: $actions.setPenSize })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__.ToolbarSeparator, null),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.close, onClick: props.onCancel }))));
    };
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/ink-annotation/InkAnnotationModule.ts":
/*!***********************************************************!*\
  !*** ./src/modules/ink-annotation/InkAnnotationModule.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InkAnnotationModule": () => (/* binding */ InkAnnotationModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _AddInkAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddInkAnnotationLayer */ "./src/modules/ink-annotation/AddInkAnnotationLayer.ts");
/* harmony import */ var _EditInkAnnotationLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditInkAnnotationLayer */ "./src/modules/ink-annotation/EditInkAnnotationLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");






class InkAnnotationModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.toolbarElement = null;
        this.name = InkAnnotationModule.moduleInfo.name;
        this.activate = this.activate.bind(this);
        this.onEdit = this.onEdit.bind(this);
    }
    onRegister() {
        this.toolbarElement = document.createElement('div');
        return {
            toolbar: this.toolbarElement,
            contextbar: {
                itemTypes: [_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.INK],
                icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.edit,
                tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__.translationManager.getText('annotInk.edit'),
                onCmd: (annotationId) => {
                    this.onEdit(annotationId);
                },
            },
        };
    }
    activate() {
        if (!this.canvasLayers['add']) {
            this.createCanvasLayer('add', _AddInkAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__.AddInkAnnotationLayer);
        }
        else {
            this.removeCanvasLayer('add');
        }
    }
    onEdit(annotationId) {
        this.createCanvasLayer('edit', _EditInkAnnotationLayer__WEBPACK_IMPORTED_MODULE_2__.EditInkAnnotationLayer, annotationId);
    }
}
InkAnnotationModule.moduleInfo = {
    name: 'InkAnnotationModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Tool,
    requiredFeatures: {
        annotate: true,
        fillFormFields: false,
    },
    translationKey: 'annotFreeDrawing.add',
    icon: 'pencil',
};


/***/ }),

/***/ "./src/modules/popup/Popup.tsx":
/*!*************************************!*\
  !*** ./src/modules/popup/Popup.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopupView": () => (/* binding */ createPopupView)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/DragMoveHandler */ "./src/common/DragMoveHandler.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");











const createPopupView = (props, element) => {
    const state = {
        selectedPopup: null,
        openPopups: [],
        maxPopupWidth: props.maxPopupWidth,
        maxPopupHeight: props.maxPopupHeight,
        minPopupWidth: 260,
        minPopupHeight: 200,
        currentUser: props.currentUser,
        hideSubject: props.hideSubject,
        activeContent: null,
        activeSubject: null,
        stateChanged: false,
        clearFocus: false,
    };
    const actions = {
        getState: () => ($state) => $state,
        updateOpenPopups: (openPopups) => ($state) => {
            openPopups.forEach((popup) => {
                const oldPopup = $state.openPopups.find((op) => op.id === popup.id);
                if (oldPopup) {
                    popup.selected = oldPopup.selected;
                    popup.positionCalculated = oldPopup.positionCalculated;
                }
            });
            return Object.assign(Object.assign({}, $state), { openPopups });
        },
        stateChanged: (hasChanged) => ($state) => {
            return Object.assign(Object.assign({}, $state), { stateChanged: hasChanged });
        },
        setPositionCalculated: (id) => ($state) => {
            const popup = $state.openPopups.find((p) => p.id === id);
            if (popup) {
                popup.positionCalculated = true;
            }
            return Object.assign({}, $state);
        },
        selectPopup: (id) => ($state) => {
            const openPopups = $state.openPopups.map((p) => (Object.assign(Object.assign({}, p), { selected: p.id === id })));
            return Object.assign(Object.assign({}, $state), { openPopups, activeContent: id === $state.selectedPopup ? $state.activeContent : null, activeSubject: id === $state.selectedPopup ? $state.activeSubject : null, selectedPopup: id });
        },
        updateSubjectAndContent: (id) => ($state) => {
            const subject = document.getElementById('pwv-popup-subject-' + id)
                .value;
            const content = document.getElementById('pwv-popup-content-' + id)
                .value;
            return Object.assign(Object.assign({}, $state), { activeContent: content, activeSubject: subject });
        },
        setFocus: (id) => ($state) => {
            const textArea = document.getElementById('pwv-popup-content-' + id);
            if (textArea) {
                textArea.focus();
            }
            return Object.assign(Object.assign({}, $state), { clearFocus: document.activeElement === textArea });
        },
        deselectPopup: () => ($state) => {
            return Object.assign(Object.assign({}, $state), { selectedPopup: null });
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(OpenPopups, null);
    const OpenPopups = ({}) => ($state, $actions) => {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, $state.openPopups.map((popup) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(Popup, { popup: Object.assign(Object.assign({}, popup), { selected: popup.id === $state.selectedPopup }), colorPalette: popup.colorPalette, hideSubject: props.hideSubject, allowLockAnnotations: props.allowLockAnnotations, allowEditLockedAnnotations: props.allowEditLockedAnnotations, close: props.onClose, remove: props.onDelete, select: props.onSelect, toggleLock: props.onLock, updatePosition: (payload) => {
                props.onUpdatePosition(payload.id, payload.x, payload.y);
            }, updateSize: (payload) => {
                props.onUpdateSize(payload.id, payload.w, payload.h);
            }, updateColor: (payload) => {
                props.onUpdateColor(payload.id, payload.color);
            } })))));
    };
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};
const Popup = ({ popup, colorPalette, hideSubject, allowLockAnnotations, allowEditLockedAnnotations, updateColor, close, select, remove, toggleLock, updatePosition, updateSize, }) => ($state, $actions) => {
    const styles = {
        backgroundColor: popup.color,
        width: popup.cssWidth < $state.minPopupWidth ? $state.minPopupWidth + 'px' : popup.cssWidth + 'px',
        height: popup.cssHeight < $state.minPopupHeight
            ? $state.minPopupHeight + 'px'
            : popup.cssHeight + 'px',
    };
    let colorString;
    if (popup.color != null) {
        const color = new _common_Color__WEBPACK_IMPORTED_MODULE_10__.Color(popup.color);
        styles.backgroundColor = color.toRgb();
        if (color.isDark()) {
            colorString = 'rgba(255, 255, 255, 0.9)';
        }
        else {
            colorString = 'rgba(0, 0, 0, 0.9)';
        }
    }
    const headerStyles = {
        color: colorString,
    };
    if (!popup.positionCalculated) {
        styles.display = 'none';
    }
    const isReadOnly = popup.isReadOnly();
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_7__.classNames)('pwv-popup', {
            'pwv-popup-view-only': isReadOnly,
            'pwv-popup-selected': popup.selected,
        }), key: popup.id, style: styles, "data-id": popup.id },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { onclick: (e) => {
                if (!e.openDropdown) {
                    window.dispatchEvent(new Event('click', e));
                }
                if (!popup.selected) {
                    select(popup.id);
                }
            }, onchange: (e) => {
                $actions.stateChanged(true);
            } },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-popup-header" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-popup-header-info", style: headerStyles },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-popup-header-author" }, popup.author),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-popup-header-modified" }, popup.modificationDate)),
                isReadOnly ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { onClick: (e) => {
                                e.stopPropagation();
                                if (!popup.selected) {
                                    select(popup.id);
                                }
                                close();
                            }, icon: _common_Icon__WEBPACK_IMPORTED_MODULE_5__.icons.close })))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotPopup.delete'), icon: _common_Icon__WEBPACK_IMPORTED_MODULE_5__.icons["delete"], onClick: () => {
                                remove(popup.id);
                            }, disabled: popup.isLocked && !allowEditLockedAnnotations }),
                        allowLockAnnotations && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText(popup.isLocked ? 'annotPopup.unlock' : 'annotPopup.lock'), onClick: (e) => {
                                e.stopPropagation();
                                if (!popup.selected) {
                                    select(popup.id);
                                }
                                toggleLock(popup.id);
                            }, icon: popup.isLocked ? _common_Icon__WEBPACK_IMPORTED_MODULE_5__.icons.lock : _common_Icon__WEBPACK_IMPORTED_MODULE_5__.icons.unlock })),
                        popup.itemType !== _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_9__.PdfItemType.STAMP && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotPopup.color'), colors: colorPalette, icon: _common_Icon__WEBPACK_IMPORTED_MODULE_5__.icons.fillColor, color: popup.color || 'transparent', onChange: (color) => {
                                updateColor({
                                    id: popup.id,
                                    color,
                                });
                            }, disabled: popup.isLocked && !allowEditLockedAnnotations }))),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { onClick: (e) => {
                                e.stopPropagation();
                                if (!popup.selected) {
                                    select(popup.id);
                                }
                                if (!popup.isLocked || allowEditLockedAnnotations) {
                                    $actions.updateSubjectAndContent(popup.id);
                                }
                                close();
                            }, icon: _common_Icon__WEBPACK_IMPORTED_MODULE_5__.icons.close }))))),
            isReadOnly ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-popup-view-only-content" },
                !hideSubject && popup.subject && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h4", null, popup.subject),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, popup.content))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                hideSubject ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { id: 'pwv-popup-subject-' + popup.id, type: "hidden", value: $state.selectedPopup === popup.id
                        ? $state.activeSubject
                            ? $state.activeSubject
                            : popup.subject
                        : popup.subject })) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-popup-subject" }, !popup.isLocked || allowEditLockedAnnotations ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { id: 'pwv-popup-subject-' + popup.id, placeholder: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotPopup.subjectPlaceholder'), onchange: () => {
                        $actions.updateSubjectAndContent(popup.id);
                    }, value: $state.selectedPopup === popup.id
                        ? $state.activeSubject
                            ? $state.activeSubject
                            : popup.subject
                        : popup.subject })) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { id: 'pwv-popup-subject-' + popup.id }, popup.subject)))),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_7__.classNames)('pwv-popup-content', {
                        'pwv-popup-content-no-subject': hideSubject,
                    }) }, !popup.isLocked || allowEditLockedAnnotations ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("textarea", { placeholder: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotPopup.contentPlaceholder'), id: 'pwv-popup-content-' + popup.id, onchange: () => {
                        $actions.updateSubjectAndContent(popup.id);
                    } }, $state.selectedPopup === popup.id
                    ? $state.activeContent
                        ? $state.activeContent
                        : popup.content
                    : popup.content)) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { id: 'pwv-popup-content-' + popup.id }, popup.content)))))),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-popup-draghandle" }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-popup-resizer", oncreate: (element) => {
                    PopupComponent.create(popup.id, element, $state.minPopupWidth, $state.minPopupHeight, $state.maxPopupWidth, $state.maxPopupHeight, updatePosition, updateSize, select);
                }, onremove: (element, done) => {
                    PopupComponent.remove(element);
                    done();
                } }))));
};
class PopupComponent {
    constructor(id, resizeHandle, minPopupWidth, minPopupHeight, maxPopupWidth, maxPopupHeight, updatePosition, updateSize, select) {
        this.cancelContentEvents = true;
        this.dragOffsetX = 0;
        this.dragOffsetY = 0;
        this.containerOffsetX = 0;
        this.containerOffsetY = 0;
        this.id = id;
        this.resizeHandle = resizeHandle;
        const parent = resizeHandle.parentElement;
        this.dragHandle = parent.children.item(0);
        this.element = parent.parentElement;
        this.minPopupWidth = 260;
        this.minPopupHeight = 200;
        this.maxPopupWidth = maxPopupWidth > this.minPopupWidth ? maxPopupWidth : this.minPopupWidth;
        this.maxPopupHeight =
            maxPopupHeight > this.minPopupHeight ? maxPopupHeight : this.minPopupHeight;
        this.updatePosition = updatePosition;
        this.updateSize = updateSize;
        this.select = select;
        this.cancelEvent = this.cancelEvent.bind(this);
        this.startMove = this.startMove.bind(this);
        this.moving = this.moving.bind(this);
        this.endMove = this.endMove.bind(this);
        this.onSelect = this.onSelect.bind(this);
        this.startResize = this.startResize.bind(this);
        this.resizing = this.resizing.bind(this);
        this.endResize = this.endResize.bind(this);
        this.handleMouseWheel = this.handleMouseWheel.bind(this);
        new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_8__.DragMoveHandler(this.dragHandle, this.startMove, this.moving, this.endMove, this.onSelect);
        new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_8__.DragMoveHandler(this.resizeHandle, this.startResize, this.resizing, this.endResize);
        this.element.addEventListener('mousewheel', this.handleMouseWheel, { passive: true });
        const contentElement = this.element.firstChild;
        contentElement.addEventListener('onclick', this.cancelEvent, false);
        contentElement.addEventListener('keydown', this.cancelEvent, false);
        contentElement.addEventListener('mousedown', this.cancelEvent, false);
        contentElement.addEventListener('mousemove', this.cancelEvent, false);
        contentElement.addEventListener('mouseup', this.cancelEvent, false);
        contentElement.addEventListener('touchstart', this.cancelEvent, { passive: true });
        contentElement.addEventListener('touchmove', this.cancelEvent, { passive: true });
        contentElement.addEventListener('touchend', this.cancelEvent, { passive: true });
    }
    static create(id, resizeHandle, minPopupWidth, minPopupHeight, maxPopupWidth, maxPopupHeight, updatePosition, updateSize, select) {
        ;
        resizeHandle.parentElement.popup = new PopupComponent(id, resizeHandle, minPopupWidth, minPopupHeight, maxPopupWidth, maxPopupHeight, updatePosition, updateSize, select);
    }
    static remove(resizeHandle) {
        ;
        resizeHandle.parentElement.popup.unmount()(resizeHandle.parentElement).popup =
            null;
    }
    unmount() {
        this.element.removeEventListener('mousewheel', this.handleMouseWheel);
    }
    cancelEvent(e) {
        if (this.cancelContentEvents) {
            if (!(e.type === 'mousemove' && e.buttons === 0)) {
                e.cancelBubble = true;
                e.stopPropagation();
            }
        }
    }
    onSelect() {
        this.select(this.id);
    }
    startResize(e) {
        this.cancelContentEvents = false;
        this.element.classList.add('pwv-popup-resizing');
        this.onSelect();
    }
    resizing(e) {
        const rect = this.element.getBoundingClientRect();
        let width = e.clientX - rect.left;
        let height = e.clientY - rect.top;
        width =
            width < this.minPopupWidth
                ? this.minPopupWidth
                : width > this.maxPopupWidth
                    ? this.maxPopupWidth
                    : width;
        height =
            height < this.minPopupHeight
                ? this.minPopupHeight
                : height > this.maxPopupHeight
                    ? this.maxPopupHeight
                    : height;
        this.element.style.width = width + 'px';
        this.element.style.height = height + 'px';
        const popupRect = {
            x: parseInt(this.element.style.left, undefined),
            y: parseInt(this.element.style.top, undefined),
            w: width,
            h: height,
        };
        const evtDetail = {
            annotationId: this.id,
            popupRect,
            color: this.element.style.backgroundColor,
        };
        window.dispatchEvent(new CustomEvent('pdfwebviewer.PopupMoved', { detail: evtDetail }));
    }
    endResize(e) {
        if (e.moved) {
            this.updateSize({
                id: this.id,
                w: this.element.clientWidth,
                h: this.element.clientHeight,
            });
        }
        this.cancelContentEvents = true;
        this.element.classList.remove('pwv-popup-resizing');
    }
    startMove(e) {
        const elementRect = this.element.getBoundingClientRect();
        const offsetParent = this.element.offsetParent;
        const offsetParentRect = offsetParent.getBoundingClientRect();
        this.dragOffsetX = e.clientX - elementRect.left;
        this.dragOffsetY = e.clientY - elementRect.top;
        this.containerOffsetX = offsetParentRect.left;
        this.containerOffsetY = offsetParentRect.top;
        this.cancelContentEvents = false;
        this.element.classList.add('pwv-popup-moving');
        this.onSelect();
    }
    moving(e) {
        const popupRect = {
            x: e.clientX - this.containerOffsetX - this.dragOffsetX,
            y: e.clientY - this.containerOffsetY - this.dragOffsetY,
            w: parseInt(this.element.style.width, undefined),
            h: parseInt(this.element.style.height, undefined),
        };
        this.element.style.top = popupRect.y + 'px';
        this.element.style.left = popupRect.x + 'px';
        const evtDetail = {
            annotationId: this.id,
            popupRect,
            color: this.element.style.backgroundColor,
        };
        window.dispatchEvent(new CustomEvent('pdfwebviewer.PopupMoved', { detail: evtDetail }));
    }
    endMove(e) {
        if (e.moved) {
            this.updatePosition({
                id: this.id,
                x: this.element.offsetLeft,
                y: this.element.offsetTop,
            });
        }
        this.cancelContentEvents = true;
        this.element.classList.remove('pwv-popup-moving');
    }
    handleMouseWheel(e) {
        if (this.element.classList.contains('pwv-popup-selected')) {
            e.stopPropagation();
        }
    }
}


/***/ }),

/***/ "./src/modules/popup/PopupLayer.ts":
/*!*****************************************!*\
  !*** ./src/modules/popup/PopupLayer.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PopupLayer": () => (/* binding */ PopupLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _Popup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Popup */ "./src/modules/popup/Popup.tsx");
/* harmony import */ var _pdf_viewer_canvas_state_annotations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/annotations */ "./src/pdf-viewer-canvas/state/annotations.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_view_layers_canvasShapes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../pdf-viewer-canvas/view-layers/canvasShapes */ "./src/pdf-viewer-canvas/view-layers/canvasShapes.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");
/* harmony import */ var _common_Tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/Tools */ "./src/common/Tools.ts");
/* harmony import */ var _custom_history__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../custom/history */ "./src/custom/history.ts");









class PopupLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.popupView = null;
        this.context = null;
        this.maxPopupWidth = window.screen.availWidth < 570 ? 280 : 480;
        this.maxPopupHeight = 320;
        this.minPopupWidth = 260;
        this.minPopupHeight = 200;
        this.zoom = 0;
        this.screenToPdfScale = 0;
    }
    onCreate() {
        this.drawPopupRelation = this.drawPopupRelation.bind(this);
        this.popupMoved = this.popupMoved.bind(this);
        this.selectPopup = this.selectPopup.bind(this);
        this.deselectPopup = this.deselectPopup.bind(this);
        this.openPopup = this.openPopup.bind(this);
        this.closePopup = this.closePopup.bind(this);
        this.deletePopup = this.deletePopup.bind(this);
        this.toggleAnnotationLock = this.toggleAnnotationLock.bind(this);
        this.updateSelectedPopupContent = this.updateSelectedPopupContent.bind(this);
        this.updatePopupPosition = this.updatePopupPosition.bind(this);
        this.updatePopupSize = this.updatePopupSize.bind(this);
        this.updatePopupColor = this.updatePopupColor.bind(this);
        this.context = this.createCanvas();
        this.createPopupView();
        window.addEventListener('pdfwebviewer.PopupMoved', this.popupMoved, false);
    }
    onRemove() { }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            if (this.popupView) {
                const state = this.popupView.getState();
                if (state.stateChanged) {
                    this.updateSelectedPopupContent(true).then(() => {
                        resolve();
                    });
                }
                else {
                    resolve();
                }
            }
        });
        return promise;
    }
    render(timestamp, state) {
        if (this.pdfApi && this.popupView && this.popupViewElement) {
            if (state.document.zoomChanged && state.document.zoom !== this.zoom) {
                this.zoom = state.document.zoom;
                this.screenToPdfScale = this.pdfApi.transformPdfLengthToScreenLength(100) / 100 / this.zoom;
            }
            if (state.annotations.openPopupChanged ||
                state.document.firstVisiblePageChanged ||
                state.document.lastVisiblePageChanged ||
                state.viewer.modeChanged) {
                this.updateOpenPopupList(state);
            }
            if (state.viewer.popupFocus) {
                this.popupView.setFocus(state.viewer.popupFocus);
            }
            if (this.popupView.getState().clearFocus) {
                this.store.viewer.clearPopupFocus();
            }
            if (state.viewer.selectedPopupChanged) {
                const selectedPopup = this.popupView.getState().selectedPopup;
                if (state.viewer.selectedPopupId) {
                    if (selectedPopup !== state.viewer.selectedPopupId) {
                        this.popupView.selectPopup(state.viewer.selectedPopupId);
                    }
                }
            }
            const viewerMode = state.viewer.mode;
            if (viewerMode === _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.ViewerMode.POPUP_SELECTED) {
                this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.CursorStyle.DEFAULT);
            }
            const { openPopups, selectedPopup } = this.popupView.getState();
            const popupsVisible = viewerMode === _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.ViewerMode.DEFAULT || viewerMode === _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.ViewerMode.POPUP_SELECTED;
            if (state.viewer.modeChanged) {
                if (popupsVisible) {
                    this.popupViewElement.style.display = 'block';
                }
                else {
                    this.popupViewElement.style.display = 'none';
                    const ctx = this.context;
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    if (selectedPopup) {
                        this.updateSelectedPopupContent(true);
                    }
                }
            }
            if (viewerMode === _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.ViewerMode.POPUP_SELECTED && state.pointer.action === 'click') {
                this.deselectPopup();
            }
            const updatePopupPosition = state.canvas.canvasInvalidated || openPopups.find((p) => !p.positionCalculated);
            if (openPopups.length > 0 && updatePopupPosition) {
                const popupElements = this.popupViewElement.querySelectorAll('.pwv-popup');
                const canvasWidth = state.canvas.width.cssPixels;
                const canvasHeight = state.canvas.height.cssPixels;
                const zoom = state.document.zoom;
                for (let i = 0; i < popupElements.length; i++) {
                    const popupElement = popupElements[i];
                    if (!popupElement.classList.contains('pwv-popup-moving')) {
                        const id = popupElement.dataset.id;
                        const popup = openPopups.find((p) => p.id.toString() === id);
                        if (popup) {
                            const screenRect = this.pdfApi.transformPdfPageRectToScreenRect(popup.pdfRect);
                            let x = screenRect.x / devicePixelRatio;
                            let y = screenRect.y / devicePixelRatio;
                            const w = parseInt(popupElement.style.width, undefined);
                            const h = parseInt(popupElement.style.height, undefined);
                            const padding = 8;
                            if (x < padding) {
                                x = padding;
                            }
                            else if (x + w + padding * 2 > canvasWidth) {
                                x = canvasWidth - (w + padding * 2);
                            }
                            if (y < padding) {
                                y = padding;
                            }
                            else if (y + h + padding * 2 > canvasHeight) {
                                y = canvasHeight - (h + padding * 2);
                            }
                            popupElement.style.top = `${y}px`;
                            popupElement.style.left = `${x}px`;
                            if (!popup.positionCalculated) {
                                this.popupView.setPositionCalculated(popup.id);
                            }
                        }
                    }
                }
            }
            if ((state.viewer.mode === _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.ViewerMode.POPUP_SELECTED ||
                state.viewer.mode === _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.ViewerMode.DEFAULT) &&
                (state.viewer.selectedPopupChanged ||
                    state.canvas.canvasInvalidated ||
                    state.pointer.positionChanged ||
                    state.annotations.openPopupChanged)) {
                const ctx = this.context;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const scale = state.canvas.pixelRatio * state.document.zoom;
                if (viewerMode !== _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.ViewerMode.POPUP_SELECTED) {
                    const popups = (0,_pdf_viewer_canvas_state_annotations__WEBPACK_IMPORTED_MODULE_2__.getPopups)(state.annotations, state.document.firstVisiblePage, state.document.lastVisiblePage);
                    if (popups === null) {
                        return;
                    }
                    for (let i = 0; i < popups.length; i++) {
                        const popup = popups[i];
                        if (popup.itemType !== _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.TEXT) {
                            let pos;
                            pos = this.pdfApi.transformPdfPageRectToScreenRect(popup.pdfRect);
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            const r = 12 * scale;
                            const posX = pos.x + r / 2;
                            const posY = pos.y - r;
                            ctx.arc(posX, posY, r, 0, 2 * Math.PI);
                            if (ctx.isPointInPath(state.pointer.x.devicePixels, state.pointer.y.devicePixels)) {
                                this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_5__.CursorStyle.POINTER);
                                ctx.globalAlpha = 0.15;
                                ctx.fillStyle = this.options.viewer.general.textSelectionColor;
                                ctx.fill();
                                ctx.globalAlpha = 1;
                                if (state.pointer.action === 'click') {
                                    this.openPopup(popup.id);
                                }
                            }
                            (0,_pdf_viewer_canvas_view_layers_canvasShapes__WEBPACK_IMPORTED_MODULE_4__.renderPopupMarker)(ctx, scale, popup.color || this.options.annotation.colors.defaultHighlightColor, { x: posX, y: posY });
                        }
                    }
                }
                if (openPopups.length > 0) {
                    const popupElements = this.popupViewElement.querySelectorAll('.pwv-popup:hover, .pwv-popup.pwv-popup-selected');
                    for (let i = 0; i < popupElements.length; i++) {
                        const popupElement = popupElements[i];
                        const id = popupElement.dataset.id ? parseInt(popupElement.dataset.id, undefined) : -1;
                        this.drawPopupRelation(ctx, id, {
                            x: popupElement.offsetLeft,
                            y: popupElement.offsetTop,
                            w: popupElement.offsetWidth,
                            h: popupElement.offsetHeight,
                        }, popupElement.style.backgroundColor, id === state.viewer.selectedPopupId);
                    }
                }
            }
        }
    }
    updateOpenPopupList(state) {
        if (this.popupView) {
            const openPopups = (0,_pdf_viewer_canvas_state_annotations__WEBPACK_IMPORTED_MODULE_2__.getOpenPopups)(state.annotations, state.document.firstVisiblePage, state.document.lastVisiblePage);
            const zoom = state.document.zoom;
            const popups = openPopups.map((an) => {
                const width = this.pdfApi.transformPdfLengthToScreenLength(an.popup.pdfRect.pdfW) / zoom;
                const height = this.pdfApi.transformPdfLengthToScreenLength(an.popup.pdfRect.pdfH) / zoom;
                return {
                    id: an.id,
                    colorPalette: (0,_common_Tools__WEBPACK_IMPORTED_MODULE_7__.getColorPalette)(an.itemType, this.options),
                    content: an.content,
                    subject: an.subject ? an.subject : null,
                    modificationDate: an.modificationDate,
                    author: an.author,
                    color: an.color,
                    itemType: an.itemType,
                    isLocked: an.isLocked(),
                    selected: false,
                    positionCalculated: false,
                    pdfRect: an.popup.pdfRect,
                    cssWidth: width < this.maxPopupWidth ? width : this.maxPopupWidth,
                    cssHeight: height < this.maxPopupHeight ? height : this.maxPopupHeight,
                    behaviors: an.behaviors,
                    isReadOnly: an.isReadOnly,
                };
            });
            this.popupView.updateOpenPopups(popups);
        }
    }
    drawPopupRelation(ctx, annotationId, popupRect, color, selected) {
        const annotation = this.pdfApi.getItem(annotationId);
        if (annotation) {
            const annotationRect = this.pdfApi.transformPdfPageRectToScreenRect(annotation.pdfRect);
            const popupX1 = popupRect.x * devicePixelRatio;
            const popupX2 = popupX1 + popupRect.w * devicePixelRatio;
            const popupXc = popupX1 + (popupRect.w / 2) * devicePixelRatio;
            const popupY1 = popupRect.y * devicePixelRatio;
            const popupY2 = popupY1 + popupRect.h * devicePixelRatio;
            const popupYc = popupY1 + (popupRect.h / 2) * devicePixelRatio;
            const annotationX1 = annotationRect.x;
            const annotationX2 = annotationX1 + annotationRect.w;
            const annotationY1 = annotationRect.y;
            const annotationY2 = annotationY1 + annotationRect.h;
            let popupRelX = popupX1;
            let popupRelY = popupY1;
            let annotationRelX = annotationX1;
            let annotationRelY = annotationY1;
            if (popupX2 <= annotationX1) {
                popupRelX = popupX2;
                annotationRelX = annotationX1;
            }
            if (popupX1 >= annotationX2) {
                popupRelX = popupX1;
                annotationRelX = annotationX2;
            }
            if (popupY2 <= annotationY1) {
                popupRelY = popupY2;
                annotationRelY = annotationY1;
            }
            if (popupY1 >= annotationY2) {
                popupRelY = popupY1;
                annotationRelY = annotationY2;
            }
            if (popupX2 >= annotationX1 && popupX1 <= annotationX2) {
                const x = popupXc < annotationX1 ? annotationX1 : popupXc > annotationX2 ? annotationX2 : popupXc;
                popupRelX = x;
                annotationRelX = x;
            }
            if (popupY2 >= annotationY1 && popupY1 <= annotationY2) {
                const y = popupYc < annotationY1 ? annotationY1 : popupYc > annotationY2 ? annotationY2 : popupYc;
                popupRelY = y;
                annotationRelY = y;
            }
            ctx.save();
            if (!(popupRelX === 0 && popupRelY === 0)) {
                if (color) {
                    const rgbColor = new _common_Color__WEBPACK_IMPORTED_MODULE_6__.Color(color);
                    rgbColor.darken(20);
                    if (!selected) {
                        rgbColor.setOpacity(0.8);
                    }
                    ctx.strokeStyle = rgbColor.toRgba();
                    ctx.fillStyle = rgbColor.toRgba();
                }
                ctx.lineWidth = 2 * window.devicePixelRatio;
                if (!selected) {
                    ctx.setLineDash([ctx.lineWidth]);
                }
                ctx.beginPath();
                ctx.moveTo(annotationRelX, annotationRelY);
                ctx.lineTo(popupRelX, popupRelY);
                ctx.stroke();
                ctx.strokeRect(annotationX1, annotationY1, annotationRect.w, annotationRect.h);
                ctx.restore();
            }
        }
        ctx.restore();
    }
    popupMoved(event) {
        if (this.context !== null && event.detail) {
            this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
            this.drawPopupRelation(this.context, event.detail.annotationId, event.detail.popupRect, event.detail.color, true);
        }
    }
    createPopupView() {
        if (this.containerElement) {
            this.popupViewElement = this.createHtmlLayer();
            this.popupView = (0,_Popup__WEBPACK_IMPORTED_MODULE_1__.createPopupView)({
                maxPopupWidth: this.maxPopupWidth,
                maxPopupHeight: this.maxPopupHeight,
                minPopupWidth: this.minPopupWidth,
                minPopupHeight: this.minPopupHeight,
                currentUser: this.options.viewer.general.user ? this.options.viewer.general.user : '',
                hideSubject: this.options.annotation.hideAnnotationSubject || false,
                allowLockAnnotations: this.options.viewer.permissions.allowLockAnnotations,
                allowEditLockedAnnotations: this.options.viewer.permissions.allowEditLockedAnnotations,
                onSelect: this.selectPopup,
                onClose: this.closePopup,
                onDelete: this.deletePopup,
                onUpdatePosition: this.updatePopupPosition,
                onUpdateSize: this.updatePopupSize,
                onUpdateColor: this.updatePopupColor,
                onLock: this.toggleAnnotationLock,
            }, this.popupViewElement);
        }
    }
    selectPopup(id) {
        if (this.popupView) {
            if (this.popupView.getState().selectedPopup !== null) {
                this.updateSelectedPopupContent(true);
            }
            this.popupView.selectPopup(id);
            this.store.viewer.selectPopup({ id, focus: false });
        }
    }
    deselectPopup() {
        if (this.popupView) {
            this.updateSelectedPopupContent(true);
            this.popupView.deselectPopup();
            this.store.viewer.selectPopup({ id: null, focus: false });
        }
    }
    openPopup(id) {
        if (this.pdfApi) {
            const annotation = this.pdfApi.getItem(id);
            if (annotation) {
                annotation.popup.isOpen = true;
                this.store.annotations.updateAnnotation(annotation);
                if (this.pdfViewerCanvas.licenseFeatures.annotate) {
                    this.pdfApi.updateItem(annotation).then(() => {
                        this.selectPopup(annotation.id);
                    });
                }
                else {
                    this.selectPopup(annotation.id);
                }
            }
        }
    }
    closePopup() {
        this.updateSelectedPopupContent(false).then((annot) => {
            this.store.viewer.deselectPopup();
            if (this.pdfApi) {
                if (annot) {
                    annot.popup.isOpen = false;
                    this.store.annotations.updateAnnotation(annot);
                    if (this.pdfViewerCanvas.licenseFeatures.annotate) {
                        this.pdfApi.updateItem(annot);
                    }
                }
            }
        });
    }
    deletePopup(id) {
        if (this.pdfApi) {
            if (this.popupView) {
                this.popupView.deselectPopup();
            }
            this.store.viewer.selectPopup({ id: null, focus: false });
            const annotation = this.pdfApi.getItem(id);
            if (annotation) {
                annotation.content = '';
                annotation.subject = '';
                annotation.popup.isOpen = false;
                this.store.annotations.updateAnnotation(annotation);
                if (this.pdfViewerCanvas.licenseFeatures.annotate) {
                    this.pdfApi.updateItem(annotation);
                }
            }
        }
    }
    toggleAnnotationLock(id) {
        if (this.pdfApi) {
            this.updateSelectedPopupContent(false).then((annotation) => {
                if (annotation) {
                    if (this.options.annotation.trackHistory) {
                        (0,_custom_history__WEBPACK_IMPORTED_MODULE_8__.addHistoryEntry)(annotation, 'lock', this.options.viewer.general.user);
                    }
                    annotation.setLock(!annotation.isLocked());
                    this.store.annotations.updateAnnotation(annotation);
                    if (this.pdfViewerCanvas.licenseFeatures.annotate) {
                        this.pdfApi.updateItem(annotation);
                    }
                }
            });
        }
    }
    updateSelectedPopupContent(syncronize, annotation) {
        const promise = new Promise((resolve, reject) => {
            var _a;
            if (this.pdfApi) {
                if (this.popupView) {
                    const state = this.popupView.getState();
                    const id = state.selectedPopup;
                    if (id) {
                        if (!annotation) {
                            annotation = this.pdfApi.getItem(id);
                        }
                        const content = state.activeContent;
                        const subject = state.activeSubject;
                        if (this.options.annotation.trackHistory) {
                            (0,_custom_history__WEBPACK_IMPORTED_MODULE_8__.addHistoryEntry)(annotation, 'edit', this.options.viewer.general.user, content, subject);
                        }
                        annotation.content = content !== null ? content : annotation.content;
                        annotation.subject = subject !== null ? subject : annotation.subject;
                        if (((_a = this.pdfViewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) && syncronize) {
                            this.pdfApi
                                .updateItem(annotation)
                                .then(() => {
                                if (this.popupView) {
                                    this.popupView.stateChanged(false);
                                }
                                resolve();
                            })
                                .catch(() => {
                                reject();
                            });
                        }
                        else {
                            resolve(annotation);
                        }
                    }
                }
            }
            resolve(null);
        });
        return promise;
    }
    updatePopupPosition(id, x, y) {
        if (this.pdfApi) {
            const annotation = this.pdfApi.getItem(id);
            if (annotation) {
                const newPdfPos = this.pdfApi.transformScreenPointToPdfPoint({
                    x: x * window.devicePixelRatio,
                    y: y * window.devicePixelRatio,
                }, annotation.pdfRect.page).pdfPoint;
                if (annotation.popup.pdfRect.pdfX !== newPdfPos.pdfX ||
                    annotation.popup.pdfRect.pdfY !== newPdfPos.pdfY) {
                    annotation.popup.pdfRect.pdfX = newPdfPos.pdfX;
                    annotation.popup.pdfRect.pdfY = newPdfPos.pdfY - annotation.popup.pdfRect.pdfH;
                    this.store.annotations.updateAnnotation(annotation);
                    this.updateSelectedPopupContent(true, annotation);
                }
            }
        }
    }
    updatePopupSize(id, w, h) {
        if (this.pdfApi) {
            const annotation = this.pdfApi.getItem(id);
            if (annotation) {
                const newWidth = w / this.screenToPdfScale;
                const newHeight = h / this.screenToPdfScale;
                if (annotation.popup.pdfRect.pdfW !== newWidth ||
                    annotation.popup.pdfRect.pdfH !== newHeight) {
                    annotation.popup.pdfRect.pdfW = newWidth;
                    annotation.popup.pdfRect.pdfH = newHeight;
                    this.store.annotations.updateAnnotation(annotation);
                    this.updateSelectedPopupContent(true, annotation);
                }
            }
        }
    }
    updatePopupColor(id, color) {
        if (this.pdfApi) {
            const annotation = this.pdfApi.getItem(id);
            if (annotation) {
                if (annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.TEXT ||
                    annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.HIGHLIGHT ||
                    annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.SQUIGGLY ||
                    annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.UNDERLINE ||
                    annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.STRIKE_OUT) {
                    ;
                    annotation.color = color;
                }
                else if (annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.INK ||
                    annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.SQUARE ||
                    annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.CIRCLE) {
                    const newColor = new _common_Color__WEBPACK_IMPORTED_MODULE_6__.Color(color);
                    const currentColor = new _common_Color__WEBPACK_IMPORTED_MODULE_6__.Color(annotation.color);
                    newColor.setOpacity(currentColor.a);
                    annotation.color = newColor.toRgba();
                }
                annotation.popup.color = color;
                this.store.annotations.updateAnnotation(annotation);
                this.updateSelectedPopupContent(true, annotation);
            }
        }
    }
}


/***/ }),

/***/ "./src/modules/popup/PopupModule.ts":
/*!******************************************!*\
  !*** ./src/modules/popup/PopupModule.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PopupModule": () => (/* binding */ PopupModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _PopupLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PopupLayer */ "./src/modules/popup/PopupLayer.ts");


class PopupModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.name = PopupModule.moduleInfo.name;
    }
    onRegister() {
        this.createCanvasLayer('popup', _PopupLayer__WEBPACK_IMPORTED_MODULE_1__.PopupLayer);
        return {};
    }
    activate() {
        return;
    }
}
PopupModule.moduleInfo = {
    name: 'PopupModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Layer,
    requiredFeatures: {
        annotate: false,
        fillFormFields: false,
    },
    translationKey: 'a',
    icon: 'a',
};


/***/ }),

/***/ "./src/modules/print-service/PrintServiceDialog.tsx":
/*!**********************************************************!*\
  !*** ./src/modules/print-service/PrintServiceDialog.tsx ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PaperFormat": () => (/* binding */ PaperFormat),
/* harmony export */   "createPrintServiceDialog": () => (/* binding */ createPrintServiceDialog)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_Loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/Loader */ "./src/common/Loader.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");





var PaperFormat;
(function (PaperFormat) {
    PaperFormat[PaperFormat["A4"] = 0] = "A4";
    PaperFormat[PaperFormat["LETTER"] = 1] = "LETTER";
})(PaperFormat || (PaperFormat = {}));
const createPrintServiceDialog = (props, element) => {
    const state = {
        pages: [],
        selectedFormat: PaperFormat.A4,
        radio_selection: 'all',
        printPending: false,
    };
    const actions = {
        setFormat: (format) => ($state) => {
            let selectedFormat = $state.selectedFormat;
            if (format === 0) {
                selectedFormat = PaperFormat.A4;
            }
            else if (format === 1) {
                selectedFormat = PaperFormat.LETTER;
            }
            return Object.assign(Object.assign({}, $state), { selectedFormat });
        },
        setRadioSelection: (sel) => ($state) => {
            return Object.assign(Object.assign({}, $state), { radio_selection: sel });
        },
        setPrintPending: (printPending) => ($state) => {
            return Object.assign(Object.assign({}, $state), { printPending });
        },
    };
    const App = () => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(PrintServiceDialog, { print: props.print, cancel: props.cancel, pageCount: props.pageCount, currentPage: props.currentPage, parseRange: props.parseRange, validateRange: props.validateRange }));
    const PrintServiceDialog = ({ print, cancel, parseRange, validateRange }) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-body", id: "pwv-print-body" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-title" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { className: "pwv-print-icon", icon: _common_icons__WEBPACK_IMPORTED_MODULE_1__.icons.print, fill: '#008BD2' }),
            _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('print.title')),
        $state.printPending ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Loader__WEBPACK_IMPORTED_MODULE_3__.Loader, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-bottom pwv-print-bottom-center" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-print-button-cancel", onclick: () => {
                        cancel();
                    } }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('print.cancel'))))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-pages" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-option" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("label", null,
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { type: "radio", id: "all", checked: $state.radio_selection === 'all' ? true : false, onclick: () => {
                                $actions.setRadioSelection('all');
                            } }),
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-print-radio" }),
                        _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('print.all'))),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-option" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("label", null,
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { type: "radio", id: "current_page", checked: $state.radio_selection === 'current_page' ? true : false, onclick: () => {
                                $actions.setRadioSelection('current_page');
                            } }),
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-print-radio" }),
                        _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('print.current'))),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-option" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("label", null,
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { type: "radio", id: "range", checked: $state.radio_selection === 'range' ? true : false, onclick: () => {
                                $actions.setRadioSelection('range');
                            } }),
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-print-radio" }),
                        _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('print.range')),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { class: "pwv-print-page-range", id: "pwv-print-input-range", type: "text", placeholder: "e.g. 1,3-5", onkeydown: (e) => {
                            e.stopPropagation();
                        }, onkeyup: (e) => {
                            if (state.radio_selection !== 'range') {
                                $actions.setRadioSelection('range');
                            }
                            const inputElement = document.getElementById('pwv-print-input-range');
                            const errorMessage = document.getElementById('pwv-print-invalid-range-text');
                            let bValidInput = false;
                            if (validateRange(inputElement.value)) {
                                const pages = parseRange(inputElement.value);
                                bValidInput = !pages.some((page) => page > props.pageCount || page < 1);
                            }
                            if (bValidInput) {
                                inputElement.classList.remove('pwv-print-invalid-input');
                                errorMessage.style.display = 'none';
                            }
                            else {
                                inputElement.classList.add('pwv-print-invalid-input');
                                errorMessage.style.display = 'block';
                            }
                        } })),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-invalid-range-text", id: "pwv-print-invalid-range-text" }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('print.invalid'))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-print-bottom" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-print-button-cancel", onclick: () => {
                        cancel();
                    } }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('print.cancel')),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-print-button-print", onclick: () => {
                        if ($state.radio_selection === 'all') {
                            const pages = Array.from({ length: props.pageCount }, (x, i) => i + 1);
                            print(pages, $state.selectedFormat);
                        }
                        if ($state.radio_selection === 'current_page') {
                            print([props.currentPage], $state.selectedFormat);
                        }
                        if ($state.radio_selection === 'range') {
                            const input = document.getElementById('pwv-print-input-range').value;
                            const pages = parseRange(input);
                            print(pages, $state.selectedFormat);
                        }
                    } }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_4__.translationManager.getText('print.print')))))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/print-service/PrintServiceLayer.ts":
/*!********************************************************!*\
  !*** ./src/modules/print-service/PrintServiceLayer.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrintServiceLayer": () => (/* binding */ PrintServiceLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _PrintServiceDialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PrintServiceDialog */ "./src/modules/print-service/PrintServiceDialog.tsx");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const moduleLayerName = 'PrintServiceLayer';
class PrintServiceLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.printDialog = null;
        this.printElement = null;
        this.printIFrame = null;
        this.pageStyle = null;
        this.printPending = false;
    }
    onCreate() {
        this.startPrint = this.startPrint.bind(this);
        this.cancelPrint = this.cancelPrint.bind(this);
        this.validateRange = this.validateRange.bind(this);
        this.parseRange = this.parseRange.bind(this);
        this.stopTouchEventPropagation = this.stopTouchEventPropagation.bind(this);
        this.printElement = this.createHtmlLayer();
        this.printElement.className = 'pwv-print-dialog';
        this.printDialog = (0,_PrintServiceDialog__WEBPACK_IMPORTED_MODULE_1__.createPrintServiceDialog)({
            pageCount: this.pdfApi.getPageCount(),
            currentPage: this.store.getState().document.firstVisiblePage,
            print: this.startPrint,
            cancel: this.cancelPrint,
            validateRange: this.validateRange,
            parseRange: this.parseRange,
        }, this.printElement);
        this.store.viewer.beginModule(moduleLayerName);
        this.printElement.addEventListener('touchstart', this.stopTouchEventPropagation);
        this.printElement.addEventListener('touchend', this.stopTouchEventPropagation);
    }
    startPrint(pages, format) {
        this.printPending = true;
        if (this.printDialog) {
            this.printDialog.setPrintPending(true);
        }
        if (!this.printIFrame) {
            this.printIFrame = document.createElement('iframe');
            this.printIFrame.style.display = 'none';
            document.body.appendChild(this.printIFrame);
            const doc = this.printIFrame.contentDocument;
            doc.open();
            doc.close();
            if (doc.head) {
                const styleElm = doc.createElement('style');
                styleElm.textContent = `
        @media print {
          @page {size:A4;margin:0;padding:0}
          body {margin:0;padding:0;background-color:white;height:100%;}
          .page {margin:0;width:100% !important; height:100% !important;overflow:hidden}
          .page img {display:block;margin:0;padding:0;width:100%;height:auto;max-height:100%;}
          .page:last-child { page-break-after: avoid; }
        }
      `;
                doc.head.append(styleElm);
            }
        }
        const printDocument = this.printIFrame.contentDocument;
        printDocument.body.innerHTML = '';
        const pageList = printDocument.createElement('div');
        printDocument.body.append(pageList);
        const pdfApi = this.pdfApi;
        const dpi = 150;
        const paperSizes = {
            a4: {
                width: 595,
                height: 842,
            },
        };
        const printerPaperSize = paperSizes.a4;
        const paperSize = {
            width: (printerPaperSize.width / 72) * dpi,
            height: (printerPaperSize.height / 72) * dpi,
        };
        const canvas = printDocument.createElement('canvas');
        canvas.width = paperSize.width;
        canvas.height = paperSize.height;
        const ctx = canvas.getContext('2d');
        const renderNextPage = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.printPending) {
                return;
            }
            const page = pages.shift();
            if (page) {
                const pageSize = yield pdfApi.getPagePdfSize(page);
                let pageWidth = (pageSize.width / 72) * dpi;
                let pageHeight = (pageSize.height / 72) * dpi;
                const isLandscape = pageWidth > pageHeight;
                let scale = 1;
                if (isLandscape) {
                    scale = Math.min(paperSize.height / pageWidth, paperSize.width / pageHeight);
                }
                else {
                    scale = Math.min(paperSize.width / pageWidth, paperSize.height / pageHeight);
                }
                if (scale < 1) {
                    pageWidth = pageWidth * scale;
                    pageHeight = pageHeight * scale;
                }
                const img = yield pdfApi.renderPage(page, pageWidth, pageHeight);
                if (ctx) {
                    ctx.clearRect(0, 0, paperSize.width, paperSize.height);
                    ctx.save();
                    if (isLandscape) {
                        const tmpCanvas = printDocument.createElement('canvas');
                        tmpCanvas.width = img.imageData.width;
                        tmpCanvas.height = img.imageData.height;
                        const tmpCtx = tmpCanvas.getContext('2d');
                        if (tmpCtx) {
                            tmpCtx.putImageData(img.imageData, 0, 0);
                        }
                        const imgPosX = (paperSize.height - img.imageData.width) / 2;
                        const imgPosY = (paperSize.width - img.imageData.height) / 2;
                        ctx.translate(canvas.width, 0);
                        ctx.rotate((90 * Math.PI) / 180);
                        ctx.drawImage(tmpCanvas, imgPosX, imgPosY);
                    }
                    else {
                        const imgPosX = (paperSize.width - pageWidth) / 2;
                        const imgPosY = (paperSize.height - pageHeight) / 2;
                        ctx.putImageData(img.imageData, imgPosX, imgPosY);
                    }
                    ctx.restore();
                    const pageElm = printDocument.createElement('div');
                    pageElm.classList.add('page');
                    pageList.append(pageElm);
                    const imgSrc = canvas.toDataURL('image/png');
                    const imgElm = printDocument.createElement('img');
                    imgElm.src = imgSrc;
                    pageElm.append(imgElm);
                }
                renderNextPage();
            }
            else {
                window.setTimeout(() => {
                    this.printPending = false;
                    if (this.printDialog) {
                        this.printDialog.setPrintPending(false);
                    }
                    if (this.printIFrame && this.printIFrame.contentWindow) {
                        this.printIFrame.contentWindow.print();
                    }
                }, 100);
            }
        });
        renderNextPage();
    }
    cancelPrint() {
        this.printPending = false;
        this.remove();
    }
    stopTouchEventPropagation(e) {
        e.stopImmediatePropagation();
    }
    validateRange(range) {
        let regex = range.match(/^[\d\,\-]*$/g);
        if (!regex || (regex && regex.length === 0)) {
            return false;
        }
        regex = range.match(/-{2,}|,{2,}/g);
        if (regex && regex.length > 0) {
            return false;
        }
        return true;
    }
    parseRange(range) {
        let pages = [];
        if (!this.validateRange(range)) {
            return [];
        }
        const splitInput = range.split(',');
        splitInput.forEach((input) => {
            const nDashes = (input.match(/-/g) || []).length;
            if (nDashes === 0) {
                pages.push(parseInt(input, 10));
            }
            if (nDashes === 1) {
                const numbers = input.split('-');
                let firstPage = parseInt(numbers[0], 10);
                let lastPage = parseInt(numbers[1], 10);
                if (lastPage < firstPage) {
                    const temp = firstPage;
                    firstPage = lastPage;
                    lastPage = temp;
                }
                const pageRange = Array.from({ length: lastPage - firstPage + 1 }, (v, k) => k + firstPage);
                pages = pages.concat(pageRange);
            }
        });
        return pages;
    }
    close() {
        this.remove();
    }
    onRemove() {
        var _a, _b;
        (_a = this.printElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchstart', this.stopTouchEventPropagation);
        (_b = this.printElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('touchend', this.stopTouchEventPropagation);
        this.removeHtmlElements();
        this.printPending = false;
        this.printElement = null;
        if (this.pageStyle) {
            this.pageStyle.remove();
        }
        if (this.printIFrame) {
            document.body.removeChild(this.printIFrame);
        }
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (this.printElement && state.pointer.action === 'click') {
            const insideHorizontal = state.pointer.x.cssPixels > this.printElement.offsetLeft &&
                state.pointer.x.cssPixels < this.printElement.offsetLeft + this.printElement.offsetWidth;
            const insideVertical = state.pointer.y.cssPixels > this.printElement.offsetTop &&
                state.pointer.y.cssPixels < this.printElement.offsetTop + this.printElement.offsetHeight;
            if (!insideHorizontal || !insideVertical) {
                this.remove();
                return;
            }
        }
    }
    onSave() {
        return new Promise((resolve, rejct) => {
            return;
        });
    }
}


/***/ }),

/***/ "./src/modules/print-service/PrintServiceModule.ts":
/*!*********************************************************!*\
  !*** ./src/modules/print-service/PrintServiceModule.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrintServiceModule": () => (/* binding */ PrintServiceModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _PrintServiceLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PrintServiceLayer */ "./src/modules/print-service/PrintServiceLayer.ts");


class PrintServiceModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.annotationbarElement = null;
        this.toolbarElement = null;
        this.name = PrintServiceModule.moduleInfo.name;
        this.activate = this.activate.bind(this);
    }
    onRegister() {
        return {};
    }
    activate() {
        if (!this.canvasLayers['add']) {
            this.createCanvasLayer('add', _PrintServiceLayer__WEBPACK_IMPORTED_MODULE_1__.PrintServiceLayer);
        }
    }
}
PrintServiceModule.moduleInfo = {
    name: 'PrintServiceModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Layer,
    requiredFeatures: {
        annotate: false,
        fillFormFields: false,
    },
    translationKey: 'a',
    icon: 'a',
};


/***/ }),

/***/ "./src/modules/shape-annotations/AddShapeAnnotationLayer.ts":
/*!******************************************************************!*\
  !*** ./src/modules/shape-annotations/AddShapeAnnotationLayer.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddShapeAnnotationLayer": () => (/* binding */ AddShapeAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/document */ "./src/pdf-viewer-canvas/state/document.ts");
/* harmony import */ var _AddShapeAnnotationToolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AddShapeAnnotationToolbar */ "./src/modules/shape-annotations/AddShapeAnnotationToolbar.tsx");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");






const moduleLayerName = 'AddShapeAnnotation';
class AddShapeAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.context = null;
        this.toolbar = null;
        this.page = 0;
        this.pointerDown = false;
        this.startPoint = null;
        this.itemType = null;
        this.strokeColors = [];
        this.fillColors = [];
    }
    onCreate(itemType) {
        this.setStrokeColor = this.setStrokeColor.bind(this);
        this.setStrokeWidth = this.setStrokeWidth.bind(this);
        this.setStrokeStyle = this.setStrokeStyle.bind(this);
        this.setFillColor = this.setFillColor.bind(this);
        this.setShape = this.setShape.bind(this);
        this.cancel = this.cancel.bind(this);
        this.context = this.createCanvas();
        this.itemType = itemType;
        const annotationOptions = this.options.annotation;
        this.strokeColors = annotationOptions.colors.foregroundColors;
        this.fillColors = annotationOptions.colors.backgroundColors;
        this.store.viewer.beginModule(moduleLayerName);
        const toolbarElement = this.module.toolbarElement;
        this.toolbar = (0,_AddShapeAnnotationToolbar__WEBPACK_IMPORTED_MODULE_4__.createAddShapeAnnotationToolbar)({
            strokeColors: this.strokeColors,
            strokeWidths: annotationOptions.strokeWidths,
            fillColors: this.fillColors,
            selectedStrokeColor: annotationOptions.colors.shapeColor,
            selectedStrokeWidth: annotationOptions.shapeStrokeWidth,
            selectedStrokeStyle: annotationOptions.shapeStrokeStyle,
            selectedFillColor: annotationOptions.colors.shapeFillColor,
            selectedShape: this.itemType,
            onStrokeColorChanged: this.setStrokeColor,
            onStrokeWidthChanged: this.setStrokeWidth,
            onStrokeStyleChanged: this.setStrokeStyle,
            onFillColorChanged: this.setFillColor,
            onShapeChanged: this.setShape,
            onCancel: this.cancel,
        }, toolbarElement);
    }
    cancel() {
        this.remove();
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            resolve();
        });
        return promise;
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.DEFAULT);
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (this.context) {
            const update = state.viewer.modeChanged ||
                state.pointer.positionChanged ||
                state.pointer.action ||
                state.document.zoomChanged;
            if (update) {
                const ctx = this.context;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const pointerPos = {
                    x: state.pointer.x.devicePixels,
                    y: state.pointer.y.devicePixels,
                };
                const pointerPdfPos = this.pdfApi.transformScreenPointToPdfPoint(pointerPos);
                if (pointerPdfPos.isOnPage) {
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.CROSSHAIR);
                }
                else {
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.NOT_ALLOWED);
                }
                if (state.pointer.isDown) {
                    if (!this.pointerDown) {
                        this.startPoint = pointerPos;
                        this.pointerDown = true;
                        if (this.page === 0 && pointerPdfPos.isOnPage) {
                            this.page = pointerPdfPos.pdfPoint.page;
                        }
                    }
                    if (this.startPoint) {
                        const rect = (0,_pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_3__.getRectFromSelection)(state.document, {
                            x: this.startPoint.x,
                            y: this.startPoint.y,
                        }, {
                            x: pointerPos.x,
                            y: pointerPos.y,
                        }, this.page);
                        const annotationOptions = this.options.annotation;
                        if (rect) {
                            ctx.save();
                            const strokeColor = new _common_Color__WEBPACK_IMPORTED_MODULE_5__.Color(annotationOptions.colors.shapeColor);
                            ctx.strokeStyle = strokeColor.toRgb();
                            const fillColor = new _common_Color__WEBPACK_IMPORTED_MODULE_5__.Color(annotationOptions.colors.shapeFillColor);
                            ctx.fillStyle = fillColor.toRgb();
                            const lineWidth = annotationOptions.shapeStrokeWidth * devicePixelRatio * state.document.zoom;
                            ctx.lineWidth = lineWidth;
                            if (lineWidth) {
                                ctx.globalAlpha = strokeColor.a;
                            }
                            else {
                                ctx.globalAlpha = fillColor.a;
                            }
                            if (this.options.annotation.shapeStrokeStyle === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle.DASHED) {
                                ctx.setLineDash([ctx.lineWidth]);
                            }
                            if (this.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.CIRCLE) {
                                const cX = rect.x + rect.w / 2;
                                const cY = rect.y + rect.h / 2;
                                ctx.beginPath();
                                ctx.ellipse(cX, cY, Math.max(rect.w / 2 - ctx.lineWidth / 2, 0), Math.max(rect.h / 2 - ctx.lineWidth / 2, 0), 0, 0, Math.PI * 2);
                                if (fillColor.a) {
                                    ctx.fill();
                                }
                                if (annotationOptions.shapeStrokeWidth) {
                                    ctx.stroke();
                                }
                            }
                            else {
                                if (fillColor.a) {
                                    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                                }
                                if (annotationOptions.shapeStrokeWidth) {
                                    ctx.strokeRect(rect.x + ctx.lineWidth / 2, rect.y + ctx.lineWidth / 2, rect.w - ctx.lineWidth, rect.h - ctx.lineWidth);
                                }
                            }
                            ctx.restore();
                        }
                    }
                }
                else if (this.pointerDown && this.startPoint) {
                    const rect = (0,_pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_3__.getRectFromSelection)(state.document, {
                        x: this.startPoint.x,
                        y: this.startPoint.y,
                    }, {
                        x: pointerPos.x,
                        y: pointerPos.y,
                    }, this.page);
                    if (rect) {
                        this.pointerDown = false;
                        this.startPoint = null;
                        this.createRectangleAnnotation(rect);
                    }
                }
            }
        }
    }
    setStrokeColor(color) {
        this.options.annotation.colors.shapeColor = color;
    }
    setShape(shape) {
        this.itemType = shape;
    }
    setStrokeWidth(width) {
        this.options.annotation.shapeStrokeWidth = width;
    }
    setStrokeStyle(style) {
        this.options.annotation.shapeStrokeStyle = style;
    }
    setFillColor(color) {
        this.options.annotation.colors.shapeFillColor = color;
    }
    createRectangleAnnotation(rect) {
        const pdfRect = this.pdfApi.transformScreenRectToPdfRect(rect, this.page);
        const annotationOptions = this.options.annotation;
        const annotation = {
            itemType: this.itemType,
            color: annotationOptions.colors.shapeColor,
            pdfRect,
            page: this.page,
            author: this.options.viewer.general.user,
            fillColor: annotationOptions.colors.shapeFillColor === 'transparent'
                ? null
                : annotationOptions.colors.shapeFillColor,
            border: {
                width: annotationOptions.shapeStrokeWidth,
                style: this.options.annotation.shapeStrokeStyle,
            },
        };
        this.pdfApi
            .createItem(annotation)
            .then(() => {
            this.remove();
        })
            .catch((err) => {
            console.error(err);
        });
    }
}


/***/ }),

/***/ "./src/modules/shape-annotations/AddShapeAnnotationToolbar.tsx":
/*!*********************************************************************!*\
  !*** ./src/modules/shape-annotations/AddShapeAnnotationToolbar.tsx ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddShapeAnnotationToolbar": () => (/* binding */ createAddShapeAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/StrokeWidthPicker */ "./src/common/StrokeWidthPicker.tsx");
/* harmony import */ var _common_StrokeStylePicker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/StrokeStylePicker */ "./src/common/StrokeStylePicker.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");











const createAddShapeAnnotationToolbar = (props, element) => {
    const state = {
        strokeColors: props.strokeColors,
        strokeWidths: props.strokeWidths,
        fillColors: props.fillColors,
        selectedShape: props.selectedShape,
        selectedStrokeColor: props.selectedStrokeColor,
        selectedStrokeWidth: props.selectedStrokeWidth,
        selectedStrokeStyle: props.selectedStrokeStyle,
        selectedFillColor: props.selectedFillColor,
    };
    const actions = {
        setShape: (shape) => ($state) => {
            props.onShapeChanged(shape);
            return Object.assign(Object.assign({}, $state), { selectedShape: shape });
        },
        setStrokeColor: (color) => ($state) => {
            props.onStrokeColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedStrokeColor: color });
        },
        setStrokeWidth: (width) => ($state) => {
            props.onStrokeWidthChanged(width);
            return Object.assign(Object.assign({}, $state), { selectedStrokeWidth: width });
        },
        setStrokeStyle: (style) => ($state) => {
            props.onStrokeStyleChanged(style);
            return Object.assign(Object.assign({}, $state), { selectedStrokeStyle: style });
        },
        setFillColor: (color) => ($state) => {
            props.onFillColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedFillColor: color });
        },
        setCancel: () => ($state) => {
            return Object.assign({}, $state);
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(AddShapeAnnotationToolbar, null);
    const AddShapeAnnotationToolbar = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_3__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.addRectangle'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.rectangle, active: $state.selectedShape === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.SQUARE, onClick: () => {
                    $actions.setShape(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.SQUARE);
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.addEllipse'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.circle, active: $state.selectedShape === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.CIRCLE, onClick: () => {
                    $actions.setShape(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.CIRCLE);
                } }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_7__.ToolbarSeparator, null)),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_8__.StrokeWidthPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.strokeWidth'), noneStrokeText: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('border.none'), strokeWidths: $state.strokeWidths, value: $state.selectedStrokeWidth, onChange: $actions.setStrokeWidth }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_StrokeStylePicker__WEBPACK_IMPORTED_MODULE_9__.StrokeStylePicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.strokeStyle'), value: $state.selectedStrokeStyle, disabled: $state.selectedStrokeWidth === 0, onChange: $actions.setStrokeStyle, shapeType: $state.selectedShape === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.CIRCLE ? 'circle' : 'rectangle' }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_10__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.strokeColor'), colors: $state.strokeColors, color: $state.selectedStrokeColor, disabled: $state.selectedStrokeWidth === 0, icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.pencil, onChange: $actions.setStrokeColor })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_7__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_10__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.bgColor'), colors: $state.fillColors, color: $state.selectedFillColor, icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.fillColor, onChange: $actions.setFillColor })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_7__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.close, onClick: props.onCancel }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/shape-annotations/EditShapeAnnotationLayer.ts":
/*!*******************************************************************!*\
  !*** ./src/modules/shape-annotations/EditShapeAnnotationLayer.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditShapeAnnotationLayer": () => (/* binding */ EditShapeAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _EditShapeAnnotationToolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditShapeAnnotationToolbar */ "./src/modules/shape-annotations/EditShapeAnnotationToolbar.tsx");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");




const moduleLayerName = 'EditShapeAnnotation';
class EditShapeAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.shapeAnnotation = null;
        this.context = null;
        this.toolbar = null;
        this.strokeColors = [];
        this.fillColors = [];
    }
    onCreate(annotationId) {
        this.shapeAnnotation = this.pdfApi.getItem(annotationId);
        this.setStrokeColor = this.setStrokeColor.bind(this);
        this.setStrokeWidth = this.setStrokeWidth.bind(this);
        this.setStrokeStyle = this.setStrokeStyle.bind(this);
        this.setFillColor = this.setFillColor.bind(this);
        this.close = this.close.bind(this);
        const annotOptions = this.options.annotation;
        this.strokeColors = annotOptions.colors.foregroundColors;
        this.fillColors = annotOptions.colors.backgroundColors;
        this.context = this.createCanvas();
        const toolbarElement = this.module.toolbarElement;
        this.toolbar = (0,_EditShapeAnnotationToolbar__WEBPACK_IMPORTED_MODULE_2__.createEditShapeAnnotationToolbar)({
            strokeColors: this.strokeColors,
            strokeWidths: annotOptions.strokeWidths,
            fillColors: this.fillColors,
            selectedStrokeColor: this.shapeAnnotation.color
                ? this.shapeAnnotation.color
                : annotOptions.colors.shapeColor,
            selectedStrokeWidth: this.shapeAnnotation.border.width,
            selectedStrokeStyle: this.shapeAnnotation.border.style,
            selectedFillColor: this.shapeAnnotation.fillColor
                ? this.shapeAnnotation.fillColor
                : annotOptions.colors.shapeFillColor,
            itemType: this.shapeAnnotation.itemType,
            onStrokeColorChanged: this.setStrokeColor,
            onStrokeWidthChanged: this.setStrokeWidth,
            onStrokeStyleChanged: this.setStrokeStyle,
            onFillColorChanged: this.setFillColor,
            onCancel: this.close,
        }, toolbarElement);
        this.store.viewer.beginModule(moduleLayerName);
    }
    close() {
        this.remove();
    }
    onSave() {
        return new Promise((resolve, reject) => {
            resolve();
        });
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_1__.CursorStyle.DEFAULT);
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        var _a;
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (state.pointer.action === 'click' || state.pointer.action === 'dblclick') {
            const shapeAnnotation = (_a = this.pdfApi
                .getAnnotationsOnPoint({
                x: state.pointer.x.devicePixels,
                y: state.pointer.y.devicePixels,
            })) === null || _a === void 0 ? void 0 : _a.find((a) => this.shapeAnnotation && a.id === this.shapeAnnotation.id);
            if (!shapeAnnotation) {
                this.close();
                return;
            }
        }
        if (this.context && this.shapeAnnotation) {
            const ctx = this.context;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const rect = this.pdfApi.transformPdfPageRectToScreenRect(this.shapeAnnotation.pdfRect);
            const lineWidth = 2 * devicePixelRatio;
            ctx.save();
            ctx.strokeStyle = this.options.viewer.general.textSelectionColor;
            ctx.lineWidth = lineWidth;
            ctx.setLineDash([lineWidth, lineWidth]);
            ctx.strokeRect(rect.x - lineWidth, rect.y - lineWidth, rect.w + 2 * lineWidth, rect.h + 2 * lineWidth);
            ctx.restore();
        }
    }
    setStrokeColor(color) {
        if (this.shapeAnnotation && this.shapeAnnotation.color) {
            const newColor = new _common_Color__WEBPACK_IMPORTED_MODULE_3__.Color(color);
            const currentColor = new _common_Color__WEBPACK_IMPORTED_MODULE_3__.Color(this.shapeAnnotation.color);
            newColor.setOpacity(currentColor.a);
            this.shapeAnnotation.color = newColor.toRgba();
            this.updateShapeAnnotation();
        }
    }
    setStrokeWidth(width) {
        if (this.shapeAnnotation) {
            this.shapeAnnotation.border = {
                style: this.shapeAnnotation.border.style,
                width: width,
            };
            this.updateShapeAnnotation();
        }
    }
    setStrokeStyle(style) {
        if (this.shapeAnnotation) {
            this.shapeAnnotation.border = {
                style: style,
                width: this.shapeAnnotation.border.width,
            };
            this.updateShapeAnnotation();
        }
    }
    setFillColor(color) {
        if (this.shapeAnnotation) {
            const newColor = new _common_Color__WEBPACK_IMPORTED_MODULE_3__.Color(color);
            this.shapeAnnotation.fillColor = newColor.toRgba();
            this.updateShapeAnnotation();
        }
    }
    updateShapeAnnotation() {
        const promise = new Promise((resolve, reject) => {
            if (this.pdfApi && this.shapeAnnotation) {
                this.pdfApi
                    .updateItem(this.shapeAnnotation)
                    .then((item) => {
                    resolve();
                })
                    .catch((error) => {
                    console.warn(error);
                });
            }
            else {
                reject();
            }
        });
        return promise;
    }
}


/***/ }),

/***/ "./src/modules/shape-annotations/EditShapeAnnotationToolbar.tsx":
/*!**********************************************************************!*\
  !*** ./src/modules/shape-annotations/EditShapeAnnotationToolbar.tsx ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEditShapeAnnotationToolbar": () => (/* binding */ createEditShapeAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/StrokeWidthPicker */ "./src/common/StrokeWidthPicker.tsx");
/* harmony import */ var _common_StrokeStylePicker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/StrokeStylePicker */ "./src/common/StrokeStylePicker.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");











const createEditShapeAnnotationToolbar = (props, element) => {
    const state = {
        strokeColors: props.strokeColors,
        strokeWidths: props.strokeWidths,
        fillColors: props.fillColors,
        selectedStrokeColor: props.selectedStrokeColor,
        selectedStrokeWidth: props.selectedStrokeWidth,
        selectedStrokeStyle: props.selectedStrokeStyle,
        selectedFillColor: props.selectedFillColor,
        itemType: props.itemType,
    };
    const actions = {
        setStrokeColor: (color) => ($state) => {
            props.onStrokeColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedStrokeColor: color });
        },
        setStrokeWidth: (width) => ($state) => {
            props.onStrokeWidthChanged(width);
            return Object.assign(Object.assign({}, $state), { selectedStrokeWidth: width });
        },
        setStrokeStyle: (style) => ($state) => {
            props.onStrokeStyleChanged(style);
            return Object.assign(Object.assign({}, $state), { selectedStrokeStyle: style });
        },
        setFillColor: (color) => ($state) => {
            props.onFillColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedFillColor: color });
        },
        setCancel: () => ($state) => {
            return Object.assign({}, $state);
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(EditShapeAnnotationToolbar, null);
    const EditShapeAnnotationToolbar = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_3__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_StrokeWidthPicker__WEBPACK_IMPORTED_MODULE_8__.StrokeWidthPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.strokeWidth'), noneStrokeText: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('border.none'), strokeWidths: $state.strokeWidths, value: $state.selectedStrokeWidth, onChange: $actions.setStrokeWidth }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_StrokeStylePicker__WEBPACK_IMPORTED_MODULE_9__.StrokeStylePicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.strokeStyle'), value: $state.selectedStrokeStyle, disabled: $state.selectedStrokeWidth === 0, onChange: $actions.setStrokeStyle, shapeType: $state.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.CIRCLE ? 'circle' : 'rectangle' }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_10__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.strokeColor'), colors: $state.strokeColors, color: $state.selectedStrokeColor, disabled: $state.selectedStrokeWidth === 0, icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.pencil, onChange: $actions.setStrokeColor })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_7__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_10__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('annotShape.bgColor'), colors: $state.fillColors, color: $state.selectedFillColor, icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.fillColor, onChange: $actions.setFillColor })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_7__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.close, onClick: props.onCancel }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/shape-annotations/ShapeAnnotationModule.ts":
/*!****************************************************************!*\
  !*** ./src/modules/shape-annotations/ShapeAnnotationModule.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShapeAnnotationModule": () => (/* binding */ ShapeAnnotationModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _AddShapeAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddShapeAnnotationLayer */ "./src/modules/shape-annotations/AddShapeAnnotationLayer.ts");
/* harmony import */ var _EditShapeAnnotationLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditShapeAnnotationLayer */ "./src/modules/shape-annotations/EditShapeAnnotationLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");






class ShapeAnnotationModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.annotationbarElement = null;
        this.toolbarElement = null;
        this.name = ShapeAnnotationModule.moduleInfo.name;
        this.onEdit = this.onEdit.bind(this);
    }
    onRegister() {
        this.toolbarElement = document.createElement('div');
        return {
            toolbar: this.toolbarElement,
            contextbar: {
                itemTypes: [_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.SQUARE, _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.CIRCLE],
                icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.edit,
                tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__.translationManager.getText('annotShape.edit'),
                onCmd: (annotationId) => {
                    this.onEdit(annotationId);
                },
            },
        };
    }
    activate() {
        if (!this.canvasLayers['add']) {
            this.createCanvasLayer('add', _AddShapeAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__.AddShapeAnnotationLayer, _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType.SQUARE);
        }
        else {
            this.removeCanvasLayer('add');
        }
    }
    onEdit(annotationId) {
        this.createCanvasLayer('edit', _EditShapeAnnotationLayer__WEBPACK_IMPORTED_MODULE_2__.EditShapeAnnotationLayer, annotationId);
    }
}
ShapeAnnotationModule.moduleInfo = {
    name: 'ShapeAnnotationModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Tool,
    requiredFeatures: {
        annotate: true,
        fillFormFields: false,
    },
    translationKey: 'annotShape.add',
    icon: 'shapes',
};


/***/ }),

/***/ "./src/modules/stamp-annotation/AddStampAnnotationLayer.ts":
/*!*****************************************************************!*\
  !*** ./src/modules/stamp-annotation/AddStampAnnotationLayer.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddStampAnnotationLayer": () => (/* binding */ AddStampAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/document */ "./src/pdf-viewer-canvas/state/document.ts");
/* harmony import */ var _AddStampAnnotationToolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AddStampAnnotationToolbar */ "./src/modules/stamp-annotation/AddStampAnnotationToolbar.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Tools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/Tools */ "./src/common/Tools.ts");







const moduleLayerName = 'AddStampAnnotation';
class AddStampAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.context = null;
        this.pointerDown = false;
        this.startPoint = null;
        this.stampRect = null;
        this.page = 0;
        this.screenPageRect = null;
        this.aspectRatio = null;
        this.stamps = [];
    }
    onCreate() {
        this.setStamp = this.setStamp.bind(this);
        this.close = this.close.bind(this);
        this.context = this.createCanvas();
        this.stamps = this.options.annotation.stamps;
        const toolbarElement = this.module.toolbarElement;
        this.setStamp(this.options.annotation.selectedStamp);
        (0,_AddStampAnnotationToolbar__WEBPACK_IMPORTED_MODULE_4__.createAddStampAnnotationToolbar)({
            selectedStamp: this.options.annotation.selectedStamp,
            stamps: this.stamps,
            onStampChanged: this.setStamp,
            onClose: this.close,
        }, toolbarElement);
        this.store.viewer.beginModule(moduleLayerName);
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            resolve();
        });
        return promise;
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.DEFAULT);
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (!this.aspectRatio) {
            return;
        }
        if (this.context) {
            const update = state.viewer.modeChanged ||
                state.pointer.positionChanged ||
                state.pointer.action ||
                state.document.zoomChanged;
            if (update) {
                const ctx = this.context;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const pointerPos = { x: state.pointer.x.devicePixels, y: state.pointer.y.devicePixels };
                const pointerPdfPos = this.pdfApi.transformScreenPointToPdfPoint(pointerPos);
                if (pointerPdfPos.isOnPage) {
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.CROSSHAIR);
                }
                else {
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.NOT_ALLOWED);
                }
                if (state.pointer.isDown) {
                    if (!this.pointerDown) {
                        if (!pointerPdfPos.isOnPage) {
                            return;
                        }
                        this.startPoint = pointerPos;
                        this.page = pointerPdfPos.pdfPoint.page;
                        this.pointerDown = true;
                        this.screenPageRect = this.pdfApi.getPageScreenRect(this.page);
                    }
                    if (this.startPoint && this.screenPageRect) {
                        this.stampRect = (0,_pdf_viewer_canvas_state_document__WEBPACK_IMPORTED_MODULE_3__.getRectFromSelection)(state.document, {
                            x: this.startPoint.x,
                            y: this.startPoint.y,
                        }, {
                            x: pointerPos.x,
                            y: pointerPos.y,
                        });
                        if (this.stampRect) {
                            this.stampRect.h = this.stampRect.w / this.aspectRatio;
                            const lineWidth = 2 * devicePixelRatio;
                            ctx.save();
                            ctx.strokeStyle = this.options.viewer.general.textSelectionColor;
                            ctx.fillStyle = this.options.viewer.general.textSelectionColor;
                            ctx.lineWidth = lineWidth;
                            ctx.setLineDash([lineWidth, lineWidth]);
                            if (this.startPoint.y > pointerPos.y) {
                                this.stampRect.y = this.startPoint.y - this.stampRect.h;
                                if (this.stampRect.y < this.screenPageRect.y) {
                                    this.stampRect.y = this.screenPageRect.y;
                                    this.stampRect.w = this.stampRect.h * this.aspectRatio;
                                }
                            }
                            else {
                                if (this.startPoint.y + this.stampRect.h >
                                    this.screenPageRect.y + this.screenPageRect.h) {
                                    this.stampRect.h =
                                        this.screenPageRect.y + this.screenPageRect.h - this.startPoint.y;
                                    this.stampRect.w = this.stampRect.h * this.aspectRatio;
                                }
                            }
                            ctx.strokeRect(this.stampRect.x, this.stampRect.y, this.stampRect.w, this.stampRect.h);
                            ctx.globalAlpha = 0.33;
                            ctx.fillRect(this.stampRect.x, this.stampRect.y, this.stampRect.w, this.stampRect.h);
                            ctx.restore();
                        }
                    }
                }
                else if (this.pointerDown && this.startPoint) {
                    if (this.stampRect) {
                        this.createStampAnnotation(this.stampRect);
                        this.pointerDown = false;
                        this.startPoint = null;
                        this.stampRect = null;
                        this.page = 0;
                        this.aspectRatio = null;
                        this.screenPageRect = null;
                        this.remove();
                        return;
                    }
                }
            }
        }
    }
    close() {
        this.remove();
    }
    setStamp(stampIndex) {
        if (this.stamps.length == 0) {
            return;
        }
        if (stampIndex > this.stamps.length) {
            stampIndex = 0;
        }
        this.options.annotation.selectedStamp = stampIndex;
        const stamp = this.stamps[stampIndex];
        if (stamp.aspectRatio) {
            this.aspectRatio = stamp.aspectRatio;
            return;
        }
        if (stamp.image) {
            const img = new Image();
            img.onload = () => {
                this.aspectRatio = img.width / img.height;
            };
            img.src = stamp.image;
            return;
        }
        this.pdfApi
            .getTextStampAspectRatio(stamp.text ? stamp.text : _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__.translationManager.getText(stamp.translation_key))
            .then((aspectRatio) => {
            this.aspectRatio = aspectRatio;
        });
    }
    createStampAnnotation(rect) {
        const pdfRect = this.pdfApi.transformScreenRectToPdfRect(rect, this.page);
        if (this.aspectRatio && (pdfRect.pdfW < 5 || pdfRect.pdfH < 5)) {
            switch (this.pdfApi.getRotation()) {
                case 0:
                    pdfRect.pdfW = this.options.annotation.defaultStampWidth;
                    pdfRect.pdfH = pdfRect.pdfW / this.aspectRatio;
                    pdfRect.pdfY -= pdfRect.pdfH;
                    break;
                case 90:
                    pdfRect.pdfH = this.options.annotation.defaultStampWidth;
                    pdfRect.pdfW = pdfRect.pdfH / this.aspectRatio;
                    break;
                case 180:
                    pdfRect.pdfW = this.options.annotation.defaultStampWidth;
                    pdfRect.pdfH = pdfRect.pdfW / this.aspectRatio;
                    pdfRect.pdfX -= pdfRect.pdfW;
                    break;
                case 270:
                    pdfRect.pdfH = this.options.annotation.defaultStampWidth;
                    pdfRect.pdfW = pdfRect.pdfH / this.aspectRatio;
                    pdfRect.pdfX -= pdfRect.pdfW;
                    pdfRect.pdfY -= pdfRect.pdfH;
                    break;
                default:
                    break;
            }
        }
        const stampSetting = this.stamps[this.options.annotation.selectedStamp];
        if (stampSetting.pdfStampFileName) {
            this.pdfApi
                .registerPdfPage(stampSetting.pdfStampFileName, stampSetting.pageNumber)
                .then((imageId) => {
                const annotation = {
                    itemType: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.STAMP,
                    imageId,
                    page: pdfRect.page,
                    color: this.options.annotation.colors.defaultHighlightColor,
                    pdfRect,
                    author: this.options.viewer.general.user,
                };
                this.pdfApi.createItem(annotation).then((annot) => {
                    this.onAnnotationCreated(annot);
                });
            });
        }
        else if (stampSetting.image) {
            const imgData = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_6__.imageDataUrlToUint8Array)(stampSetting.image);
            this.pdfApi.registerStampImage(imgData).then((imageId) => {
                const annotation = {
                    itemType: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.STAMP,
                    imageId,
                    page: pdfRect.page,
                    color: this.options.annotation.colors.defaultHighlightColor,
                    pdfRect,
                    author: this.options.viewer.general.user,
                };
                this.pdfApi.createItem(annotation).then((annot) => {
                    this.onAnnotationCreated(annot);
                });
            });
        }
        else {
            let stampColor = null;
            let stampName = null;
            if (stampSetting) {
                stampColor = stampSetting.color;
                stampName = stampSetting.pdfStampName !== undefined ? stampSetting.pdfStampName : null;
            }
            const annotation = {
                itemType: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.STAMP,
                color: this.options.annotation.colors.defaultHighlightColor,
                author: this.options.viewer.general.user,
                page: pdfRect.page,
                pdfRect,
                stampName,
                stampText: stampSetting.text
                    ? stampSetting.text
                    : _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__.translationManager.getText(stampSetting.translation_key),
                stampColor: stampColor != null ? stampColor : _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.StampAnnotationColor.GREEN,
            };
            this.pdfApi.createItem(annotation).then((annot) => {
                this.onAnnotationCreated(annot);
            });
        }
    }
}


/***/ }),

/***/ "./src/modules/stamp-annotation/AddStampAnnotationToolbar.tsx":
/*!********************************************************************!*\
  !*** ./src/modules/stamp-annotation/AddStampAnnotationToolbar.tsx ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddStampAnnotationToolbar": () => (/* binding */ createAddStampAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_Dropdown__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/Dropdown */ "./src/common/Dropdown.tsx");








const createAddStampAnnotationToolbar = (props, element) => {
    const state = {
        stamps: props.stamps,
        stampDropdownItems: [],
        selectedStamp: props.selectedStamp,
    };
    const actions = {
        setStamp: (stamp) => ($state) => {
            props.onStampChanged(stamp);
            return Object.assign(Object.assign({}, $state), { selectedStamp: stamp });
        },
    };
    const DropdownStampItem = (item) => {
        const stamp = state.stamps[item.value];
        if (stamp.thumbnail) {
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("img", { src: stamp.thumbnail })));
        }
        if (stamp.name) {
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, stamp.name);
        }
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, stamp.image
            ? stamp.name
            : stamp.text
                ? stamp.text
                : _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText(stamp.translation_key)));
    };
    const DropdownButton = (value) => {
        if (value === -1) {
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-Dropdown-text" }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('annotStamp.chooseStamp')));
        }
        const stamp = state.stamps[value];
        if (stamp.thumbnail) {
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-Dropdown-text" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("img", { src: stamp.thumbnail })));
        }
        if (stamp.pdfStampFileName) {
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-Dropdown-text" }, stamp.name);
        }
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-Dropdown-text" }, stamp.image
            ? stamp.name
            : stamp.text
                ? stamp.text
                : _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText(stamp.translation_key)));
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(AddStampAnnotationToolbar, null);
    const AddStampAnnotationToolbar = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Dropdown__WEBPACK_IMPORTED_MODULE_7__.Dropdown, { className: "pwv-stampannotation-dropdown", value: $state.selectedStamp, items: $state.stamps.map((stamp, index) => ({
                    value: index,
                    renderItem: DropdownStampItem,
                })), onChange: $actions.setStamp, renderButton: DropdownButton })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_6__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons.close, onClick: props.onClose }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/stamp-annotation/StampAnnotationModule.ts":
/*!***************************************************************!*\
  !*** ./src/modules/stamp-annotation/StampAnnotationModule.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StampAnnotationModule": () => (/* binding */ StampAnnotationModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _AddStampAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddStampAnnotationLayer */ "./src/modules/stamp-annotation/AddStampAnnotationLayer.ts");


class StampAnnotationModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.annotationbarElement = null;
        this.toolbarElement = null;
        this.name = StampAnnotationModule.moduleInfo.name;
        this.activate = this.activate.bind(this);
    }
    onRegister() {
        this.toolbarElement = document.createElement('div');
        return {
            toolbar: this.toolbarElement,
        };
    }
    activate() {
        if (!this.canvasLayers['add']) {
            this.createCanvasLayer('add', _AddStampAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__.AddStampAnnotationLayer);
        }
        else {
            this.removeCanvasLayer('add');
        }
    }
}
StampAnnotationModule.moduleInfo = {
    name: 'StampAnnotationModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Tool,
    requiredFeatures: {
        annotate: true,
        fillFormFields: false,
    },
    translationKey: 'annotStamp.add',
    icon: 'stamp',
};


/***/ }),

/***/ "./src/modules/text-annotation/AddTextAnnotationLayer.ts":
/*!***************************************************************!*\
  !*** ./src/modules/text-annotation/AddTextAnnotationLayer.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddTextAnnotationLayer": () => (/* binding */ AddTextAnnotationLayer)
/* harmony export */ });
/* harmony import */ var _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasLayer */ "./src/modules/CanvasLayer.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../pdf-viewer-canvas/state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _pdf_viewer_canvas_view_layers_canvasShapes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../pdf-viewer-canvas/view-layers/canvasShapes */ "./src/pdf-viewer-canvas/view-layers/canvasShapes.ts");
/* harmony import */ var _AddTextAnnotationToolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AddTextAnnotationToolbar */ "./src/modules/text-annotation/AddTextAnnotationToolbar.tsx");





const moduleLayerName = 'AddTextAnnotation';
class AddTextAnnotationLayer extends _CanvasLayer__WEBPACK_IMPORTED_MODULE_0__.CanvasLayer {
    constructor() {
        super(...arguments);
        this.colors = [];
        this.selectedColor = '';
    }
    onCreate() {
        this.setColor = this.setColor.bind(this);
        this.close = this.close.bind(this);
        this.context = this.createCanvas();
        this.colors = this.options.annotation.colors.highlightColors;
        this.selectedColor = this.options.annotation.colors.stickyNoteColor;
        const toolbarElement = this.module.toolbarElement;
        (0,_AddTextAnnotationToolbar__WEBPACK_IMPORTED_MODULE_4__.createAddTextAnnotationToolbar)({
            colors: this.colors,
            selectedColor: this.selectedColor,
            onColorChanged: this.setColor,
            onClose: this.close,
        }, toolbarElement);
        this.store.viewer.beginModule(moduleLayerName);
    }
    onSave() {
        const promise = new Promise((resolve, reject) => {
            resolve();
        });
        return promise;
    }
    onRemove() {
        this.removeCanvasElements();
        this.context = null;
        const toolbarElement = this.module.toolbarElement;
        toolbarElement.innerHTML = '';
        this.store.viewer.endModule(moduleLayerName);
    }
    render(timestamp, state) {
        if (state.viewer.modeChanged && state.viewer.selectedModuleName !== moduleLayerName) {
            this.remove();
            return;
        }
        if (this.context &&
            (state.viewer.modeChanged ||
                state.pointer.positionChanged ||
                state.pointer.action ||
                state.canvas.canvasInvalidated)) {
            const ctx = this.context;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            const scale = state.canvas.pixelRatio * state.document.zoom;
            const s = 6 * scale;
            const h = 22 * scale;
            const rect = {
                w: 26 * scale,
                h,
                x: state.pointer.x.devicePixels - s,
                y: state.pointer.y.devicePixels - h,
            };
            let rectOnPage = false;
            for (const k in state.document.pageRects) {
                if (state.document.pageRects[k]) {
                    const p = state.document.pageRects[k];
                    const px2 = p.x + p.w;
                    const rx2 = rect.x + rect.w;
                    const py2 = p.y + p.h;
                    const ry2 = rect.y + rect.h;
                    if (rect.x >= p.x && rx2 <= px2 && rect.y >= p.y && ry2 <= py2) {
                        rectOnPage = true;
                        break;
                    }
                }
            }
            if (rectOnPage) {
                if (state.pointer.type === 'mouse') {
                    (0,_pdf_viewer_canvas_view_layers_canvasShapes__WEBPACK_IMPORTED_MODULE_3__.renderStickyNote)(ctx, scale, rect, this.selectedColor, '#000000');
                    this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.DEFAULT);
                }
                if (state.pointer.action === 'click') {
                    rect.y = rect.y;
                    this.createTextAnnotation(rect, this.selectedColor);
                    this.remove();
                    return;
                }
            }
            else {
                this.store.viewer.setCursorStyle(_pdf_viewer_canvas_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.NOT_ALLOWED);
            }
        }
    }
    setColor(color) {
        this.selectedColor = color;
        this.options.annotation.colors.stickyNoteColor = color;
    }
    close() {
        this.remove();
    }
    createTextAnnotation(point, color) {
        const pdfPoint = this.pdfApi.transformScreenPointToPdfPoint({
            x: point.x,
            y: point.y,
        }).pdfPoint;
        const annotation = {
            itemType: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.TEXT,
            color,
            author: this.options.viewer.general.user,
            page: pdfPoint.page,
            isOpen: true,
            pdfRect: {
                pdfX: pdfPoint.pdfX,
                pdfY: pdfPoint.pdfY,
                pdfW: 0,
                pdfH: 0,
                page: pdfPoint.page,
            },
        };
        this.pdfApi.createItem(annotation).then((item) => {
            const annot = item;
            const annotation = this.pdfApi.getItem(annot.id);
            if (annotation) {
                annotation.popup.isOpen = true;
                this.store.annotations.updateAnnotation(annotation);
                this.store.viewer.selectPopup({ id: annot.id, focus: true });
            }
            this.onAnnotationCreated(annot);
        });
    }
}


/***/ }),

/***/ "./src/modules/text-annotation/AddTextAnnotationToolbar.tsx":
/*!******************************************************************!*\
  !*** ./src/modules/text-annotation/AddTextAnnotationToolbar.tsx ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAddTextAnnotationToolbar": () => (/* binding */ createAddTextAnnotationToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/ColorPicker */ "./src/common/ColorPicker.tsx");







const createAddTextAnnotationToolbar = (props, element) => {
    const state = {
        colors: props.colors,
        selectedColor: props.selectedColor,
    };
    const actions = {
        setColor: (color) => ($state) => {
            props.onColorChanged(color);
            return Object.assign(Object.assign({}, $state), { selectedColor: color });
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(AddTextAnnotationToolbar, null);
    const AddTextAnnotationToolbar = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_1__.Toolbar, { allowWrap: true, alignCenter: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__.ToolbarItemGroup, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { colors: $state.colors, color: $state.selectedColor, icon: _common_icons__WEBPACK_IMPORTED_MODULE_4__.icons.fillColor, mode: "buttons", onChange: $actions.setColor })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__.ToolbarItemGroup, { pushRight: true },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_5__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_4__.icons.close, onClick: props.onClose }))));
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/modules/text-annotation/TextAnnotationModule.ts":
/*!*************************************************************!*\
  !*** ./src/modules/text-annotation/TextAnnotationModule.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextAnnotationModule": () => (/* binding */ TextAnnotationModule)
/* harmony export */ });
/* harmony import */ var _CanvasModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CanvasModule */ "./src/modules/CanvasModule.ts");
/* harmony import */ var _AddTextAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddTextAnnotationLayer */ "./src/modules/text-annotation/AddTextAnnotationLayer.ts");


class TextAnnotationModule extends _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModule {
    constructor() {
        super();
        this.toolbarElement = null;
        this.name = TextAnnotationModule.moduleInfo.name;
        this.activate = this.activate.bind(this);
    }
    onRegister() {
        this.toolbarElement = document.createElement('div');
        return {
            toolbar: this.toolbarElement,
        };
    }
    activate() {
        if (!this.canvasLayers['add']) {
            this.createCanvasLayer('add', _AddTextAnnotationLayer__WEBPACK_IMPORTED_MODULE_1__.AddTextAnnotationLayer);
        }
        else {
            this.removeCanvasLayer('add');
        }
    }
}
TextAnnotationModule.moduleInfo = {
    name: 'TextAnnotationModule',
    moduleType: _CanvasModule__WEBPACK_IMPORTED_MODULE_0__.CanvasModuleType.Tool,
    requiredFeatures: {
        annotate: true,
        fillFormFields: false,
    },
    translationKey: 'annotText.add',
    icon: 'stickyNote',
};


/***/ }),

/***/ "./src/pdf-viewer-api/ImageContainer.ts":
/*!**********************************************!*\
  !*** ./src/pdf-viewer-api/ImageContainer.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageContainer": () => (/* binding */ ImageContainer)
/* harmony export */ });
const isFirefox = /Firefox/i.test(navigator.userAgent);
class ImageContainer {
    constructor(image) {
        this._imageBitmap = null;
        this._imageData = null;
        this._htmlCanvas = null;
        if (image.bufferView) {
            if (image.hasImageData) {
                this._imageData = new ImageData(new Uint8ClampedArray(image.bufferView), image.width, image.height);
            }
            else {
                throw new Error('Cannot create an image container of image without imageData');
            }
            image.removeImageData();
            if (!isFirefox && typeof window.createImageBitmap === 'function') {
                createImageBitmap(this._imageData).then((imageBitmap) => {
                    this._imageBitmap = imageBitmap;
                });
            }
            else {
                this._htmlCanvas = document.createElement('canvas');
                this._htmlCanvas.width = image.width;
                this._htmlCanvas.height = image.height;
                const ctx = this._htmlCanvas.getContext('2d');
                ctx && ctx.putImageData(this._imageData, 0, 0);
            }
        }
    }
    get scaledImage() {
        if (this._imageBitmap) {
            return this._imageBitmap;
        }
        return this._htmlCanvas;
    }
    get imageData() {
        return this._imageData;
    }
    destroy() {
        this._imageBitmap = null;
        this._imageData = null;
        this._htmlCanvas = null;
    }
}


/***/ }),

/***/ "./src/pdf-viewer-api/PdfViewerApi.ts":
/*!********************************************!*\
  !*** ./src/pdf-viewer-api/PdfViewerApi.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PdfViewerApi": () => (/* binding */ PdfViewerApi)
/* harmony export */ });
/* harmony import */ var _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pdf-tools/four-heights-pdf-viewing */ "../../node_modules/@pdf-tools/four-heights-pdf-viewing/es6/PdfViewing.js");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums */ "./src/pdf-viewer-api/enums.ts");
/* harmony import */ var _PdfViewingWrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PdfViewingWrapper */ "./src/pdf-viewer-api/PdfViewingWrapper.ts");



const checkType = (object, typeName, methodName, optional = false) => {
    if (!optional && (object === null || typeof object !== typeName)) {
        throw new TypeError(`Method ${methodName} requires argument of type '${typeName}' but is '${typeof object}'`);
    }
};
const checkLicense = (instance) => {
    if (!instance)
        throw new Error('License is not set.');
};
class PdfViewerApi {
    constructor(pdfViewerApiOptions) {
        this.eventListeners = new Map();
        this.open = this.open.bind(this);
        this.save = this.save.bind(this);
        this.pdfViewerApiOptions = pdfViewerApiOptions;
    }
    open(pdfFile, fdfFiles, password, viewOptions, renderOptions, viewportSize) {
        checkLicense(this.instance);
        return this.instance.open(pdfFile, fdfFiles, password, viewOptions, renderOptions, viewportSize);
    }
    save(saveOptions) {
        checkLicense(this.instance);
        return this.instance.save(saveOptions);
    }
    close() {
        checkLicense(this.instance);
        return this.instance.close();
    }
    destroy() {
        checkLicense(this.instance);
        this.instance.destroy();
    }
    registerPdfStampFile(pdfStampFileName, data, onStampCreated) {
        checkLicense(this.instance);
        this.instance.registerPdfStampFile(pdfStampFileName, data, onStampCreated);
    }
    forceFlushCache() {
        checkLicense(this.instance);
        this.instance.forceFlushCache();
    }
    getMaxCacheSize() {
        checkLicense(this.instance);
        return this.instance.getMaxCacheSize();
    }
    setMaxCacheSize(cacheSize) {
        checkLicense(this.instance);
        this.instance.setMaxCacheSize(cacheSize);
    }
    getPageCount() {
        checkLicense(this.instance);
        return this.instance.getPageCount();
    }
    getPageNumber() {
        checkLicense(this.instance);
        return this.instance.getPageNumber();
    }
    getLastVisiblePage() {
        checkLicense(this.instance);
        return this.instance.getLastVisiblePage();
    }
    getFirstVisiblePage() {
        checkLicense(this.instance);
        return this.instance.getFirstVisiblePage();
    }
    setPageNumber(pageNumber) {
        checkType(pageNumber, 'number', 'setPageNumber');
        checkLicense(this.instance);
        this.instance.setPageNumber(pageNumber);
    }
    getRotation() {
        checkLicense(this.instance);
        return this.instance.getRotation();
    }
    setRotation(rotation) {
        checkType(rotation, 'number', 'setRotation');
        checkLicense(this.instance);
        this.instance.setRotation(rotation);
    }
    getZoom() {
        checkLicense(this.instance);
        return this.instance.getZoom();
    }
    setZoom(zoom, location) {
        checkType(zoom, 'number', 'setZoom');
        checkLicense(this.instance);
        this.instance.setZoom(zoom, location);
    }
    getScrollMaxPosition() {
        checkLicense(this.instance);
        return this.instance.getScrollMaxPosition();
    }
    getScrollPosition() {
        checkLicense(this.instance);
        return this.instance.getScrollPosition();
    }
    setScrollPosition(pos) {
        checkLicense(this.instance);
        this.instance.setScrollPosition(pos);
    }
    goTo(destination) {
        checkLicense(this.instance);
        this.instance.goTo(destination);
    }
    goToViewerDestination(destination) {
        checkLicense(this.instance);
        this.instance.goTo(destination);
    }
    goToRectangle(rectangle) {
        checkLicense(this.instance);
        this.instance.goToRectangle(rectangle);
    }
    isOpen() {
        checkLicense(this.instance);
        return this.instance.getIsOpen();
    }
    setPageLayoutMode(mode) {
        checkLicense(this.instance);
        this.instance.setPageLayoutMode(mode);
    }
    getPageLayoutMode() {
        checkLicense(this.instance);
        return this.instance.getPageLayoutMode();
    }
    setFitMode(fitMode) {
        checkLicense(this.instance);
        this.instance.setFitMode(fitMode);
    }
    getFitMode() {
        checkLicense(this.instance);
        return this.instance.getFitMode();
    }
    getBorderSize() {
        checkLicense(this.instance);
        return this.instance.getBorderSize();
    }
    setBorderSize(borderSize) {
        checkLicense(this.instance);
        const ret = this.instance.setBorderSize(borderSize);
        if (!ret.ok) {
            throw new Error(ret.message);
        }
    }
    getSlidingWindowSize() {
        checkLicense(this.instance);
        return this.instance.getSlidingWindowSize();
    }
    setSlidingWindowSize(slidingWindowSize) {
        checkType(slidingWindowSize, 'number', 'setSlidingWindowSize');
        checkLicense(this.instance);
        const ret = this.instance.setSlidingWindowSize(slidingWindowSize);
        if (!ret.ok) {
            throw new Error(ret.message);
        }
    }
    suspendDrawing() {
        checkLicense(this.instance);
        this.instance.suspendDrawing();
    }
    resumeDrawing() {
        checkLicense(this.instance);
        this.instance.resumeDrawing();
    }
    renderCanvas(context, options) {
        checkLicense(this.instance);
        this.instance.renderCanvas(context, options);
    }
    renderPage(pageNumber, width, height) {
        checkLicense(this.instance);
        return this.instance.renderPage(pageNumber, width, height);
    }
    rotatePage(pageNumber, direction) {
        checkLicense(this.instance);
        return this.instance.rotatePage(pageNumber, direction);
    }
    getPagePdfSize(pageNumber) {
        checkLicense(this.instance);
        return this.instance.getPagePdfSize(pageNumber);
    }
    setIgnoringPreferences(ignore) {
        checkLicense(this.instance);
        this.instance.setIgnoringPreferences(ignore);
    }
    getIgnoringPreferences() {
        checkLicense(this.instance);
        return this.instance.getIgnoringPreferences();
    }
    getProductVersion() {
        return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_0__.PdfViewing.Sdk.version;
    }
    getOutlines(parent) {
        checkLicense(this.instance);
        return this.instance.getOutlines(parent);
    }
    getTextFragmentOnPoint(point) {
        checkType(point, 'object', 'getTextFragmentOnPoint');
        checkLicense(this.instance);
        return this.instance.getTextFragmentOnPoint(point);
    }
    getWordOnPoint(point) {
        checkType(point, 'object', 'getWordOnPoint');
        checkLicense(this.instance);
        return this.instance.getWordOnPoint(point);
    }
    getTextSelection(startPoint, endPoint) {
        checkLicense(this.instance);
        return this.instance.getTextSelection(startPoint, endPoint);
    }
    getRectangularTextSelection(startPoint, endPoint) {
        checkLicense(this.instance);
        return this.instance.getRectangularTextSelection(startPoint, endPoint);
    }
    getText(startPoint, endPoint) {
        checkLicense(this.instance);
        return this.instance.getText(startPoint, endPoint);
    }
    getTextForRectangularSelection(startPoint, endPoint) {
        checkLicense(this.instance);
        return this.instance.getTextForRectangularSelection(startPoint, endPoint);
    }
    getAnnotationsOnPoint(point, onlySelectable = false) {
        checkLicense(this.instance);
        return this.instance.getAnnotationsOnPoint(point, onlySelectable);
    }
    getOpenPopups(firstPage, lastPage) {
        checkLicense(this.instance);
        return this.instance.getOpenPopups(firstPage, lastPage);
    }
    getItemsFromPage(page, category) {
        checkType(page, 'number', 'getItemsFromPage');
        checkType(category, 'number', 'getItemsFromPage');
        checkLicense(this.instance);
        if (category === _enums__WEBPACK_IMPORTED_MODULE_1__.PdfItemCategory.ANNOTATION) {
            return this.instance.getItemsFromPage(page, category);
        }
        else {
            return new Promise((resolve, reject) => {
                resolve({});
            });
        }
    }
    createItem(itemArgs) {
        checkType(itemArgs, 'object', 'createItem');
        checkLicense(this.instance);
        return this.instance.createItem(itemArgs);
    }
    getItem(id) {
        checkLicense(this.instance);
        return this.instance.getItem(id);
    }
    getItems(ids) {
        checkLicense(this.instance);
        return this.instance.getItems(ids);
    }
    updateItem(item) {
        checkType(item, 'object', 'updateItem');
        checkLicense(this.instance);
        return this.instance.updateItem(item);
    }
    deleteItem(item) {
        checkType(item, 'object', 'deleteItem');
        checkLicense(this.instance);
        return this.instance.deleteItem(item);
    }
    getStampInfo(args) {
        checkLicense(this.instance);
        return this.instance.getStampInfo(args);
    }
    getTextStampAspectRatio(stampText) {
        checkLicense(this.instance);
        return this.instance.getTextStampAspectRatio(stampText);
    }
    registerStampImage(image) {
        checkType(image, 'object', 'registerStampImage');
        checkLicense(this.instance);
        return this.instance.registerImage(image);
    }
    registerPdfPage(fileName, pageNumber) {
        checkType(fileName, 'string', 'registerPdfStamp');
        checkType(pageNumber, 'number', 'registerPdfStamp');
        checkLicense(this.instance);
        return this.instance.registerPdfPage(fileName, pageNumber);
    }
    hasChanges() {
        checkLicense(this.instance);
        return this.instance.hasChanges();
    }
    getSearchIterator(searchString, startPage, caseSensitive, wrapSearch, useRegex) {
        return this.instance.getSearchIterator(searchString, startPage, caseSensitive, wrapSearch, useRegex);
    }
    setLicenseKey(license) {
        try {
            this.instance = new _PdfViewingWrapper__WEBPACK_IMPORTED_MODULE_2__.PdfViewingWrapper(license, this.pdfViewerApiOptions);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    getSupportedFeatures() {
        return this.instance.getSupportedFeatures();
    }
    transformScreenPointToPdfPoint(point, page, guaranteePointIsOnPage) {
        checkType(point.x, 'number', 'x');
        checkType(point.y, 'number', 'y');
        checkLicense(this.instance);
        if (page !== undefined) {
            checkType(page, 'number', 'page');
        }
        if (guaranteePointIsOnPage !== undefined) {
            checkType(guaranteePointIsOnPage, 'boolean', 'transformScreenPointToPdf');
        }
        return this.instance.transformScreenPointToPdfPoint(point, page, guaranteePointIsOnPage);
    }
    getClosestPointOnPdfByScreenPoint(point, padding = 0, page) {
        checkLicense(this.instance);
        return this.instance.getClosestPointOnPdfByScreenPoint(point, page, padding);
    }
    transformPdfPointToScreenPoint(pdfPoint) {
        checkType(pdfPoint.pdfX, 'number', 'pdfX');
        checkType(pdfPoint.pdfY, 'number', 'pdfY');
        checkType(pdfPoint.page, 'number', 'page');
        checkLicense(this.instance);
        return this.instance.transformPdfPointToScreenPoint(pdfPoint);
    }
    transformScreenRectToPdfRect(rect, page) {
        checkType(rect.x, 'number', 'x');
        checkType(rect.y, 'number', 'y');
        checkType(rect.w, 'number', 'w');
        checkType(rect.h, 'number', 'h');
        checkLicense(this.instance);
        return this.instance.transformScreenRectToPdfRect(rect, page);
    }
    transformPdfPageRectToScreenRect(pdfRect) {
        checkType(pdfRect.pdfX, 'number', 'pdfX');
        checkType(pdfRect.pdfY, 'number', 'pdfY');
        checkType(pdfRect.pdfW, 'number', 'pdfW');
        checkType(pdfRect.pdfH, 'number', 'pdfH');
        checkType(pdfRect.page, 'number', 'page');
        checkLicense(this.instance);
        let ret = this.instance.transformPdfPageRectToScreenRect(pdfRect);
        return ret;
    }
    transformPdfLengthToScreenLength(pdfLength) {
        checkType(pdfLength, 'number', 'transformPdfLengthToScreenLength');
        checkLicense(this.instance);
        return this.instance.transformPdfLengthToScreenLength(pdfLength);
    }
    transformScreenLengthToPdfLength(screenLength) {
        checkType(screenLength, 'number', 'transformScreenLengthToPdfLength');
        checkLicense(this.instance);
        return this.instance.transformScreenLengthToPdfLength(screenLength);
    }
    transformQuadrilateralToViewport(quadrilateral) {
        checkLicense(this.instance);
        return this.instance.transformQuadrilateralToViewport(quadrilateral);
    }
    getPageScreenRect(pageNumber) {
        checkLicense(this.instance);
        return this.instance.getPageScreenRect(pageNumber);
    }
    addEventListener(type, listener) {
        checkLicense(this.instance);
        this.instance.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        checkLicense(this.instance);
        this.instance.removeEventListener(type, listener);
    }
}


/***/ }),

/***/ "./src/pdf-viewer-api/annotationDefaultBehaviors.ts":
/*!**********************************************************!*\
  !*** ./src/pdf-viewer-api/annotationDefaultBehaviors.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "annotationDefaultBehaviors": () => (/* binding */ annotationDefaultBehaviors)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ "./src/pdf-viewer-api/enums.ts");

const annotationDefaultBehaviors = {
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.TEXT]: [true, false, true, true, false, false, false, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.LINK]: [false, false, false, true, false, false, false, false, true, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.FREE_TEXT]: [true, false, true, true, true, true, true, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.LINE]: [true, false, true, true, false, true, true, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SQUARE]: [true, false, true, true, false, true, true, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.CIRCLE]: [true, false, true, true, false, true, true, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.POLYGON]: [true, false, true, true, false, true, true, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.POLY_LINE]: [true, false, true, true, false, true, true, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.HIGHLIGHT]: [true, false, true, false, false, false, false, true, false, true],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.UNDERLINE]: [true, false, true, false, false, false, false, true, false, true],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SQUIGGLY]: [true, false, true, false, false, false, false, true, false, true],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.STRIKE_OUT]: [true, false, true, false, false, false, false, true, false, true],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.STAMP]: [true, false, true, true, true, true, false, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.CARET]: [true, false, true, false, false, false, false, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.INK]: [true, false, true, true, false, true, true, true, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.POPUP]: [false, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.FILE_ATTACHMENT]: [false, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SOUND]: [false, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.MOVIE]: [false, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.WIDGET]: [true, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SCREEN]: [false, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.PRINTER_MARK]: [false, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.TRAP_NET]: [false, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.WATERMARK]: [false, false, false, false, false, false, false, false, false, false],
    [_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.THREED]: [false, false, false, false, false, false, false, false, false, false],
};


/***/ }),

/***/ "./src/pdf-viewer-api/enums.ts":
/*!*************************************!*\
  !*** ./src/pdf-viewer-api/enums.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationBorderStyle": () => (/* binding */ AnnotationBorderStyle),
/* harmony export */   "DocumentChange": () => (/* binding */ DocumentChange),
/* harmony export */   "PdfActionType": () => (/* binding */ PdfActionType),
/* harmony export */   "PdfDestinationType": () => (/* binding */ PdfDestinationType),
/* harmony export */   "PdfFitMode": () => (/* binding */ PdfFitMode),
/* harmony export */   "PdfItemCategory": () => (/* binding */ PdfItemCategory),
/* harmony export */   "PdfItemType": () => (/* binding */ PdfItemType),
/* harmony export */   "PdfPageLayoutMode": () => (/* binding */ PdfPageLayoutMode),
/* harmony export */   "RotationDirection": () => (/* binding */ RotationDirection),
/* harmony export */   "SearchResultType": () => (/* binding */ SearchResultType),
/* harmony export */   "StampAnnotationColor": () => (/* binding */ StampAnnotationColor),
/* harmony export */   "StampType": () => (/* binding */ StampType),
/* harmony export */   "WidgetType": () => (/* binding */ WidgetType)
/* harmony export */ });
var PdfItemCategory;
(function (PdfItemCategory) {
    PdfItemCategory[PdfItemCategory["ANNOTATION"] = 1] = "ANNOTATION";
    PdfItemCategory[PdfItemCategory["TEXT_FRAGMENT"] = 2] = "TEXT_FRAGMENT";
    PdfItemCategory[PdfItemCategory["OUTLINE"] = 3] = "OUTLINE";
    PdfItemCategory[PdfItemCategory["DESTINATION"] = 4] = "DESTINATION";
    PdfItemCategory[PdfItemCategory["CONTENT_ELEMENT"] = 5] = "CONTENT_ELEMENT";
})(PdfItemCategory || (PdfItemCategory = {}));
var AnnotationBorderStyle;
(function (AnnotationBorderStyle) {
    AnnotationBorderStyle[AnnotationBorderStyle["SOLID"] = 0] = "SOLID";
    AnnotationBorderStyle[AnnotationBorderStyle["DASHED"] = 1] = "DASHED";
    AnnotationBorderStyle[AnnotationBorderStyle["BEVELED"] = 2] = "BEVELED";
    AnnotationBorderStyle[AnnotationBorderStyle["INSET"] = 3] = "INSET";
    AnnotationBorderStyle[AnnotationBorderStyle["UNDERLINE"] = 4] = "UNDERLINE";
})(AnnotationBorderStyle || (AnnotationBorderStyle = {}));
var StampAnnotationColor;
(function (StampAnnotationColor) {
    StampAnnotationColor[StampAnnotationColor["GREEN"] = 0] = "GREEN";
    StampAnnotationColor[StampAnnotationColor["RED"] = 1] = "RED";
    StampAnnotationColor[StampAnnotationColor["BLUE"] = 2] = "BLUE";
})(StampAnnotationColor || (StampAnnotationColor = {}));
var WidgetType;
(function (WidgetType) {
    WidgetType[WidgetType["CHECK_BOX"] = 1] = "CHECK_BOX";
    WidgetType[WidgetType["RADIO_BUTTON"] = 2] = "RADIO_BUTTON";
    WidgetType[WidgetType["TEXT_BOX"] = 3] = "TEXT_BOX";
    WidgetType[WidgetType["LIST_BOX"] = 4] = "LIST_BOX";
    WidgetType[WidgetType["COMBO_BOX"] = 5] = "COMBO_BOX";
})(WidgetType || (WidgetType = {}));
var PdfItemType;
(function (PdfItemType) {
    PdfItemType[PdfItemType["UNKNOWN"] = 0] = "UNKNOWN";
    PdfItemType[PdfItemType["TEXT"] = 1] = "TEXT";
    PdfItemType[PdfItemType["LINK"] = 2] = "LINK";
    PdfItemType[PdfItemType["FREE_TEXT"] = 3] = "FREE_TEXT";
    PdfItemType[PdfItemType["LINE"] = 4] = "LINE";
    PdfItemType[PdfItemType["SQUARE"] = 5] = "SQUARE";
    PdfItemType[PdfItemType["CIRCLE"] = 6] = "CIRCLE";
    PdfItemType[PdfItemType["POLYGON"] = 7] = "POLYGON";
    PdfItemType[PdfItemType["POLY_LINE"] = 8] = "POLY_LINE";
    PdfItemType[PdfItemType["HIGHLIGHT"] = 9] = "HIGHLIGHT";
    PdfItemType[PdfItemType["UNDERLINE"] = 10] = "UNDERLINE";
    PdfItemType[PdfItemType["SQUIGGLY"] = 11] = "SQUIGGLY";
    PdfItemType[PdfItemType["STRIKE_OUT"] = 12] = "STRIKE_OUT";
    PdfItemType[PdfItemType["STAMP"] = 13] = "STAMP";
    PdfItemType[PdfItemType["CARET"] = 14] = "CARET";
    PdfItemType[PdfItemType["INK"] = 15] = "INK";
    PdfItemType[PdfItemType["POPUP"] = 16] = "POPUP";
    PdfItemType[PdfItemType["FILE_ATTACHMENT"] = 17] = "FILE_ATTACHMENT";
    PdfItemType[PdfItemType["SOUND"] = 18] = "SOUND";
    PdfItemType[PdfItemType["MOVIE"] = 19] = "MOVIE";
    PdfItemType[PdfItemType["WIDGET"] = 20] = "WIDGET";
    PdfItemType[PdfItemType["SCREEN"] = 21] = "SCREEN";
    PdfItemType[PdfItemType["PRINTER_MARK"] = 22] = "PRINTER_MARK";
    PdfItemType[PdfItemType["TRAP_NET"] = 23] = "TRAP_NET";
    PdfItemType[PdfItemType["WATERMARK"] = 24] = "WATERMARK";
    PdfItemType[PdfItemType["THREED"] = 25] = "THREED";
})(PdfItemType || (PdfItemType = {}));
var PdfDestinationType;
(function (PdfDestinationType) {
    PdfDestinationType[PdfDestinationType["FIT"] = 1] = "FIT";
    PdfDestinationType[PdfDestinationType["FITH"] = 2] = "FITH";
    PdfDestinationType[PdfDestinationType["FITV"] = 3] = "FITV";
    PdfDestinationType[PdfDestinationType["FITR"] = 4] = "FITR";
    PdfDestinationType[PdfDestinationType["FITB"] = 5] = "FITB";
    PdfDestinationType[PdfDestinationType["FITBH"] = 6] = "FITBH";
    PdfDestinationType[PdfDestinationType["FITBV"] = 7] = "FITBV";
    PdfDestinationType[PdfDestinationType["XYZ"] = 8] = "XYZ";
})(PdfDestinationType || (PdfDestinationType = {}));
var PdfFitMode;
(function (PdfFitMode) {
    PdfFitMode[PdfFitMode["NONE"] = 0] = "NONE";
    PdfFitMode[PdfFitMode["FIT_WIDTH"] = 1] = "FIT_WIDTH";
    PdfFitMode[PdfFitMode["FIT_PAGE"] = 2] = "FIT_PAGE";
})(PdfFitMode || (PdfFitMode = {}));
var PdfPageLayoutMode;
(function (PdfPageLayoutMode) {
    PdfPageLayoutMode[PdfPageLayoutMode["SINGLE_PAGE"] = 0] = "SINGLE_PAGE";
    PdfPageLayoutMode[PdfPageLayoutMode["ONE_COLUMN"] = 1] = "ONE_COLUMN";
    PdfPageLayoutMode[PdfPageLayoutMode["TWO_COLUMN_LEFT"] = 2] = "TWO_COLUMN_LEFT";
    PdfPageLayoutMode[PdfPageLayoutMode["TWO_COLUMN_RIGHT"] = 3] = "TWO_COLUMN_RIGHT";
    PdfPageLayoutMode[PdfPageLayoutMode["TWO_PAGE_LEFT"] = 4] = "TWO_PAGE_LEFT";
    PdfPageLayoutMode[PdfPageLayoutMode["TWO_PAGE_RIGHT"] = 5] = "TWO_PAGE_RIGHT";
})(PdfPageLayoutMode || (PdfPageLayoutMode = {}));
var PdfActionType;
(function (PdfActionType) {
    PdfActionType[PdfActionType["UNKNOWN"] = 0] = "UNKNOWN";
    PdfActionType[PdfActionType["GO_TO"] = 1] = "GO_TO";
    PdfActionType[PdfActionType["URI"] = 2] = "URI";
})(PdfActionType || (PdfActionType = {}));
var StampType;
(function (StampType) {
    StampType[StampType["TEXT"] = 0] = "TEXT";
    StampType[StampType["IMAGE"] = 1] = "IMAGE";
})(StampType || (StampType = {}));
var SearchResultType;
(function (SearchResultType) {
    SearchResultType[SearchResultType["OK"] = 0] = "OK";
    SearchResultType[SearchResultType["NO_RESULT"] = 1] = "NO_RESULT";
    SearchResultType[SearchResultType["END"] = 2] = "END";
})(SearchResultType || (SearchResultType = {}));
var DocumentChange;
(function (DocumentChange) {
    DocumentChange[DocumentChange["NONE"] = 0] = "NONE";
    DocumentChange[DocumentChange["ANNOTATION"] = 1] = "ANNOTATION";
    DocumentChange[DocumentChange["CONTENT"] = 2] = "CONTENT";
})(DocumentChange || (DocumentChange = {}));
var RotationDirection;
(function (RotationDirection) {
    RotationDirection[RotationDirection["CLOCKWISE"] = 90] = "CLOCKWISE";
    RotationDirection[RotationDirection["COUNTERCLOCKWISE"] = 270] = "COUNTERCLOCKWISE";
})(RotationDirection || (RotationDirection = {}));


/***/ }),

/***/ "./src/pdf-viewer-api/index.ts":
/*!*************************************!*\
  !*** ./src/pdf-viewer-api/index.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationBorderStyle": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.AnnotationBorderStyle),
/* harmony export */   "DocumentChange": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.DocumentChange),
/* harmony export */   "FileType": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.FileType),
/* harmony export */   "PdfActionType": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.PdfActionType),
/* harmony export */   "PdfDestinationType": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.PdfDestinationType),
/* harmony export */   "PdfFitMode": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode),
/* harmony export */   "PdfItemCategory": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.PdfItemCategory),
/* harmony export */   "PdfItemType": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.PdfItemType),
/* harmony export */   "PdfPageLayoutMode": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.PdfPageLayoutMode),
/* harmony export */   "PdfViewerApi": () => (/* reexport safe */ _PdfViewerApi__WEBPACK_IMPORTED_MODULE_2__.PdfViewerApi),
/* harmony export */   "RotationDirection": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.RotationDirection),
/* harmony export */   "SearchResultType": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.SearchResultType),
/* harmony export */   "StampAnnotationColor": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.StampAnnotationColor),
/* harmony export */   "StampType": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.StampType),
/* harmony export */   "WidgetType": () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.WidgetType)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./src/pdf-viewer-api/types.ts");
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums */ "./src/pdf-viewer-api/enums.ts");
/* harmony import */ var _PdfViewerApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PdfViewerApi */ "./src/pdf-viewer-api/PdfViewerApi.ts");





/***/ }),

/***/ "./src/pdf-viewer-api/types.ts":
/*!*************************************!*\
  !*** ./src/pdf-viewer-api/types.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileType": () => (/* binding */ FileType)
/* harmony export */ });
var FileType;
(function (FileType) {
    FileType[FileType["Pdf"] = 0] = "Pdf";
    FileType[FileType["Fdf"] = 1] = "Fdf";
})(FileType || (FileType = {}));


/***/ }),

/***/ "./src/pdf-viewer-canvas/CanvasEvents.ts":
/*!***********************************************!*\
  !*** ./src/pdf-viewer-canvas/CanvasEvents.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasEvents": () => (/* binding */ CanvasEvents)
/* harmony export */ });
class CanvasEvents {
    constructor(element) {
        this.eventListeners = new Map();
        this.trackEvents = true;
        this.startPosX = 0;
        this.startPosY = 0;
        this.multiTouch = false;
        this.pinch = false;
        this.dragging = false;
        this.lastTouchPosX = 0;
        this.lastTouchPosY = 0;
        this.lastPinchDiv = 0;
        this.lastPinchPosX = 0;
        this.lastPinchPosY = 0;
        this.lastTouchX1 = 0;
        this.lastTouchY1 = 0;
        this.lastTouchX2 = 0;
        this.lastTouchY2 = 0;
        this.clickTimer = null;
        this.clickDuration = 250;
        this.dblClickTimer = null;
        this.dblClickDuration = 250;
        this.longPressTimer = null;
        this.longPressDuration = 750;
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onStart = this.onStart.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this);
        this.onMove = this.onMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onEnd = this.onEnd.bind(this);
        this.suspend = this.suspend.bind(this);
        this.resume = this.resume.bind(this);
        this.element = element;
        this.element.addEventListener('mousedown', this.onMouseDown, {
            passive: true,
        });
        this.element.addEventListener('mousemove', this.onMouseMove, {
            passive: true,
        });
        this.element.addEventListener('touchstart', this.onTouchStart, {
            passive: false,
        });
        window.addEventListener('pdfwebviewer.DragMoveHandlerStart', () => {
            this.suspend();
        }, { passive: true });
        window.addEventListener('pdfwebviewer.DragMoveHandlerEnd', () => {
            this.resume();
        }, { passive: true });
    }
    addEventListener(type, listener) {
        if (this.eventListeners.has(type)) {
            ;
            this.eventListeners.get(type).push(listener);
        }
        else {
            this.eventListeners.set(type, [listener]);
        }
    }
    removeEventListener(type, listener) {
        if (this.eventListeners.has(type)) {
            let listeners = this.eventListeners.get(type);
            listeners = listeners.filter((listenerInArray) => listenerInArray !== listener);
            if (listeners.length !== 0) {
                this.eventListeners.set(type, listeners);
            }
            else {
                this.eventListeners.delete(type);
            }
        }
    }
    suspend() {
        this.trackEvents = false;
        this.element.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('touchmove', this.onTouchMove);
    }
    resume() {
        if (!this.trackEvents) {
            this.trackEvents = true;
            this.element.addEventListener('mousemove', this.onMouseMove, {
                passive: true,
            });
        }
    }
    dispatchEvent(type, args) {
        if (this.eventListeners.has(type)) {
            const listeners = this.eventListeners.get(type);
            listeners.forEach((listener) => listener(args));
        }
    }
    clearClickTimer() {
        if (this.clickTimer !== null) {
            window.clearTimeout(this.clickTimer);
            this.clickTimer = null;
        }
    }
    clearLongPressTimer() {
        if (this.longPressTimer !== null) {
            window.clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
    }
    clearDblClickTimer() {
        if (this.dblClickTimer !== null) {
            window.clearTimeout(this.dblClickTimer);
            this.dblClickTimer = null;
        }
    }
    mouseToCanvasPointerEvent(e) {
        return {
            clientX: e.clientX,
            clientY: e.clientY,
            movementX: e.movementX,
            movementY: e.movementY,
            buttons: e.buttons,
            type: 'mouse',
        };
    }
    touchToCanvasPointerEvent(e) {
        const event = {
            clientX: e.touches[0].clientX,
            clientY: e.touches[0].clientY,
            movementX: e.touches[0].clientX - this.lastTouchPosX,
            movementY: e.touches[0].clientY - this.lastTouchPosY,
            buttons: e.touches.length === 1 ? 1 : 4,
            type: 'touch',
        };
        this.lastTouchPosX = e.touches[0].clientX;
        this.lastTouchPosY = e.touches[0].clientY;
        return event;
    }
    getPinchPos(e) {
        const x1 = e.touches[0].clientX;
        const y1 = e.touches[0].clientY;
        const x2 = e.touches[1].clientX;
        const y2 = e.touches[1].clientY;
        const vx = Math.abs(x1 - x2);
        const vy = Math.abs(y1 - y2);
        const distance = Math.sqrt(vx * vx + vy * vy);
        const clientX = Math.min(x1, x2) + vx;
        const clientY = Math.min(y1, y2) + vy;
        return {
            clientX,
            clientY,
            distance,
        };
    }
    touchToCanvasPointerPinchEvent(e) {
        const { clientX, clientY, distance } = this.getPinchPos(e);
        const event = {
            clientX,
            clientY,
            movementX: clientX - this.lastPinchPosX,
            movementY: clientY - this.lastPinchPosY,
            distance,
            movementDistance: distance - this.lastPinchDiv,
            buttons: 1,
            type: 'touch',
        };
        this.lastPinchPosX = event.clientX;
        this.lastPinchPosY = event.clientY;
        this.lastPinchDiv = distance;
        return event;
    }
    onMouseDown(e) {
        if (this.trackEvents) {
            const event = this.mouseToCanvasPointerEvent(e);
            this.onStart(event);
            window.addEventListener('mouseup', this.onMouseUp, { passive: true });
        }
    }
    onTouchStart(e) {
        e.preventDefault();
        this.pinch = false;
        if (this.trackEvents) {
            if (e.touches.length === 0) {
                return;
            }
            else if (e.touches.length === 1) {
                this.lastTouchPosX = e.touches[0].clientX;
                this.lastTouchPosY = e.touches[0].clientY;
                const event = this.touchToCanvasPointerEvent(e);
                this.onStart(event);
                window.addEventListener('touchmove', this.onTouchMove, {
                    passive: false,
                });
                window.addEventListener('touchend', this.onTouchEnd, { passive: false });
            }
            else if (e.touches.length === 2) {
                this.clearClickTimer();
                this.clearDblClickTimer();
                this.clearLongPressTimer();
                this.multiTouch = true;
                const { clientX, clientY, distance } = this.getPinchPos(e);
                this.lastPinchDiv = distance;
                this.lastPinchPosX = clientX;
                this.lastPinchPosY = clientY;
                this.lastTouchX1 = e.touches[0].clientX;
                this.lastTouchY1 = e.touches[0].clientY;
                this.lastTouchX2 = e.touches[1].clientX;
                this.lastTouchY2 = e.touches[1].clientY;
                window.addEventListener('touchmove', this.onTouchMove, {
                    passive: false,
                });
                window.addEventListener('touchend', this.onTouchEnd, { passive: false });
            }
        }
    }
    onStart(e) {
        this.startPosX = e.clientX;
        this.startPosY = e.clientY;
        this.dragging = false;
        if (!this.dblClickTimer) {
            this.clickTimer = window.setTimeout(() => {
                this.clickTimer = null;
            }, this.clickDuration);
        }
        this.longPressTimer = window.setTimeout(() => {
            this.longPressTimer = null;
            this.dispatchEvent('pointerlongpress', e);
        }, this.longPressDuration);
        this.dispatchEvent('pointerdown', e);
    }
    onMouseMove(e) {
        const event = this.mouseToCanvasPointerEvent(e);
        this.onMove(event);
    }
    onTouchMove(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!e.touches) {
            return;
        }
        if (e.touches.length === 1 && !this.multiTouch) {
            const event = this.touchToCanvasPointerEvent(e);
            this.onMove(event);
        }
        else if (e.touches.length === 2) {
            const event = this.touchToCanvasPointerPinchEvent(e);
            const x1 = e.touches[0].clientX;
            const y1 = e.touches[0].clientY;
            const x2 = e.touches[1].clientX;
            const y2 = e.touches[1].clientY;
            const dX1 = x1 - this.lastTouchX1;
            const dY1 = y1 - this.lastTouchY1;
            const dX2 = x2 - this.lastTouchX2;
            const dY2 = y2 - this.lastTouchY2;
            const sX1 = Math.sign(dX1);
            const sY1 = Math.sign(dY1);
            const sX2 = Math.sign(dX2);
            const sY2 = Math.sign(dY2);
            if ((sX1 === sX2 && sY1 === sY2) ||
                ((sX1 === sX2 || dX1 === 0 || dX2 === 0) && (sY1 === sY2 || dY1 === 0 || dY2 === 0)) ||
                Math.max(Math.abs(event.movementX), Math.abs(event.movementY)) >
                    Math.abs(event.movementDistance)) {
                event.buttons = 4;
                this.onMove(event);
                this.pinch = false;
            }
            else {
                this.dispatchEvent('pinch', event);
                this.pinch = true;
            }
            this.lastTouchX1 = e.touches[0].clientX;
            this.lastTouchY1 = e.touches[0].clientY;
            this.lastTouchX2 = e.touches[1].clientX;
            this.lastTouchY2 = e.touches[1].clientY;
        }
    }
    onMove(e) {
        this.dispatchEvent('pointermove', e);
        if (this.clickTimer || this.longPressTimer) {
            if (Math.abs(this.startPosX - e.clientX) > 5 || Math.abs(this.startPosY - e.clientY) > 5) {
                this.clearLongPressTimer();
                this.clearClickTimer();
                this.dispatchEvent('pointerstartdrag', e);
                this.dragging = true;
            }
        }
        else if (e.buttons > 0 && !this.dragging) {
            this.dispatchEvent('pointerstartdrag', e);
            this.dragging = true;
        }
    }
    onMouseUp(e) {
        const event = this.mouseToCanvasPointerEvent(e);
        this.onEnd(event);
        window.removeEventListener('mouseup', this.onMouseUp);
    }
    onTouchEnd(e) {
        if (e.touches.length === 0) {
            this.multiTouch = false;
            const event = {
                clientX: this.lastTouchPosX,
                clientY: this.lastTouchPosY,
                movementX: 0,
                movementY: 0,
                buttons: 0,
                type: 'touch',
            };
            this.onEnd(event);
            window.removeEventListener('touchmove', this.onTouchMove);
            window.removeEventListener('touchend', this.onTouchEnd);
        }
    }
    onEnd(e) {
        this.dispatchEvent('pointerup', e);
        if (this.dblClickTimer !== null) {
            this.clearDblClickTimer();
            this.dispatchEvent('pointerdblclick', e);
        }
        else if (this.clickTimer !== null) {
            this.dispatchEvent('pointerclick', {
                clientX: this.startPosX,
                clientY: this.startPosY,
                movementX: e.movementX,
                movementY: e.movementY,
                buttons: e.buttons,
                type: e.type,
            });
            this.dblClickTimer = window.setTimeout(() => {
                this.dblClickTimer = null;
            }, this.dblClickDuration);
        }
        if (this.dragging) {
            this.dispatchEvent('pointerenddrag', e);
        }
        this.lastTouchX1 = 0;
        this.lastTouchY1 = 0;
        this.lastTouchX2 = 0;
        this.lastTouchY2 = 0;
        this.lastTouchPosX = 0;
        this.lastTouchPosY = 0;
        this.lastPinchPosX = 0;
        this.lastPinchPosY = 0;
        this.clearClickTimer();
        this.clearLongPressTimer();
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/PdfViewerCanvas.ts":
/*!**************************************************!*\
  !*** ./src/pdf-viewer-canvas/PdfViewerCanvas.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PdfViewerCanvas": () => (/* binding */ PdfViewerCanvas)
/* harmony export */ });
/* harmony import */ var _state_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state/store */ "./src/pdf-viewer-canvas/state/store.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_TooltipManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/TooltipManager */ "./src/common/TooltipManager.ts");
/* harmony import */ var _CanvasEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CanvasEvents */ "./src/pdf-viewer-canvas/CanvasEvents.ts");
/* harmony import */ var _modules_stamp_annotation_StampAnnotationModule__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../modules/stamp-annotation/StampAnnotationModule */ "./src/modules/stamp-annotation/StampAnnotationModule.ts");
/* harmony import */ var _view_layers_PdfDocumentLayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./view-layers/PdfDocumentLayer */ "./src/pdf-viewer-canvas/view-layers/PdfDocumentLayer.ts");
/* harmony import */ var _view_layers_ScrollLayer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./view-layers/ScrollLayer */ "./src/pdf-viewer-canvas/view-layers/ScrollLayer.ts");
/* harmony import */ var _view_layers_BusyStateLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./view-layers/BusyStateLayer */ "./src/pdf-viewer-canvas/view-layers/BusyStateLayer.ts");
/* harmony import */ var _view_layers_AnnotationSelectionLayer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./view-layers/AnnotationSelectionLayer */ "./src/pdf-viewer-canvas/view-layers/AnnotationSelectionLayer.ts");
/* harmony import */ var _view_layers_TextSelectionLayer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./view-layers/TextSelectionLayer */ "./src/pdf-viewer-canvas/view-layers/TextSelectionLayer.ts");
/* harmony import */ var _state_viewer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _common_Tools__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../common/Tools */ "./src/common/Tools.ts");
/* harmony import */ var _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @pdf-tools/four-heights-pdf-viewing */ "../../node_modules/@pdf-tools/four-heights-pdf-viewing/es6/PdfViewing.js");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../common/utils */ "./src/common/utils.ts");
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../modules */ "./src/modules/index.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
















class PdfViewerCanvas {
    constructor(containerElement, license, options) {
        var _a;
        this.eventListeners = new Map();
        this.documentLoaded = false;
        this.renderLoopRunning = false;
        if (!containerElement) {
            throw { error: 'PdfViewerCanvas container element is null' };
        }
        this.options = options;
        this.annotTimer = 0;
        this.onResize = this.onResize.bind(this);
        this.startRenderLoop = this.startRenderLoop.bind(this);
        this.updateViewLayerContext = this.updateViewLayerContext.bind(this);
        this.onKeyboardShortcuts = this.onKeyboardShortcuts.bind(this);
        this.dispatchEvent = this.dispatchEvent.bind(this);
        this.onCanvasPointerDown = this.onCanvasPointerDown.bind(this);
        this.onCanvasPointerMove = this.onCanvasPointerMove.bind(this);
        this.onCanvasPointerUp = this.onCanvasPointerUp.bind(this);
        this.onCanvasPointerClick = this.onCanvasPointerClick.bind(this);
        this.onCanvasPointerDblClick = this.onCanvasPointerDblClick.bind(this);
        this.onCanvasPointerLongPress = this.onCanvasPointerLongPress.bind(this);
        this.onCanvasPointerStartDrag = this.onCanvasPointerStartDrag.bind(this);
        this.onCanvasPointerEndDrag = this.onCanvasPointerEndDrag.bind(this);
        this.onCanvasPointerPinch = this.onCanvasPointerPinch.bind(this);
        this.onMouseWheel = this.onMouseWheel.bind(this);
        this.onDocumentOpened = this.onDocumentOpened.bind(this);
        this.onDocumentClosed = this.onDocumentClosed.bind(this);
        this.onCanvasInvalidated = this.onCanvasInvalidated.bind(this);
        this.onFirstVisiblePageChanged = this.onFirstVisiblePageChanged.bind(this);
        this.onLastVisiblePageChanged = this.onLastVisiblePageChanged.bind(this);
        this.onPageNumberChanged = this.onPageNumberChanged.bind(this);
        this.onZoomChanged = this.onZoomChanged.bind(this);
        this.onFitModeChanged = this.onFitModeChanged.bind(this);
        this.onPageLayoutModeChanged = this.onPageLayoutModeChanged.bind(this);
        this.onBusyStateChanged = this.onBusyStateChanged.bind(this);
        this.onRotationChanged = this.onRotationChanged.bind(this);
        this.onItemCreated = this.onItemCreated.bind(this);
        this.onItemUpdated = this.onItemUpdated.bind(this);
        this.onItemDeleted = this.onItemDeleted.bind(this);
        this.onPageChanged = this.onPageChanged.bind(this);
        this.onTextSelected = this.onTextSelected.bind(this);
        this.onHtmlDocumentSelectionChanged = this.onHtmlDocumentSelectionChanged.bind(this);
        this.onApiError = this.onApiError.bind(this);
        this.beforeUnloadCallback = this.beforeUnloadCallback.bind(this);
        this.getAnnotations = this.getAnnotations.bind(this);
        this.openRoutine = this.openRoutine.bind(this);
        this.print = this.print.bind(this);
        this.close = this.close.bind(this);
        this.searchIterator = null;
        this.store = (0,_state_store__WEBPACK_IMPORTED_MODULE_0__.createStore)();
        const pdfViewerApiOptions = {
            onlyAuthorCanEdit: (_a = options.annotation.onlyAuthorCanEdit) !== null && _a !== void 0 ? _a : false,
            viewOnly: options.viewer.general.viewOnly,
            user: options.viewer.general.user,
            allowPopups: options.modules.includes(_modules__WEBPACK_IMPORTED_MODULE_15__.PopupModule),
            annotationPermissionCallback: options.annotation.annotationPermissionCallback,
        };
        this.pdfViewerApi = new _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfViewerApi(pdfViewerApiOptions);
        const licenseIsValid = this.pdfViewerApi.setLicenseKey(license);
        if (!licenseIsValid) {
            throw new Error('Invalid License');
        }
        this.element = containerElement;
        this.element.classList.add('pwv-ViewerCanvas');
        const viewerContainer = document.createElement('div');
        viewerContainer.classList.add('pwv-canvas-container');
        this.element.appendChild(viewerContainer);
        this.toolbarElement = document.createElement('div');
        if (this.licenseFeatures.annotate) {
            this.toolbarElement.classList.add('pwv-canvas-toolbar');
            viewerContainer.appendChild(this.toolbarElement);
        }
        const canvasLayers = document.createElement('div');
        canvasLayers.classList.add('pwv-canvas-layers');
        viewerContainer.appendChild(canvasLayers);
        this.viewLayersElement = document.createElement('div');
        canvasLayers.appendChild(this.viewLayersElement);
        viewerContainer.appendChild(canvasLayers);
        this.viewLayers = [];
        this.modules = [];
        this.resizeObserver = new ResizeObserver(this.onResize);
        this.resizeObserver.observe(canvasLayers);
        this.pdfViewerApi.addEventListener('firstVisiblePage', this.onFirstVisiblePageChanged);
        this.pdfViewerApi.addEventListener('lastVisiblePage', this.onLastVisiblePageChanged);
        this.pdfViewerApi.addEventListener('pageNumber', this.onPageNumberChanged);
        this.pdfViewerApi.addEventListener('zoom', this.onZoomChanged);
        this.pdfViewerApi.addEventListener('fitMode', this.onFitModeChanged);
        this.pdfViewerApi.addEventListener('pageLayoutMode', this.onPageLayoutModeChanged);
        this.pdfViewerApi.addEventListener('busyState', this.onBusyStateChanged);
        this.pdfViewerApi.addEventListener('canvasInvalidated', this.onCanvasInvalidated);
        this.pdfViewerApi.addEventListener('itemCreated', this.onItemCreated);
        this.pdfViewerApi.addEventListener('itemUpdated', this.onItemUpdated);
        this.pdfViewerApi.addEventListener('itemDeleted', this.onItemDeleted);
        this.pdfViewerApi.addEventListener('pageChanged', this.onPageChanged);
        this.pdfViewerApi.addEventListener('rotation', this.onRotationChanged);
        this.pdfViewerApi.addEventListener('error', this.onApiError);
        if (this.options.viewer.general.promptOnUnsavedChange) {
            window.addEventListener('beforeunload', this.beforeUnloadCallback);
        }
        document.addEventListener('selectionchange', this.onHtmlDocumentSelectionChanged);
        this.canvasEvents = new _CanvasEvents__WEBPACK_IMPORTED_MODULE_4__.CanvasEvents(canvasLayers);
        this.canvasEvents.suspend();
        this.canvasEvents.addEventListener('pointerdown', this.onCanvasPointerDown);
        this.canvasEvents.addEventListener('pointermove', this.onCanvasPointerMove);
        this.canvasEvents.addEventListener('pointerup', this.onCanvasPointerUp);
        this.canvasEvents.addEventListener('pointerclick', this.onCanvasPointerClick);
        this.canvasEvents.addEventListener('pointerdblclick', this.onCanvasPointerDblClick);
        this.canvasEvents.addEventListener('pointerlongpress', this.onCanvasPointerLongPress);
        this.canvasEvents.addEventListener('pointerstartdrag', this.onCanvasPointerStartDrag);
        this.canvasEvents.addEventListener('pointerenddrag', this.onCanvasPointerEndDrag);
        this.canvasEvents.addEventListener('pinch', this.onCanvasPointerPinch);
        this.viewLayersElement.addEventListener('wheel', this.onMouseWheel, {
            passive: false,
        });
        document.addEventListener('keydown', this.onKeyboardShortcuts, {
            passive: false,
        });
        _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.loadTranslations(this.options.viewer.general.language || 'en');
        _common_TooltipManager__WEBPACK_IMPORTED_MODULE_3__.tooltipManager.setType(this.options.viewer.general.tooltips || 'title');
        if (this.options.modules) {
            if (this.licenseFeatures.annotate &&
                this.options.modules.find((m) => m === _modules_stamp_annotation_StampAnnotationModule__WEBPACK_IMPORTED_MODULE_5__.StampAnnotationModule) &&
                this.options.annotation.options.pdfStampFiles) {
                this.registerPdfStamps(this.options.annotation.options.pdfStampFiles);
            }
        }
        requestAnimationFrame(() => {
            this.dispatchEvent('appLoaded', true);
        });
    }
    get licenseFeatures() {
        const licenseFeatures = this.pdfViewerApi.getSupportedFeatures();
        return {
            annotate: !this.options.viewer.general.viewOnly &&
                _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__.PdfViewing.LicenseFeature.Annotate ===
                    (licenseFeatures & _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__.PdfViewing.LicenseFeature.Annotate),
            fillFormFields: !this.options.viewer.general.viewOnly &&
                _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__.PdfViewing.LicenseFeature.FillFormFields ===
                    (licenseFeatures & _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__.PdfViewing.LicenseFeature.FillFormFields),
            pageRotation: !this.options.viewer.general.viewOnly &&
                _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__.PdfViewing.LicenseFeature.PageRotation ===
                    (licenseFeatures & _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__.PdfViewing.LicenseFeature.PageRotation),
        };
    }
    open(pdfFile, fdfFiles, password, viewOptions, renderOptions) {
        const _viewOptions = viewOptions ? viewOptions : {};
        const containerRect = this.viewLayersElement.getBoundingClientRect();
        const viewportSize = {
            width: containerRect.width,
            height: containerRect.height,
        };
        return this.openRoutine(this.pdfViewerApi.open, pdfFile, fdfFiles, password, _viewOptions, renderOptions, viewportSize);
    }
    save(saveOptions) {
        const promises = new Array();
        for (let i = 0; i < this.modules.length; i++) {
            promises.push(this.modules[i].onSave());
        }
        const savePromise = new Promise((resolve, reject) => {
            Promise.all(promises).then(() => {
                return this.pdfViewerApi
                    .save(saveOptions)
                    .then((buffer) => {
                    resolve(buffer);
                })
                    .catch((err) => {
                    reject(err);
                });
            });
        });
        return savePromise;
    }
    openFDF(pdfBuffer, fdfBuffer, password) {
        return this.open({ data: pdfBuffer }, [{ data: fdfBuffer }], password);
    }
    openUri(pdfUri, password, pdfAuthorization) {
        return this.open({ uri: pdfUri }, [], password);
    }
    openFDFUri(pdfUri, fdfUri, password, pdfAuthorization, fdfAuthorization) {
        return this.open({ uri: pdfUri }, [{ uri: pdfUri }], password);
    }
    openBlob(blob, password) {
        return this.open({ data: blob }, [], password);
    }
    openFDFBlob(pdfBlob, fdfBlob, password) {
        return this.open({ data: pdfBlob }, [{ data: fdfBlob }], password);
    }
    saveFile(asFdf) {
        return new Promise((resolve, reject) => {
            const saveOptions = {};
            if (asFdf) {
                saveOptions.fileType = _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.FileType.Fdf;
            }
            this.save(saveOptions).then((blob) => {
                blob.arrayBuffer().then((arrayBuffer) => {
                    resolve(new Uint8Array(arrayBuffer));
                });
            });
        });
    }
    close() {
        this.unRegisterModules();
        this.onDocumentClosed();
        if (this.searchIterator) {
            this.searchIterator.close();
            this.searchIterator = null;
        }
        return this.pdfViewerApi.close();
    }
    destroy() {
        this.stopRenderLoop();
        if (this.searchIterator) {
            this.searchIterator.close();
        }
        this.resizeObserver.disconnect();
        if (this.annotTimer) {
            window.clearTimeout(this.annotTimer);
        }
        this.eventListeners.clear();
        document.removeEventListener('keydown', this.onKeyboardShortcuts);
        window.removeEventListener('beforeunload', this.beforeUnloadCallback);
        this.pdfViewerApi.removeEventListener('firstVisiblePage', this.onFirstVisiblePageChanged);
        this.pdfViewerApi.removeEventListener('lastVisiblePage', this.onLastVisiblePageChanged);
        this.pdfViewerApi.removeEventListener('pageNumber', this.onPageNumberChanged);
        this.pdfViewerApi.removeEventListener('zoom', this.onZoomChanged);
        this.pdfViewerApi.removeEventListener('fitMode', this.onFitModeChanged);
        this.pdfViewerApi.removeEventListener('pageLayoutMode', this.onPageLayoutModeChanged);
        this.pdfViewerApi.removeEventListener('busyState', this.onBusyStateChanged);
        this.pdfViewerApi.removeEventListener('canvasInvalidated', this.onCanvasInvalidated);
        this.pdfViewerApi.removeEventListener('itemCreated', this.onItemCreated);
        this.pdfViewerApi.removeEventListener('itemUpdated', this.onItemUpdated);
        this.pdfViewerApi.removeEventListener('itemDeleted', this.onItemDeleted);
        this.pdfViewerApi.removeEventListener('pageChanged', this.onPageChanged);
        this.pdfViewerApi.removeEventListener('rotation', this.onRotationChanged);
        this.pdfViewerApi.removeEventListener('error', this.onApiError);
        this.canvasEvents.suspend();
        this.canvasEvents.removeEventListener('pointerdown', this.onCanvasPointerDown);
        this.canvasEvents.removeEventListener('pointermove', this.onCanvasPointerMove);
        this.canvasEvents.removeEventListener('pointerup', this.onCanvasPointerUp);
        this.canvasEvents.removeEventListener('pointerclick', this.onCanvasPointerClick);
        this.canvasEvents.removeEventListener('pointerdblclick', this.onCanvasPointerDblClick);
        this.canvasEvents.removeEventListener('pointerlongpress', this.onCanvasPointerLongPress);
        this.canvasEvents.removeEventListener('pointerstartdrag', this.onCanvasPointerStartDrag);
        this.canvasEvents.removeEventListener('pointerenddrag', this.onCanvasPointerEndDrag);
        this.canvasEvents.removeEventListener('pinch', this.onCanvasPointerPinch);
        this.viewLayersElement.removeEventListener('wheel', this.onMouseWheel);
        this.pdfViewerApi.destroy();
        this.viewLayers = [];
        this.modules = [];
        while (this.element.firstChild) {
            this.element.removeChild(this.element.firstChild);
        }
    }
    hasChanges() {
        return this.pdfViewerApi.hasChanges();
    }
    getProductVersion() {
        return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__.PdfViewing.Sdk.version;
    }
    getZoom() {
        return this.pdfViewerApi.getZoom();
    }
    setZoom(zoom, location) {
        this.pdfViewerApi.setZoom(zoom, location);
    }
    zoomIn(location) {
        const zoom = this.pdfViewerApi.getZoom();
        this.pdfViewerApi.setZoom(this.getNextZoomInLevel(zoom), location);
    }
    zoomOut(location) {
        const zoom = this.pdfViewerApi.getZoom();
        this.pdfViewerApi.setZoom(this.getNextZoomOutLevel(zoom), location);
    }
    getPageCount() {
        return this.pdfViewerApi.getPageCount();
    }
    getPageNumber() {
        return this.pdfViewerApi.getPageNumber();
    }
    rotatePage(pageNumber, direction) {
        const { textSelection, selectedAnnotationId, selectedModuleName } = this.store.getState().viewer;
        if (textSelection) {
            const textSelectionLayer = this.viewLayers.find((v) => v instanceof _view_layers_TextSelectionLayer__WEBPACK_IMPORTED_MODULE_10__.TextSelectionLayer);
            if (textSelectionLayer) {
                textSelectionLayer.clearSelection();
            }
        }
        if (selectedAnnotationId) {
            this.store.viewer.deselectAnnotation();
        }
        if (selectedModuleName) {
            this.store.viewer.endModule(selectedModuleName);
        }
        return this.pdfViewerApi.rotatePage(pageNumber, direction);
    }
    setPageNumber(page) {
        if (page < 1) {
            page = 1;
        }
        else {
            const pageCount = this.pdfViewerApi.getPageCount();
            if (page > pageCount) {
                page = pageCount;
            }
        }
        this.pdfViewerApi.setPageNumber(page);
    }
    scrollDown(distance = 100) {
        if (distance === 0) {
            return;
        }
        const pos = this.pdfViewerApi.getScrollPosition();
        pos.y += distance * window.devicePixelRatio;
        this.pdfViewerApi.setScrollPosition(pos);
    }
    scrollUp(distance = 100) {
        if (distance === 0) {
            return;
        }
        const pos = this.pdfViewerApi.getScrollPosition();
        pos.y -= distance * window.devicePixelRatio;
        this.pdfViewerApi.setScrollPosition(pos);
    }
    scrollLeft(distance = 100) {
        if (distance === 0) {
            return;
        }
        const pos = this.pdfViewerApi.getScrollPosition();
        pos.x -= distance * window.devicePixelRatio;
        this.pdfViewerApi.setScrollPosition(pos);
    }
    scrollRight(distance = 100) {
        if (distance === 0) {
            return;
        }
        const pos = this.pdfViewerApi.getScrollPosition();
        pos.x += distance * window.devicePixelRatio;
        this.pdfViewerApi.setScrollPosition(pos);
    }
    scrollMove(distanceVertical = 0, distanceHorizontal = 0) {
        if (distanceVertical === 0 && distanceHorizontal === 0) {
            return;
        }
        const pos = this.pdfViewerApi.getScrollPosition();
        pos.y += distanceVertical * window.devicePixelRatio;
        pos.x += distanceHorizontal * window.devicePixelRatio;
        this.pdfViewerApi.setScrollPosition(pos);
    }
    nextPage() {
        const page = this.pdfViewerApi.getPageNumber();
        const pageCount = this.pdfViewerApi.getPageCount();
        if (page < pageCount) {
            this.pdfViewerApi.setPageNumber(page + 1);
        }
    }
    previousPage() {
        const page = this.pdfViewerApi.getPageNumber();
        if (page > 1) {
            this.pdfViewerApi.setPageNumber(page - 1);
        }
    }
    getFitMode() {
        return this.pdfViewerApi.getFitMode();
    }
    setFitMode(fitMode) {
        this.pdfViewerApi.setFitMode(fitMode);
    }
    getPageLayoutMode() {
        return this.pdfViewerApi.getPageLayoutMode();
    }
    setPageLayoutMode(pageLayoutMode) {
        this.pdfViewerApi.setPageLayoutMode(pageLayoutMode);
    }
    getRotation() {
        return this.pdfViewerApi.getRotation();
    }
    setRotation(rotation) {
        this.pdfViewerApi.setRotation(rotation);
    }
    renderPage(pageNumber, width, height) {
        return this.pdfViewerApi.renderPage(pageNumber, width, height);
    }
    getDocumentOutline() {
        return this.getOutlines(null);
    }
    goTo(pdfDestination) {
        this.pdfViewerApi.goTo(pdfDestination);
    }
    updateCanvasSearchState(state) {
        this.store.search.start({
            caseSensitive: state.caseSensitive,
            searchString: state.searchString,
            reverse: false,
            useRegex: state.useRegex,
            wrapSearch: state.wrapSearch,
        });
    }
    doSearch() {
        const s = this.store.getState().search;
        if (this.searchIterator &&
            this.searchIterator.match instanceof _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_13__.PdfViewing.Pdf.Content.TextSelection) {
            const list = this.searchIterator.match.textArea;
            let page = 1;
            const quadrilateralList = [];
            for (let i = 0; i < list.size; i++) {
                const quad = list.get(i);
                if (quad.pageNumber > page) {
                    page = quad.pageNumber;
                }
                quadrilateralList.push(quad);
            }
            this.store.search.updateMatch({
                match: quadrilateralList,
                page,
            });
            const q = list.get(0);
            const { bottomLeft, bottomRight, topRight, topLeft, pageNumber } = q;
            const x = Math.min(bottomLeft.x, bottomRight.x, topRight.x, topLeft.x);
            const y = Math.min(bottomLeft.y, bottomRight.y, topRight.y, topLeft.y);
            const padding = 10;
            const rect = {
                pdfX: x - padding,
                pdfY: y - padding,
                pdfW: Math.max(bottomLeft.x, bottomRight.x, topRight.x, topLeft.x) - x + 2 * padding,
                pdfH: Math.max(bottomLeft.y, bottomRight.y, topRight.y, topLeft.y) - y + 2 * padding,
                page: pageNumber,
            };
            this.pdfViewerApi.goToRectangle(rect);
        }
    }
    startSearch(searchString, startPage, caseSensitive, wrapSearch, useRegex) {
        if (this.searchIterator) {
            this.endSearch();
        }
        this.searchIterator = this.pdfViewerApi.getSearchIterator(searchString, startPage, caseSensitive, wrapSearch, useRegex);
        if (!this.searchIterator) {
            return;
        }
        this.searchIterator.getNext().then((hasResult) => {
            if (hasResult) {
                this.doSearch();
            }
            else {
                this.endSearch();
            }
        });
    }
    nextSearchMatch() {
        if (this.searchIterator) {
            this.searchIterator.getNext().then((hasResult) => {
                if (hasResult) {
                    this.doSearch();
                }
            });
        }
    }
    previousSearchMatch() {
        if (this.searchIterator) {
            return this.searchIterator.getPrevious().then((hasResult) => {
                if (hasResult) {
                    this.doSearch();
                }
            });
        }
    }
    endSearch() {
        if (this.searchIterator) {
            this.searchIterator.close();
            this.searchIterator = null;
            this.store.search.clear();
        }
    }
    resetViewerMode() {
        this.store.viewer.setDefaultMode();
    }
    getAnnotationsFromPage(page) {
        return new Promise((resolve, reject) => {
            this.pdfViewerApi
                .getItemsFromPage(page, _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemCategory.ANNOTATION)
                .then((items) => {
                this.store.annotations.setPageAnnotations(items);
                resolve(items);
            })
                .catch((err) => {
                reject(err);
            });
        });
    }
    goToAnnotation(annotation, action) {
        this.pdfViewerApi.goToRectangle(annotation.pdfRect);
        if (action === 'select') {
            this.dispatchEvent('itemSelected', annotation);
        }
    }
    print() {
        this.activateModule('PrintServiceModule', null);
    }
    getModules() {
        return this.modules;
    }
    activateModule(moduleName, args) {
        const module = this.modules.find((m) => {
            return m.name == moduleName;
        });
        if (module) {
            module.activate(args);
            this.dispatchEvent('moduleActivated', moduleName);
        }
    }
    deactivateModule(moduleName) {
        this.dispatchEvent('moduleActivated', moduleName);
        const module = this.modules.find((m) => {
            return m.name == moduleName;
        });
        if (module) {
            module.deactivate();
        }
    }
    getSelectedText() {
        const { textSelection, textSelectionType } = this.store.getState().viewer;
        let text = undefined;
        if (textSelection) {
            const { startPoint, endPoint } = textSelection;
            text =
                textSelectionType === 'rectangular'
                    ? this.pdfViewerApi.getTextForRectangularSelection(startPoint, endPoint)
                    : this.pdfViewerApi.getText(startPoint, endPoint);
        }
        return text;
    }
    addEventListener(type, listener) {
        if (this.eventListeners.has(type)) {
            ;
            this.eventListeners.get(type).push(listener);
        }
        else {
            this.eventListeners.set(type, [listener]);
        }
    }
    removeEventListener(type, listener) {
        if (this.eventListeners.has(type)) {
            let listeners = this.eventListeners.get(type);
            listeners = listeners.filter((listenerInArray) => listenerInArray !== listener);
            if (listeners.length !== 0) {
                this.eventListeners.set(type, listeners);
            }
            else {
                this.eventListeners.delete(type);
            }
        }
    }
    suspendCanvasEvents() {
        this.canvasEvents.suspend();
    }
    resumeCanvasEvents() {
        this.canvasEvents.resume();
    }
    dispatchEvent(type, args) {
        if (this.eventListeners.has(type)) {
            const listeners = this.eventListeners.get(type);
            listeners.forEach((listener) => listener(args));
        }
    }
    getOutlines(parent) {
        return __awaiter(this, void 0, void 0, function* () {
            const outlineItems = yield this.pdfViewerApi.getOutlines(parent);
            for (const item of outlineItems) {
                if (item.hasDescendants) {
                    const children = yield this.getOutlines(item);
                    item.descendants = children;
                }
            }
            return outlineItems;
        });
    }
    openRoutine(openFunction, ...args) {
        return new Promise((resolve, reject) => {
            if (this.pdfViewerApi.isOpen()) {
                this.close();
            }
            requestAnimationFrame(() => {
                openFunction(...args)
                    .then(() => {
                    this.onDocumentOpened();
                    resolve({});
                })
                    .catch((error) => {
                    if (error.message === 'The authentication failed due to a wrong password.') {
                        reject(new Error('password required'));
                    }
                    else {
                        reject(new Error('unsupported file'));
                    }
                });
            });
        });
    }
    onDocumentOpened() {
        this.registerModules();
        this.documentLoaded = true;
        this.element.classList.add('pwv-ViewerCanvas--documentLoaded');
        this.dispatchEvent('pageLayoutMode', this.pdfViewerApi.getPageLayoutMode());
        this.dispatchEvent('firstVisiblePage', this.pdfViewerApi.getFirstVisiblePage());
        this.dispatchEvent('lastVisiblePage', this.pdfViewerApi.getLastVisiblePage());
        this.dispatchEvent('pageNumber', this.pdfViewerApi.getPageNumber());
        this.dispatchEvent('zoom', this.pdfViewerApi.getZoom());
        const containerRect = this.viewLayersElement.getBoundingClientRect();
        this.store.canvas.resize({
            cssWidth: containerRect.width,
            cssHeight: containerRect.height,
        });
        this.startRenderLoop();
        const document = this.store.getState().document;
        window.setTimeout(() => {
            this.canvasEvents.resume();
            this.element.classList.add('pwv-ViewerCanvas--documentLoaded');
        }, 100);
    }
    onDocumentClosed() {
        this.canvasEvents.suspend();
        this.documentLoaded = false;
        this.element.classList.remove('pwv-ViewerCanvas--documentLoaded');
        this.stopRenderLoop();
        this.store.loadDefaultState();
    }
    startRenderLoop() {
        const viewLayers = this.viewLayers;
        const modules = this.modules;
        const loop = (timestamp) => {
            const state = this.store.getState();
            if (this.renderLoopRunning) {
                this.store.resetChangedState();
                if (state.viewer.cursorStyleChanged) {
                    this.viewLayersElement.style.cursor = state.viewer.cursorStyle;
                }
                for (let i = 0; i < viewLayers.length; i++) {
                    const res = viewLayers[i].render(timestamp, state);
                    if (res === false) {
                        break;
                    }
                }
                for (let i = 0; i < modules.length; i++) {
                    modules[i].render(timestamp, state);
                }
                requestAnimationFrame(loop);
            }
        };
        this.renderLoopRunning = true;
        requestAnimationFrame(loop);
    }
    stopRenderLoop() {
        this.renderLoopRunning = false;
    }
    registerPdfStamps(pdfStampFiles) {
        const pdfStampConfigs = this.options.annotation.options.stamps.filter((s) => s.pdfStampFileName);
        const pdfStampConfigMap = pdfStampConfigs.reduce(function (acc, obj) {
            let key = obj.pdfStampFileName;
            if (!acc[key]) {
                acc[key] = 0;
            }
            ++acc[key];
            return acc;
        }, {});
        const onStampCreated = (pdfStamp) => {
            if (pdfStampConfigMap.hasOwnProperty(pdfStamp.pdfStampFileName)) {
                const stamp = this.options.annotation.options.stamps.find((s) => s.pdfStampFileName === pdfStamp.pdfStampFileName && s.pageNumber === pdfStamp.pageNumber);
                if (stamp) {
                    stamp.thumbnail = pdfStamp.thumbnail;
                    stamp.aspectRatio = pdfStamp.aspectRatio;
                }
            }
            else {
                this.options.annotation.options.stamps.push(pdfStamp);
            }
        };
        pdfStampFiles.forEach((stampFile) => {
            const data = (0,_common_Tools__WEBPACK_IMPORTED_MODULE_12__.imageDataUrlToUint8Array)(stampFile.data);
            const pdfStampFileName = stampFile.pdfStampFileName ? stampFile.pdfStampFileName : '';
            this.pdfViewerApi.registerPdfStampFile(pdfStampFileName, data, onStampCreated);
        });
    }
    registerModules() {
        const viewLayers = [
            _view_layers_PdfDocumentLayer__WEBPACK_IMPORTED_MODULE_6__.PdfDocumentLayer,
            _view_layers_BusyStateLayer__WEBPACK_IMPORTED_MODULE_8__.BusyStateLayer,
            _view_layers_AnnotationSelectionLayer__WEBPACK_IMPORTED_MODULE_9__.AnnotationSelectionLayer,
            _view_layers_TextSelectionLayer__WEBPACK_IMPORTED_MODULE_10__.TextSelectionLayer,
            _view_layers_ScrollLayer__WEBPACK_IMPORTED_MODULE_7__.ScrollLayer,
        ];
        viewLayers.forEach((viewLayerBaseClass) => {
            const viewLayer = new viewLayerBaseClass();
            viewLayer.register(this, this.dispatchEvent);
            this.viewLayers.push(viewLayer);
        });
        const modules = this.options.modules.filter(({ moduleInfo }) => (!moduleInfo.requiredFeatures.annotate ||
            (moduleInfo.requiredFeatures.annotate && this.licenseFeatures.annotate)) &&
            (!moduleInfo.requiredFeatures.fillFormFields ||
                (moduleInfo.requiredFeatures.fillFormFields && this.licenseFeatures.fillFormFields)));
        if (modules) {
            modules.forEach((module) => {
                const m = new module();
                this.modules.push(m);
                const viewerCanvas = this;
                const reg = m.register(this.viewLayersElement, this.store, this.pdfViewerApi, viewerCanvas, this.options);
                if (reg.toolbar && this.toolbarElement) {
                    this.toolbarElement.appendChild(reg.toolbar);
                }
                if (reg.contextbar) {
                    this.store.viewer.addContextBarItem(reg.contextbar);
                }
            });
        }
        this.updateCanvasSize();
    }
    unRegisterModules() {
        this.viewLayers = [];
        this.store.viewer.clearContextBarItems();
        this.toolbarElement.innerHTML = '';
        this.viewLayersElement.innerHTML = '';
        this.modules.splice(0, this.modules.length);
    }
    updateViewLayerContext() {
        const pixelRatio = window.devicePixelRatio;
        this.store.canvas.setPixelRatio(pixelRatio);
        const rect = this.viewLayersElement.getBoundingClientRect();
        const maxScroll = this.pdfViewerApi.getScrollMaxPosition();
        const scrollPosition = this.pdfViewerApi.getScrollPosition();
        const devicePixelsWidth = rect.width * pixelRatio + (maxScroll.x > 0 ? maxScroll.x : scrollPosition.x * 2);
        const devicePixelsHeight = rect.height * pixelRatio + (maxScroll.y > 0 ? maxScroll.y : scrollPosition.y * 2);
        const zoom = this.pdfViewerApi.getZoom();
        this.store.document.resize({ zoom, devicePixelsHeight, devicePixelsWidth });
        this.store.scroll.scrollChanged({
            cssLeft: scrollPosition.x,
            cssTop: scrollPosition.y,
        });
        const state = this.store.getState();
        const pageRects = {};
        for (let page = this.pdfViewerApi.getFirstVisiblePage(); page <= this.pdfViewerApi.getLastVisiblePage(); page++) {
            pageRects[page] = this.pdfViewerApi.getPageScreenRect(page);
        }
        this.store.document.updatePageRects(pageRects);
    }
    onMouseWheel(e) {
        if (e.deltaY !== 0) {
            if (e.ctrlKey) {
                e.preventDefault();
                e.cancelBubble = true;
                const containerRect = this.viewLayersElement.getBoundingClientRect();
                const x = e.clientX - containerRect.left;
                const y = e.clientY - containerRect.top;
                if (e.deltaY < 0) {
                    this.zoomIn({ x, y });
                }
                else {
                    this.zoomOut({ x, y });
                }
            }
            else if (e.shiftKey) {
                e.preventDefault();
                e.cancelBubble = true;
                const distance = e.deltaY > 0 ? 100 : -100;
                this.scrollRight(distance);
            }
            else {
                e.preventDefault();
                e.cancelBubble = true;
                const distance = e.deltaY > 0 ? 100 : -100;
                this.scrollDown(distance);
            }
        }
        else if (e.deltaX > 0) {
            this.scrollRight();
        }
        else if (e.deltaX < 0) {
            this.scrollLeft();
        }
        else if (e.deltaZ < 0) {
            this.zoomIn();
        }
        else if (e.deltaZ > 0) {
            this.zoomOut();
        }
    }
    transformPointer(e) {
        const containerRect = this.viewLayersElement.getBoundingClientRect();
        const x = e.clientX - containerRect.left;
        const y = e.clientY - containerRect.top;
        return {
            cssX: x,
            cssY: y,
            isDown: e.buttons === 1,
            type: e.type,
        };
    }
    onCanvasPointerClick(e) {
        const p = this.transformPointer(e);
        this.store.pointer.update(p);
        this.store.pointer.setAction('click');
    }
    onCanvasPointerDblClick(e) {
        const p = this.transformPointer(e);
        this.store.pointer.update(p);
        this.store.pointer.setAction('dblclick');
    }
    onCanvasPointerLongPress(e) {
        const p = this.transformPointer(e);
        this.store.pointer.update(p);
        this.store.pointer.setAction('longpress');
    }
    onCanvasPointerStartDrag(e) {
        this.store.pointer.setAction('startdrag');
    }
    onCanvasPointerEndDrag(e) {
        this.store.pointer.setAction('enddrag');
    }
    onCanvasPointerPinch(e) {
        const containerRect = this.viewLayersElement.getBoundingClientRect();
        const x = (e.clientX - containerRect.left) * devicePixelRatio;
        const y = (e.clientY - containerRect.top) * devicePixelRatio;
        const zoom = this.pdfViewerApi.getZoom();
        const zoomDistance = (e.movementDistance / 200) * zoom;
        const newZoom = zoom + zoomDistance;
        this.setZoom(newZoom, { x, y });
    }
    onCanvasPointerDown(e) {
        const p = this.transformPointer(e);
        this.store.pointer.update(p);
        this.store.startPointer.update(p);
    }
    onCanvasPointerUp(e) {
        const p = this.transformPointer(e);
        this.store.pointer.update(p);
    }
    onCanvasPointerMove(e) {
        if (e.buttons < 2) {
            const p = this.transformPointer(e);
            this.store.pointer.update(p);
        }
        else if (e.buttons === 4) {
            this.scrollMove(e.movementY * -1, e.movementX * -1);
            this.store.viewer.setCursorStyle(_state_viewer__WEBPACK_IMPORTED_MODULE_11__.CursorStyle.GRABBING);
        }
    }
    onKeyboardShortcuts(e) {
        const rect = this.element.getBoundingClientRect();
        if (rect.width + rect.height === 0) {
            return;
        }
        const { shortcuts } = this.options;
        if (Object.keys(shortcuts).length > 0) {
            const keyboardCommands = (0,_common_utils__WEBPACK_IMPORTED_MODULE_14__.getKeyboardCommands)(e, shortcuts);
            if (!keyboardCommands.length) {
                return;
            }
            keyboardCommands.forEach((cmd) => {
                switch (cmd) {
                    case 'zoomIn':
                        e.preventDefault();
                        this.zoomIn();
                        break;
                    case 'zoomOut':
                        e.preventDefault();
                        this.zoomOut();
                        break;
                    case 'nextPage':
                        e.preventDefault();
                        this.nextPage();
                        break;
                    case 'previousPage':
                        e.preventDefault();
                        this.previousPage();
                        break;
                    case 'scrollDown':
                        e.preventDefault();
                        this.scrollDown();
                        break;
                    case 'scrollUp':
                        e.preventDefault();
                        this.scrollUp();
                        break;
                    case 'scrollLeft':
                        e.preventDefault();
                        this.scrollLeft();
                        break;
                    case 'scrollRight':
                        e.preventDefault();
                        this.scrollRight();
                        break;
                    case 'firstPage':
                        e.preventDefault();
                        this.setPageNumber(1);
                        break;
                    case 'lastPage':
                        e.preventDefault();
                        this.setPageNumber(this.getPageCount());
                        break;
                    case 'releaseSelection':
                        const viewerMode = this.store.getState().viewer.mode;
                        if (viewerMode === _state_viewer__WEBPACK_IMPORTED_MODULE_11__.ViewerMode.TEXT_SELECTED) {
                            e.preventDefault();
                            e.cancelBubble = true;
                            this.store.viewer.setTextSelection({ selection: null, type: null });
                            this.store.viewer.setTextSelectionState(null);
                            break;
                        }
                        if (viewerMode === _state_viewer__WEBPACK_IMPORTED_MODULE_11__.ViewerMode.ANNOTATION_SELECTED) {
                            e.preventDefault();
                            e.cancelBubble = true;
                            this.store.viewer.deselectAnnotation();
                            break;
                        }
                        break;
                    case 'copy':
                        if (this.options.viewer.permissions.allowCopyText) {
                            const documentSelection = document.getSelection();
                            if (documentSelection && !documentSelection.isCollapsed) {
                                return;
                            }
                            e.preventDefault();
                            e.cancelBubble = true;
                            (0,_state_viewer__WEBPACK_IMPORTED_MODULE_11__.copyTextToClipboard)(this.getSelectedText() || '');
                        }
                        break;
                    case 'resetZoom':
                        e.preventDefault();
                        this.setZoom(1);
                        break;
                    case 'fitToPage':
                        e.preventDefault();
                        this.setFitMode(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode.FIT_PAGE);
                        break;
                    case 'fitToWidth':
                        e.preventDefault();
                        this.setFitMode(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode.FIT_WIDTH);
                        break;
                    case 'rotateView':
                        if (this.options.viewer.permissions.allowRotateView) {
                            e.preventDefault();
                            const r = this.getRotation();
                            const rotation = r >= 270 ? 0 : r + 90;
                            this.setRotation(rotation);
                        }
                        break;
                    case 'cancelEditAnnotation':
                        const { selectedModuleName } = this.store.getState().viewer;
                        if (selectedModuleName) {
                            this.store.viewer.endModule(selectedModuleName);
                            e.preventDefault();
                            break;
                        }
                }
            });
        }
        else if (e.key === 'Escape') {
            const { selectedModuleName, mode } = this.store.getState().viewer;
            if (selectedModuleName) {
                this.store.viewer.endModule(selectedModuleName);
            }
            const viewerMode = mode;
            if (viewerMode === _state_viewer__WEBPACK_IMPORTED_MODULE_11__.ViewerMode.TEXT_SELECTED) {
                this.store.viewer.setTextSelection({ selection: null, type: null });
                this.store.viewer.setTextSelectionState(null);
            }
            if (viewerMode === _state_viewer__WEBPACK_IMPORTED_MODULE_11__.ViewerMode.ANNOTATION_SELECTED) {
                this.store.viewer.deselectAnnotation();
            }
        }
    }
    onResize(entries, observer) {
        const containerRect = this.viewLayersElement.getBoundingClientRect();
        if (containerRect.width === 0 || containerRect.height === 0) {
            return;
        }
        this.updateCanvasSize();
    }
    onHtmlDocumentSelectionChanged() {
        const documentSelection = document.getSelection();
        if (documentSelection && !documentSelection.isCollapsed) {
            const viewerMode = this.store.getState().viewer.mode;
            if (viewerMode === _state_viewer__WEBPACK_IMPORTED_MODULE_11__.ViewerMode.TEXT_SELECTED) {
                this.store.viewer.setTextSelection({ selection: null, type: null });
                this.store.viewer.setTextSelectionState(null);
            }
        }
    }
    updateCanvasSize() {
        const containerRect = this.viewLayersElement.getBoundingClientRect();
        const pixelRatio = window.devicePixelRatio;
        this.viewLayers.forEach((viewLayer) => {
            viewLayer.resize(containerRect.width, containerRect.height, pixelRatio);
        });
        this.modules.forEach((module) => {
            module.resize(containerRect.width, containerRect.height);
        });
        this.store.canvas.resize({
            cssWidth: containerRect.width,
            cssHeight: containerRect.height,
        });
        this.store.canvas.setCanvasInvalidated(true);
    }
    onCanvasInvalidated() {
        this.store.canvas.setCanvasInvalidated(true);
        this.updateViewLayerContext();
    }
    onFirstVisiblePageChanged(page) {
        this.store.document.fistVisiblePageChanged(page);
        this.maybeGetAnnotations(this.store.getState().document.firstVisiblePage, this.store.getState().document.lastVisiblePage);
        this.dispatchEvent('firstVisiblePage', page);
    }
    onPageNumberChanged(page) {
        this.dispatchEvent('pageNumber', page);
    }
    onTextSelected() {
        var _a;
        this.dispatchEvent('textSelected', (_a = this.getSelectedText()) !== null && _a !== void 0 ? _a : '');
    }
    maybeGetAnnotations(begin, end) {
        if (this.annotTimer) {
            window.clearTimeout(this.annotTimer);
        }
        this.annotTimer = window.setTimeout(() => {
            this.getAnnotations(begin, end);
        }, 100);
    }
    getAnnotations(begin, end) {
        for (let page = begin; page <= end; page++) {
            if (this.store.getState().annotations.byPage[page] === undefined) {
                this.pdfViewerApi
                    .getItemsFromPage(page, _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemCategory.ANNOTATION)
                    .then((itemsOnPage) => {
                    this.store.annotations.setPageAnnotations(itemsOnPage);
                })
                    .catch((err) => {
                    console.warn(err);
                });
            }
        }
    }
    onLastVisiblePageChanged(page) {
        this.store.document.lastVisiblePageChanged(page);
        this.maybeGetAnnotations(this.store.getState().document.firstVisiblePage, this.store.getState().document.lastVisiblePage);
        this.dispatchEvent('lastVisiblePage', page);
    }
    onZoomChanged(zoom) {
        this.dispatchEvent('zoom', zoom);
    }
    onFitModeChanged(fitMode) {
        this.store.document.fitModeChanged(fitMode);
        this.dispatchEvent('fitMode', fitMode);
    }
    onPageLayoutModeChanged(layoutMode) {
        this.store.document.pageLayoutModeChanged(layoutMode);
        this.dispatchEvent('pageLayoutMode', layoutMode);
    }
    onBusyStateChanged(state) {
        this.store.document.busyStateChanged(state);
        if (state) {
            this.element.classList.remove('pwv-ViewerCanvas--documentIdle');
        }
        else {
            this.element.classList.add('pwv-ViewerCanvas--documentIdle');
        }
        this.dispatchEvent('busyState', state);
    }
    onRotationChanged(rotation) {
        this.store.document.rotationChanged(rotation);
        this.dispatchEvent('rotation', rotation);
    }
    onItemCreated(item) {
        if (item.itemCategory === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemCategory.ANNOTATION) {
            this.store.annotations.addAnnotation(item);
        }
        this.dispatchEvent('itemCreated', item);
    }
    onItemUpdated(item) {
        if (item.itemCategory === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemCategory.ANNOTATION) {
            this.store.annotations.updateAnnotation(item);
        }
        this.dispatchEvent('itemUpdated', item);
    }
    onItemDeleted(deletedItem) {
        if (deletedItem.categoryType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemCategory.ANNOTATION) {
            this.store.annotations.deleteAnnotation(deletedItem.id);
        }
        this.dispatchEvent('itemDeleted', deletedItem);
    }
    onPageChanged(pageNumber) {
        this.pdfViewerApi
            .getItemsFromPage(pageNumber, _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemCategory.ANNOTATION)
            .then((itemsOnPage) => {
            itemsOnPage.items.forEach((annotation) => {
                this.store.annotations.updateAnnotation(annotation);
            });
            this.dispatchEvent('pageChanged', pageNumber);
        });
    }
    onApiError(error) {
        console.error('//// PdfViewerApi Error: ', error);
        this.dispatchEvent('error', error);
    }
    beforeUnloadCallback(e) {
        const changes = this.pdfViewerApi.hasChanges();
        if (changes !== null && changes !== _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.DocumentChange.NONE) {
            e.preventDefault();
            e.returnValue = '';
        }
        else {
            return;
        }
    }
    getNextZoomOutLevel(zoomCurrent) {
        for (var i = this.options.viewer.general.defaultZoomLevels.length - 1; i >= 0; i--) {
            if (zoomCurrent > this.options.viewer.general.defaultZoomLevels[i])
                return this.options.viewer.general.defaultZoomLevels[i];
        }
        return this.options.viewer.general.defaultZoomLevels[0];
    }
    getNextZoomInLevel(zoomCurrent) {
        for (var i = 0; i < this.options.viewer.general.defaultZoomLevels.length; i++) {
            if (zoomCurrent < this.options.viewer.general.defaultZoomLevels[i])
                return this.options.viewer.general.defaultZoomLevels[i];
        }
        return this.options.viewer.general.defaultZoomLevels[this.options.viewer.general.defaultZoomLevels.length - 1];
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/annotations.ts":
/*!****************************************************!*\
  !*** ./src/pdf-viewer-canvas/state/annotations.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "annotationHasPopup": () => (/* binding */ annotationHasPopup),
/* harmony export */   "getOpenPopups": () => (/* binding */ getOpenPopups),
/* harmony export */   "getPopups": () => (/* binding */ getPopups),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");

const state = {
    annotationsChanged: false,
    openPopupChanged: false,
    all: [],
    byPage: [],
    popupsByPage: [],
    openPopupsByPage: [],
};
const annotationHasPopup = (annotation) => {
    if (annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.TEXT) {
        return true;
    }
    if (annotation.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.FREE_TEXT) {
        return false;
    }
    if (!annotation.behaviors) {
        return false;
    }
    return (annotation.behaviors.canHavePopup &&
        (annotation.popup.isOpen === true ||
            (typeof annotation.content === 'string' && annotation.content !== '') ||
            (typeof annotation.subject === 'string' && annotation.subject !== '')));
};
const actions = {
    setPageAnnotations: (annotationsOnPage) => ($state) => {
        const newState = Object.assign({}, $state);
        const pageNumber = annotationsOnPage.page;
        newState.byPage[pageNumber] = [];
        annotationsOnPage.items.forEach((item) => {
            const annotation = item;
            newState.all[annotation.id] = annotation;
            newState.byPage[pageNumber].push(annotation.id);
            if (annotationHasPopup(annotation)) {
                if (!newState.popupsByPage[pageNumber]) {
                    newState.popupsByPage[pageNumber] = [];
                }
                newState.popupsByPage[pageNumber].push(annotation.id);
                if (annotation.popup.isOpen) {
                    if (!newState.openPopupsByPage[pageNumber]) {
                        newState.openPopupsByPage[pageNumber] = [];
                    }
                    if (!newState.openPopupsByPage[pageNumber].find((id) => id === annotation.id)) {
                        newState.openPopupsByPage[pageNumber].push(annotation.id);
                        newState.openPopupChanged = true;
                    }
                }
            }
        });
        newState.annotationsChanged = true;
        return newState;
    },
    deleteAnnotation: (id) => ($state) => {
        const newState = Object.assign({}, $state);
        const annotation = $state.all[id];
        const pageNumber = annotation.pdfRect.page;
        delete newState.all[id];
        newState.byPage[pageNumber] = newState.byPage[pageNumber].filter((i) => i !== id);
        if (newState.popupsByPage[pageNumber]) {
            newState.popupsByPage[pageNumber] = newState.popupsByPage[pageNumber].filter((i) => i !== id);
        }
        if (newState.openPopupsByPage[pageNumber]) {
            newState.openPopupChanged = newState.openPopupsByPage[pageNumber].indexOf(id) > -1;
            newState.openPopupsByPage[pageNumber] = newState.openPopupsByPage[pageNumber].filter((i) => i !== id);
        }
        newState.annotationsChanged = true;
        return newState;
    },
    updateAnnotation: (annotation) => ($state) => {
        const newState = Object.assign({}, $state);
        const { behaviors } = annotation;
        const id = annotation.id;
        const pageNumber = annotation.pdfRect.page;
        if (behaviors.canHavePopup) {
            if (annotationHasPopup(annotation)) {
                if (!newState.popupsByPage[pageNumber]) {
                    newState.popupsByPage[pageNumber] = [];
                }
                const popupIndex = newState.popupsByPage[pageNumber].indexOf(id);
                if (popupIndex < 0) {
                    newState.popupsByPage[pageNumber].push(annotation.id);
                }
            }
            else {
                if (newState.popupsByPage[pageNumber]) {
                    newState.popupsByPage[pageNumber] = newState.popupsByPage[pageNumber].filter((i) => i !== id);
                }
            }
            if (annotation.popup.isOpen) {
                if (!newState.openPopupsByPage[pageNumber]) {
                    newState.openPopupsByPage[pageNumber] = [];
                }
                if (newState.openPopupsByPage[pageNumber].indexOf(id) < 0) {
                    newState.openPopupsByPage[pageNumber].push(id);
                }
                newState.openPopupChanged = true;
            }
            else if (newState.openPopupsByPage[pageNumber]) {
                newState.openPopupsByPage[pageNumber] = newState.openPopupsByPage[pageNumber].filter((i) => i !== id);
                newState.openPopupChanged = true;
            }
        }
        newState.all[annotation.id] = annotation;
        newState.annotationsChanged = true;
        return newState;
    },
    addAnnotation: (annotation) => ($state) => {
        const newState = Object.assign({}, $state);
        const pageNumber = annotation.pdfRect.page;
        const id = annotation.id;
        newState.all[id] = annotation;
        if (!newState.byPage[pageNumber]) {
            newState.byPage[pageNumber] = [];
        }
        newState.byPage[pageNumber].push(id);
        if (annotationHasPopup(annotation)) {
            if (!newState.popupsByPage[pageNumber]) {
                newState.popupsByPage[pageNumber] = [];
            }
            newState.popupsByPage[pageNumber].push(id);
            if (annotation.popup.isOpen) {
                if (!newState.openPopupsByPage[pageNumber]) {
                    newState.openPopupsByPage[pageNumber] = [];
                }
                newState.openPopupsByPage[pageNumber].push(id);
                newState.openPopupChanged = true;
            }
        }
        newState.annotationsChanged = true;
        return newState;
    },
};
const getPopups = ($state, startPage, endPage) => {
    let popups = [];
    for (let page = startPage; page <= endPage; page++) {
        if ($state.popupsByPage[page]) {
            popups = popups
                .concat($state.popupsByPage[page].map((id) => $state.all[id]))
                .filter((annot) => !annot.isHidden());
        }
    }
    return popups;
};
const getOpenPopups = ($state, startPage, endPage) => {
    let openPopups = [];
    for (let page = startPage; page <= endPage; page++) {
        if ($state.openPopupsByPage[page]) {
            openPopups = openPopups.concat($state.openPopupsByPage[page].map((id) => $state.all[id]));
        }
    }
    return openPopups;
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/appState.ts":
/*!*************************************************!*\
  !*** ./src/pdf-viewer-canvas/state/appState.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appState": () => (/* binding */ appState)
/* harmony export */ });
const appState = (state, actions) => {
    const clone = (target, source) => {
        const out = {};
        for (const field of Object.keys(target)) {
            out[field] = target[field];
        }
        if (source) {
            for (const field of Object.keys(source)) {
                out[field] = source[field];
            }
        }
        return out;
    };
    const getPartialState = (path, source) => {
        let i = 0;
        while (i < path.length) {
            source = source[path[i++]];
        }
        return source;
    };
    function setPartialState(path, value, source) {
        const target = {};
        if (path.length) {
            target[path[0]] =
                path.length > 1 ? setPartialState(path.slice(1), value, source[path[0]]) : value;
            return clone(source, target);
        }
        return value;
    }
    const wireStateToActions = (path, wState, wActions) => {
        for (const field of Object.keys(wActions)) {
            if (typeof wActions[field] === 'function') {
                ;
                ((key, action) => {
                    wActions[key] = (data) => {
                        let result = action(data);
                        if (typeof result === 'function') {
                            result = result(getPartialState(path, globalState), wActions);
                        }
                        if (result &&
                            result !== (wState = getPartialState(path, globalState)) &&
                            !result.then) {
                            globalState = setPartialState(path, clone(wState, result), globalState);
                        }
                        return result;
                    };
                })(field, wActions[field]);
            }
            else {
                wireStateToActions(path.concat(field), (wState[field] = clone(wState[field])), (wActions[field] = clone(wActions[field])));
            }
        }
        return wActions;
    };
    let globalState = clone(state);
    const wiredActions = wireStateToActions([], globalState, clone(actions));
    return wiredActions;
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/canvas.ts":
/*!***********************************************!*\
  !*** ./src/pdf-viewer-canvas/state/canvas.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
const state = {
    widthChanged: true,
    heightChanged: true,
    pixelRatioChanged: true,
    canvasInvalidated: true,
    width: { devicePixels: 0, cssPixels: 0 },
    height: { devicePixels: 0, cssPixels: 0 },
    pixelRatio: 1,
};
const actions = {
    resize: (payload) => ($state) => {
        const pixelRatio = window.devicePixelRatio;
        const newState = Object.assign({}, $state);
        if ($state.pixelRatio !== pixelRatio) {
            newState.pixelRatio = pixelRatio;
            newState.pixelRatioChanged = true;
        }
        if ($state.width.cssPixels !== payload.cssWidth) {
            newState.width.cssPixels = payload.cssWidth;
            newState.width.devicePixels = payload.cssWidth * pixelRatio;
            newState.widthChanged = true;
        }
        if ($state.height.cssPixels !== payload.cssHeight) {
            newState.height.cssPixels = payload.cssHeight;
            newState.height.devicePixels = payload.cssHeight * pixelRatio;
            newState.heightChanged = true;
        }
        return newState;
    },
    setPixelRatio: (pixelRatio) => ($state) => {
        const newState = Object.assign({}, $state);
        if ($state.pixelRatio !== pixelRatio) {
            newState.pixelRatio = pixelRatio;
            newState.pixelRatioChanged = true;
        }
        return newState;
    },
    setCanvasInvalidated: (canvasInvalidated) => ($state) => (Object.assign(Object.assign({}, $state), { canvasInvalidated })),
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/document.ts":
/*!*************************************************!*\
  !*** ./src/pdf-viewer-canvas/state/document.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "getRectFromSelection": () => (/* binding */ getRectFromSelection),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");

const state = {
    busyStateChanged: true,
    heightChanged: true,
    widthChanged: true,
    zoomChanged: true,
    rotationChanged: true,
    firstVisiblePageChanged: true,
    lastVisiblePageChanged: true,
    busyState: false,
    firstVisiblePage: 0,
    lastVisiblePage: 0,
    pageRects: [],
    zoom: 1,
    fitMode: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfFitMode.NONE,
    pageLayoutMode: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.SINGLE_PAGE,
    rotation: 0,
    width: { devicePixels: 0, cssPixels: 0 },
    height: { devicePixels: 0, cssPixels: 0 },
};
const actions = {
    fistVisiblePageChanged: (pageNumber) => ($state) => (Object.assign(Object.assign({}, $state), { firstVisiblePage: pageNumber, firstVisiblePageChanged: true })),
    lastVisiblePageChanged: (pageNumber) => ($state) => (Object.assign(Object.assign({}, $state), { lastVisiblePage: pageNumber, lastVisiblePageChanged: true })),
    resize: (payload) => ($state) => {
        const newState = Object.assign({}, $state);
        const pixelRatio = window.devicePixelRatio;
        if (newState.width.devicePixels !== payload.devicePixelsWidth) {
            newState.width.cssPixels = payload.devicePixelsWidth / pixelRatio;
            newState.width.devicePixels = payload.devicePixelsWidth;
            newState.widthChanged = true;
        }
        if (newState.height.devicePixels !== payload.devicePixelsHeight) {
            newState.height.cssPixels = payload.devicePixelsHeight / pixelRatio;
            newState.height.devicePixels = payload.devicePixelsHeight;
            newState.heightChanged = true;
        }
        if (newState.zoom !== payload.zoom) {
            newState.zoom = payload.zoom;
            newState.zoomChanged = true;
        }
        return newState;
    },
    rotationChanged: (rotation) => ($state) => (Object.assign(Object.assign({}, $state), { rotation, rotationChanged: true })),
    updatePageRects: (pageRects) => ($state) => (Object.assign(Object.assign({}, $state), { pageRects })),
    busyStateChanged: (busyState) => ($state) => (Object.assign(Object.assign({}, $state), { busyState, busyStateChanged: true })),
    fitModeChanged: (fitMode) => ($state) => (Object.assign(Object.assign({}, $state), { fitMode })),
    pageLayoutModeChanged: (pageLayoutMode) => ($state) => (Object.assign(Object.assign({}, $state), { pageLayoutMode })),
};
const getSelectionRectFromPage = ($state, startPoint, endPoint, page, padding = 1) => {
    let rect = null;
    const pageRect = $state.pageRects[page];
    const pX1 = pageRect.x + padding;
    const pX2 = pageRect.x + (pageRect.w - 2 * padding);
    const pY1 = pageRect.y + padding;
    const pY2 = pageRect.y + (pageRect.h - 2 * padding);
    if (startPoint.x >= pX1 && startPoint.x <= pX2 && startPoint.y >= pY1 && startPoint.y <= pY2) {
        endPoint.x = endPoint.x < pX1 ? pX1 : endPoint.x > pX2 ? pX2 : endPoint.x;
        endPoint.y = endPoint.y < pY1 ? pY1 : endPoint.y > pY2 ? pY2 : endPoint.y;
        rect = { x: 0, y: 0, w: 0, h: 0 };
        if (startPoint.x < endPoint.x) {
            rect.x = startPoint.x;
            rect.w = endPoint.x - startPoint.x;
        }
        else {
            rect.x = endPoint.x;
            rect.w = startPoint.x - endPoint.x;
        }
        if (startPoint.y < endPoint.y) {
            rect.y = startPoint.y;
            rect.h = endPoint.y - startPoint.y;
        }
        else {
            rect.y = endPoint.y;
            rect.h = startPoint.y - endPoint.y;
        }
        return rect;
    }
    return rect;
};
const getRectFromSelection = ($state, startPoint, endPoint, page, padding = 1) => {
    if (page) {
        return getSelectionRectFromPage($state, startPoint, endPoint, page);
    }
    else {
        for (const pNr in $state.pageRects) {
            if ($state.pageRects) {
                const rect = getSelectionRectFromPage($state, startPoint, endPoint, parseInt(pNr, 10), padding);
                if (rect) {
                    return rect;
                }
            }
        }
    }
    return null;
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/pointer.ts":
/*!************************************************!*\
  !*** ./src/pdf-viewer-canvas/state/pointer.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
const state = {
    positionChanged: true,
    stateChanged: true,
    isDown: false,
    type: 'ontouchstart' in window ? 'touch' : 'mouse',
    action: null,
    x: { devicePixels: 0, cssPixels: 0 },
    y: { devicePixels: 0, cssPixels: 0 },
};
const actions = {
    setAction: (action) => ($state) => (Object.assign(Object.assign({}, $state), { action })),
    update: (payload) => ($state) => {
        const pixelRatio = window.devicePixelRatio;
        const newState = Object.assign({}, $state);
        newState.type = payload.type;
        if ($state.x.cssPixels !== payload.cssY || $state.x.cssPixels !== payload.cssX) {
            newState.x.cssPixels = payload.cssX;
            newState.x.devicePixels = payload.cssX * pixelRatio;
            newState.y.cssPixels = payload.cssY;
            newState.y.devicePixels = payload.cssY * pixelRatio;
            newState.positionChanged = true;
        }
        if ($state.isDown !== payload.isDown) {
            newState.isDown = payload.isDown;
            newState.stateChanged = true;
        }
        return newState;
    },
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/scroll.ts":
/*!***********************************************!*\
  !*** ./src/pdf-viewer-canvas/state/scroll.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
const state = {
    topPositionChanged: false,
    leftPositionChanged: false,
    top: { devicePixels: 0, cssPixels: 0 },
    left: { devicePixels: 0, cssPixels: 0 },
};
const actions = {
    scrollChanged: (payload) => ($state) => {
        const newState = Object.assign({}, $state);
        const pixelRatio = window.devicePixelRatio;
        if ($state.top.devicePixels !== payload.cssTop) {
            newState.top.cssPixels = payload.cssTop / pixelRatio;
            newState.top.devicePixels = payload.cssTop;
            newState.topPositionChanged = true;
        }
        if ($state.left.devicePixels !== payload.cssLeft) {
            newState.left.cssPixels = payload.cssLeft / pixelRatio;
            newState.left.devicePixels = payload.cssLeft;
            newState.leftPositionChanged = true;
        }
        return newState;
    },
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/search.ts":
/*!***********************************************!*\
  !*** ./src/pdf-viewer-canvas/state/search.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
const state = {
    searchString: '',
    caseSensitive: false,
    wrapSearch: false,
    useRegex: false,
    page: 1,
    match: null,
    painted: false,
};
const actions = {
    start: (payload) => ($state) => (Object.assign(Object.assign(Object.assign({}, $state), payload), { match: null, page: 1 })),
    updateMatch: (payload) => ($state) => (Object.assign(Object.assign(Object.assign({}, $state), payload), { painted: false })),
    matchPainted: () => ($state) => {
        return Object.assign(Object.assign({}, $state), { painted: true });
    },
    clear: () => ($state) => ({
        searchString: '',
        caseSensitive: false,
        wrapSearch: false,
        useRegex: false,
        page: 1,
        match: null,
        painted: false,
    }),
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/store.ts":
/*!**********************************************!*\
  !*** ./src/pdf-viewer-canvas/state/store.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "createStore": () => (/* binding */ createStore),
/* harmony export */   "defaultState": () => (/* binding */ defaultState)
/* harmony export */ });
/* harmony import */ var _appState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appState */ "./src/pdf-viewer-canvas/state/appState.ts");
/* harmony import */ var _document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./document */ "./src/pdf-viewer-canvas/state/document.ts");
/* harmony import */ var _annotations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./annotations */ "./src/pdf-viewer-canvas/state/annotations.ts");
/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./canvas */ "./src/pdf-viewer-canvas/state/canvas.ts");
/* harmony import */ var _scroll__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scroll */ "./src/pdf-viewer-canvas/state/scroll.ts");
/* harmony import */ var _pointer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pointer */ "./src/pdf-viewer-canvas/state/pointer.ts");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./search */ "./src/pdf-viewer-canvas/state/search.ts");
/* harmony import */ var _viewer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");








const defaultState = {
    document: _document__WEBPACK_IMPORTED_MODULE_1__.state,
    annotations: _annotations__WEBPACK_IMPORTED_MODULE_2__.state,
    canvas: _canvas__WEBPACK_IMPORTED_MODULE_3__.state,
    scroll: _scroll__WEBPACK_IMPORTED_MODULE_4__.state,
    pointer: _pointer__WEBPACK_IMPORTED_MODULE_5__.state,
    startPointer: _pointer__WEBPACK_IMPORTED_MODULE_5__.state,
    search: _search__WEBPACK_IMPORTED_MODULE_6__.state,
    viewer: _viewer__WEBPACK_IMPORTED_MODULE_7__.state,
};
const deepClone = (state) => {
    return JSON.parse(JSON.stringify(state));
};
const resetSearchResults = (searchState) => {
    searchState.page = 1;
    searchState.match = null;
    return searchState;
};
const actions = {
    document: _document__WEBPACK_IMPORTED_MODULE_1__.actions,
    annotations: _annotations__WEBPACK_IMPORTED_MODULE_2__.actions,
    canvas: _canvas__WEBPACK_IMPORTED_MODULE_3__.actions,
    scroll: _scroll__WEBPACK_IMPORTED_MODULE_4__.actions,
    search: _search__WEBPACK_IMPORTED_MODULE_6__.actions,
    pointer: _pointer__WEBPACK_IMPORTED_MODULE_5__.actions,
    startPointer: _pointer__WEBPACK_IMPORTED_MODULE_5__.actions,
    viewer: _viewer__WEBPACK_IMPORTED_MODULE_7__.actions,
    getState: () => ($state) => $state,
    loadDefaultState: () => ($state) => {
        const newState = deepClone(defaultState);
        newState.viewer.contextBarItems = $state.viewer.contextBarItems;
        newState.search = resetSearchResults($state.search);
        return newState;
    },
    resetChangedState: () => ($state) => (Object.assign(Object.assign({}, $state), { changed: false, viewer: Object.assign(Object.assign({}, $state.viewer), { modeChanged: false, cursorStyleChanged: false, selectedAnnotationChanged: false, textSelectionChanged: false, selectedPopupChanged: false, command: null }), annotations: Object.assign(Object.assign({}, $state.annotations), { annotationsChanged: false, openPopupChanged: false }), document: Object.assign(Object.assign({}, $state.document), { busyStateChanged: false, heightChanged: false, widthChanged: false, firstVisiblePageChanged: false, lastVisiblePageChanged: false, rotationChanged: false, zoomChanged: false }), canvas: Object.assign(Object.assign({}, $state.canvas), { canvasInvalidated: false, heightChanged: false, widthChanged: false }), scroll: Object.assign(Object.assign({}, $state.scroll), { leftPositionChanged: false, topPositionChanged: false }), pointer: Object.assign(Object.assign({}, $state.pointer), { positionChanged: false, stateChanged: false, action: null }) })),
};
const createStore = () => {
    return (0,_appState__WEBPACK_IMPORTED_MODULE_0__.appState)(deepClone(defaultState), actions);
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/state/viewer.ts":
/*!***********************************************!*\
  !*** ./src/pdf-viewer-canvas/state/viewer.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CursorStyle": () => (/* binding */ CursorStyle),
/* harmony export */   "ViewerMode": () => (/* binding */ ViewerMode),
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "copyTextToClipboard": () => (/* binding */ copyTextToClipboard),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var ViewerMode;
(function (ViewerMode) {
    ViewerMode[ViewerMode["DEFAULT"] = 0] = "DEFAULT";
    ViewerMode[ViewerMode["ANNOTATION_SELECTED"] = 1] = "ANNOTATION_SELECTED";
    ViewerMode[ViewerMode["TEXT_SELECTED"] = 2] = "TEXT_SELECTED";
    ViewerMode[ViewerMode["POPUP_SELECTED"] = 3] = "POPUP_SELECTED";
    ViewerMode[ViewerMode["MODULE_SELECTED"] = 4] = "MODULE_SELECTED";
})(ViewerMode || (ViewerMode = {}));
var CursorStyle;
(function (CursorStyle) {
    CursorStyle["DEFAULT"] = "default";
    CursorStyle["TEXT"] = "text";
    CursorStyle["NONE"] = "none";
    CursorStyle["POINTER"] = "pointer";
    CursorStyle["CROSSHAIR"] = "crosshair";
    CursorStyle["NOT_ALLOWED"] = "not-allowed";
    CursorStyle["WAIT"] = "wait";
    CursorStyle["MOVE"] = "move";
    CursorStyle["GRAB"] = "grab";
    CursorStyle["GRABBING"] = "grabbing";
    CursorStyle["COL_RESIZE"] = "col-resize";
    CursorStyle["ROW_RESIZE"] = "row-resize";
    CursorStyle["NS_RESIZE"] = "ns-resize";
    CursorStyle["EW_RESIZE"] = "ew-resize";
    CursorStyle["NESW_RESIZE"] = "nesw-resize";
    CursorStyle["NWSE_RESIZE"] = "nwse-resize";
    CursorStyle["ERASE"] = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAADwQAAA8EB0Z6ZfgAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAM+SURBVEiJtZRbSBRRGMe/WTd3dmfmzOyZdcaVQlCsl3yK8lIqRAgFIbrubGa6D1IURQ8RhWgPQZC0RRQ99agPQXSDNCPEy67FCqZb6boma7Vq1w0zytvO7PTS0qZ7M+wPw8D3/+b/O+fMzEcEg0HV5/NBtPx+/2273W6D9ZDL5VIBIAwAi1HXkXUJBwDt7/sbAMhdr9BoaVJtbK6sPLwrP9/4XwBX7XbH6YqKG+erqjxHy8uFtQC0c3NzPQBwK17DzWPHzlsKCk5u0Gq1hXl5GwmCGJyX5aLW7u6ZVABEItNRV9dkLys7R5Hkhuj64OTkh3tOZ/G1rq5AMkBaPON6Q8OJ2pKSCzRJpq/0soxGRsC4xsRx9/vHxmbXDGiprT1uKy6+zOr1q8IjElmWZvX6GoamHw6Mj39NGXClvv7QwdLS60aK0iVaGQBAJsdRPEXZkF7f4Z6YCCYFNErSPntJSSumaTJZeBTEICJky+D5jn6v98tK/6/PVKeqwW/z80qq4RHlmM28YtrcZ7UeyV/p/bWDXq93RkSoLwOhap5hkh4RAMCyLMPVVx8VcaeN4hB7QKBRz+jY0PuYgN+QKTPLuniEqk1JIEuhEDhezISFAksaEAToWIE0Yl7KNtIuz8jQVExABCJynDMDIYuJYWK+j5CiQMvzd4pQZE0jNH9OOp0x6QwsL2VnsG7Py8G3cf8Dp9c7bca4Q0RIwgxjiPZkRYFLQ+8UoUhK02hWTxsdY0o3MNiSbebdcQEAAL2jo59Zmn6CaVoSWVYfCXcMTyl8YXXM8GgICcT+hAAAgKc+3ycBoUeYpiWeYQyXhwNhXJA4HABAXvyhwrSnPSkAAMDl832mSbL92XeN1bSzhtZoEj8mLy2oCyOPO5odjdUpAQAA3BMTQQpvahcwL5HGTCpenyovq6Hx7r6mljN7ARIMu1jy+0eCyIAeYA7ZSFZcBVEVWZ0dfDBw7tLZskgt4biOp117LDm7d1ucOHebOVILhxX4+aJzuPniqe0EQaiR+pp2EFFgcmxWWVq+I/LYasBZSFVV+OnpfLll0r1jqySFo3v/CQAAEAi8ngsvh+6KHFMZmvJMi7Pj2+1tbfLKvl/ycBilf3EZ0gAAAABJRU5ErkJggg=='), auto";
})(CursorStyle || (CursorStyle = {}));
const state = {
    modeChanged: true,
    mode: ViewerMode.DEFAULT,
    selectedAnnotationId: null,
    selectedAnnotationBehaviors: null,
    selectedAnnotationChanged: true,
    textSelectionChanged: true,
    textSelection: null,
    textSelectionType: null,
    textSelectionState: null,
    textSelectionRects: null,
    selectedPopupId: null,
    selectedPopupChanged: true,
    popupFocus: null,
    selectedModuleName: null,
    cursorStyle: CursorStyle.DEFAULT,
    cursorStyleChanged: true,
    contextBarItems: [],
};
const actions = {
    setDefaultMode: () => ($state) => ({
        modeChanged: true,
        mode: ViewerMode.DEFAULT,
        selectedAnnotationId: null,
        selectedAnnotationBehaviors: null,
        selectedAnnotationChanged: true,
        textSelectionChanged: true,
        textSelection: null,
        selectedPopupId: null,
        selectedPopupChanged: true,
        selectedModuleName: null,
        cursorStyle: CursorStyle.DEFAULT,
        cursorStyleChanged: true,
    }),
    addContextBarItem: (contextBarItem) => ($state) => {
        const contextBarItems = $state.contextBarItems;
        contextBarItem.itemTypes.forEach((itemType) => {
            if (!contextBarItems[itemType]) {
                contextBarItems[itemType] = [];
            }
            contextBarItems[itemType].push(contextBarItem);
        });
        return Object.assign(Object.assign({}, $state), { contextBarItems });
    },
    clearContextBarItems: () => ($state) => (Object.assign(Object.assign({}, $state), { contextBarItems: [] })),
    setCursorStyle: (cursorStyle) => ($state) => (Object.assign(Object.assign({}, $state), { cursorStyle, cursorStyleChanged: $state.cursorStyle !== cursorStyle })),
    selectAnnotation: (annotation) => ($state) => (Object.assign(Object.assign({}, $state), { selectedAnnotationId: annotation.id, selectedAnnotationBehaviors: annotation.behaviors, selectedAnnotationChanged: true, selectedModuleName: null, selectedPopupId: null, modeChanged: true, mode: ViewerMode.ANNOTATION_SELECTED })),
    deselectAnnotation: () => ($state) => {
        const modeChanged = $state.mode === ViewerMode.ANNOTATION_SELECTED;
        return Object.assign(Object.assign({}, $state), { selectedAnnotationId: null, selectedAnnotationBehaviors: null, selectedModuleName: null, selectedAnnotationChanged: true, modeChanged, mode: modeChanged ? ViewerMode.DEFAULT : $state.mode });
    },
    beginModule: (moduleName) => ($state) => {
        return Object.assign(Object.assign({}, $state), { modeChanged: true, mode: ViewerMode.MODULE_SELECTED, selectedAnnotationId: null, selectedAnnotationBehaviors: null, selectedAnnotationChanged: true, textSelectionChanged: true, textSelection: null, selectedModuleName: moduleName, selectedPopupId: null, selectedPopupChanged: true });
    },
    endModule: (moduleName) => ($state) => {
        const selectedModuleName = $state.selectedModuleName === moduleName ? null : $state.selectedModuleName;
        const mode = selectedModuleName !== null ? ViewerMode.MODULE_SELECTED : ViewerMode.DEFAULT;
        return Object.assign(Object.assign({}, $state), { modeChanged: true, selectedModuleName,
            mode });
    },
    setTextSelectionState: (textSelectionState) => ($state) => {
        return Object.assign(Object.assign({}, $state), { textSelectionState });
    },
    setTextSelection: (args) => ($state) => {
        const { selection, type } = args;
        const mode = selection ? ViewerMode.TEXT_SELECTED : ViewerMode.DEFAULT;
        const modeChanged = $state.mode !== mode;
        const textSelectionRects = selection ? {} : null;
        if (selection && textSelectionRects) {
            const pageRects = {};
            selection.quadrilaterals.forEach((q) => {
                const { bottomLeft, bottomRight, topRight, topLeft, pageNumber } = q;
                if (!pageRects[pageNumber]) {
                    pageRects[pageNumber] = {
                        x1: Number.MAX_SAFE_INTEGER,
                        y1: Number.MAX_SAFE_INTEGER,
                        x2: Number.MIN_SAFE_INTEGER,
                        y2: Number.MIN_SAFE_INTEGER,
                    };
                }
                pageRects[pageNumber] = {
                    x1: Math.min(pageRects[pageNumber].x1, bottomLeft.x, bottomRight.x, topRight.x, topLeft.x),
                    y1: Math.min(pageRects[pageNumber].y1, bottomLeft.y, bottomRight.y, topRight.y, topLeft.y),
                    x2: Math.max(pageRects[pageNumber].x2, bottomLeft.x, bottomRight.x, topRight.x, topLeft.x),
                    y2: Math.max(pageRects[pageNumber].y2, bottomLeft.y, bottomRight.y, topRight.y, topLeft.y),
                };
            });
            Object.keys(pageRects).forEach((pageNumber) => {
                textSelectionRects[pageNumber] = {
                    pdfX: pageRects[pageNumber].x1,
                    pdfY: pageRects[pageNumber].y1,
                    pdfW: pageRects[pageNumber].x2 - pageRects[pageNumber].x1,
                    pdfH: pageRects[pageNumber].y2 - pageRects[pageNumber].y1,
                    page: parseInt(pageNumber),
                };
            });
        }
        return Object.assign(Object.assign({}, $state), { mode,
            modeChanged, textSelectionChanged: true, textSelection: selection, textSelectionType: type, textSelectionRects });
    },
    selectPopup: (args) => ($state) => {
        const mode = args.id !== null ? ViewerMode.POPUP_SELECTED : ViewerMode.DEFAULT;
        const modeChanged = $state.mode !== mode;
        return Object.assign(Object.assign({}, $state), { mode,
            modeChanged, selectedPopupChanged: args.id !== $state.selectedPopupId, selectedPopupId: args.id, popupFocus: args.focus ? args.id : null });
    },
    clearPopupFocus: () => ($state) => {
        return Object.assign(Object.assign({}, $state), { popupFocus: null });
    },
    deselectPopup: () => ($state) => {
        const mode = ViewerMode.DEFAULT;
        const modeChanged = mode !== $state.mode;
        return Object.assign(Object.assign({}, $state), { mode,
            modeChanged });
    },
};
const copyTextToClipboard = (text) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield navigator.clipboard.writeText(text);
    }
    catch (err) {
        var textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.top = '0';
        textArea.style.left = '0';
        textArea.style.position = 'fixed';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
    }
});


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/AnnotationSelectionLayer.ts":
/*!***********************************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/AnnotationSelectionLayer.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationSelectionLayer": () => (/* binding */ AnnotationSelectionLayer)
/* harmony export */ });
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _ViewLayerBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ViewLayerBase */ "./src/pdf-viewer-canvas/view-layers/ViewLayerBase.ts");
/* harmony import */ var _state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _views_AnnotationContextBar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./views/AnnotationContextBar */ "./src/pdf-viewer-canvas/view-layers/views/AnnotationContextBar.tsx");
/* harmony import */ var _views_AnnotationBorder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./views/AnnotationBorder */ "./src/pdf-viewer-canvas/view-layers/views/AnnotationBorder.ts");
/* harmony import */ var _custom_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../custom/history */ "./src/custom/history.ts");






class AnnotationSelectionLayer extends _ViewLayerBase__WEBPACK_IMPORTED_MODULE_1__.ViewLayerBase {
    constructor() {
        super();
        this.context = null;
        this.selectedAnnotation = null;
        this.selectionElement = null;
        this.barAtTop = true;
        this.contextBar = null;
        this.annotationBorder = null;
        this.deleteAnnotation = this.deleteAnnotation.bind(this);
        this.rotateAnnotation = this.rotateAnnotation.bind(this);
        this.copyAnnotationText = this.copyAnnotationText.bind(this);
        this.createPopup = this.createPopup.bind(this);
        this.openPopup = this.openPopup.bind(this);
        this.deletePopup = this.deletePopup.bind(this);
        this.moveAnnotation = this.moveAnnotation.bind(this);
        this.toggleLock = this.toggleLock.bind(this);
        this.resizeAnnotation = this.resizeAnnotation.bind(this);
        this.onItemSelected = this.onItemSelected.bind(this);
        this.onItemDblClick = this.onItemDblClick.bind(this);
    }
    create() {
        var _a, _b;
        if (this.viewerCanvas) {
            this.viewerCanvas.addEventListener('itemSelected', this.onItemSelected);
        }
        this.selectAnnotation = this.selectAnnotation.bind(this);
        this.deselectAnnotation = this.deselectAnnotation.bind(this);
        this.deleteAnnotation = this.deleteAnnotation.bind(this);
        this.createPopup = this.createPopup.bind(this);
        this.deletePopup = this.deletePopup.bind(this);
        this.openPopup = this.openPopup.bind(this);
        this.context = this.createCanvas('pwv-annotation-selection-layers');
        this.context.canvas.style.display = 'none';
        this.selectionElement = this.createHtmlLayer();
        this.selectionElement.style.display = 'none';
        this.selectionElement.style.position = 'absolute';
        this.selectionElement.classList.add('pwv-annotation-selection');
        this.selectionElement.classList.add('pwv-contextbar-top');
        this.selectionElement.addEventListener('click', (e) => {
            e.preventDefault();
            e.cancelBubble = true;
        }, false);
        if ((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) {
            this.contextBar = (0,_views_AnnotationContextBar__WEBPACK_IMPORTED_MODULE_3__.createAnnotationContextBar)({
                allowCopyText: this.options.viewer.permissions.allowCopyText,
                allowLockAnnotations: this.options.viewer.permissions.allowLockAnnotations,
                allowEditLockedAnnotations: this.options.viewer.permissions.allowEditLockedAnnotations,
                onDeleteAnnotation: this.deleteAnnotation,
                onRotateAnnotation: this.rotateAnnotation,
                onCopy: this.copyAnnotationText,
                onCreatePopup: this.createPopup,
                onOpenPopup: this.openPopup,
                onDeletePopup: this.deletePopup,
                onToggleLock: this.toggleLock,
            }, this.selectionElement);
        }
        this.annotationBorder = new _views_AnnotationBorder__WEBPACK_IMPORTED_MODULE_4__.AnnotationBorder(this.selectionElement, this.moveAnnotation, this.resizeAnnotation, this.onItemDblClick, this.options, this.store, !((_b = this.viewerCanvas) === null || _b === void 0 ? void 0 : _b.licenseFeatures.annotate) || false);
    }
    render(timestamp, state) {
        const mode = state.viewer.mode;
        if (this.selectedAnnotation && mode !== _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.ANNOTATION_SELECTED) {
            this.deselectAnnotation();
        }
        const { pageLayoutMode } = state.document;
        if ((pageLayoutMode === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.SINGLE_PAGE ||
            pageLayoutMode === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_PAGE_LEFT ||
            pageLayoutMode === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.TWO_PAGE_RIGHT) &&
            this.selectedAnnotation &&
            state.document.firstVisiblePageChanged) {
            this.deselectAnnotation();
            this.store.canvas.setCanvasInvalidated(true);
            return false;
        }
        if ((state.pointer.action === 'click' || state.pointer.action === 'dblclick') &&
            (mode === _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.DEFAULT ||
                mode === _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.ANNOTATION_SELECTED ||
                mode === _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.POPUP_SELECTED)) {
            const annotationsOnPoint = this.pdfViewerApi.getAnnotationsOnPoint({
                x: state.pointer.x.devicePixels,
                y: state.pointer.y.devicePixels,
            });
            let breakRenderLoop = false;
            if (annotationsOnPoint && annotationsOnPoint.length) {
                for (let i = annotationsOnPoint.length - 1; i >= 0; i--) {
                    const annotationOnPoint = annotationsOnPoint[i];
                    if (annotationOnPoint.behaviors.selectable) {
                        if (state.pointer.action === 'click') {
                            if (annotationOnPoint.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.WIDGET) {
                                if (this.viewerCanvas && !annotationOnPoint.widget.readOnly) {
                                    this.viewerCanvas.activateModule('FormFieldModule', {
                                        annotationId: annotationOnPoint.id,
                                        action: 'click',
                                    });
                                    breakRenderLoop = true;
                                    break;
                                }
                            }
                            else if (annotationOnPoint.id !== state.viewer.selectedAnnotationId) {
                                if (state.viewer.selectedAnnotationId) {
                                    this.deselectAnnotation();
                                }
                                if (!annotationOnPoint.isHidden()) {
                                    this.selectAnnotation(annotationOnPoint);
                                    breakRenderLoop = true;
                                    break;
                                }
                            }
                        }
                        else if (state.pointer.action === 'dblclick') {
                            this.onItemDblClick(annotationOnPoint.id);
                            break;
                        }
                    }
                }
            }
            else if (state.viewer.selectedAnnotationId) {
                this.deselectAnnotation();
                breakRenderLoop = true;
            }
            if (breakRenderLoop) {
                this.store.canvas.setCanvasInvalidated(true);
                return false;
            }
        }
        if (mode === _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.ANNOTATION_SELECTED && state.viewer.selectedAnnotationId) {
            const annotation = state.annotations.all[state.viewer.selectedAnnotationId];
            if (this.selectedAnnotation === null) {
                this.selectAnnotation(annotation);
            }
            if (this.annotationBorder && state.canvas.canvasInvalidated) {
                const pageRect = state.document.pageRects[annotation.pdfRect.page];
                if (pageRect) {
                    this.annotationBorder.updatePageRect(pageRect);
                }
            }
            if (state.viewer.selectedAnnotationChanged || state.canvas.canvasInvalidated) {
                this.updateSelectionElementPosition(annotation);
            }
        }
    }
    updateSelectionElementPosition(annotation) {
        if (this.selectionElement) {
            const rect = this.pdfViewerApi.transformPdfPageRectToScreenRect(annotation.pdfRect);
            const annotationY = rect.y / devicePixelRatio;
            const annotationX = rect.x / devicePixelRatio;
            const annotationW = rect.w / devicePixelRatio;
            const annotationH = rect.h / devicePixelRatio;
            const newBarAtTop = annotationY > 80;
            this.selectionElement.style.top = annotationY + 'px';
            this.selectionElement.style.left = annotationX + 'px';
            this.selectionElement.style.width = annotationW + 'px';
            this.selectionElement.style.height = annotationH + 'px';
            if (this.barAtTop !== newBarAtTop) {
                this.barAtTop = newBarAtTop;
                if (this.barAtTop) {
                    this.selectionElement.classList.remove('pwv-contextbar-bottom');
                    this.selectionElement.classList.add('pwv-contextbar-top');
                }
                else {
                    this.selectionElement.classList.remove('pwv-contextbar-top');
                    this.selectionElement.classList.add('pwv-contextbar-bottom');
                }
            }
            const contextbarElement = this.selectionElement.lastChild;
            if (contextbarElement && contextbarElement.nodeType === 1) {
                const state = this.store.getState();
                const canvasWidth = state.canvas.width.cssPixels;
                const barWidth = contextbarElement.offsetWidth;
                const barCenter = barWidth / 2;
                const padding = 4;
                let left = 0;
                if (barWidth > annotationW) {
                    left = (barWidth - annotationW) / -2;
                }
                else {
                    left = (annotationW - barWidth) / 2;
                }
                if (annotationX + left + padding < 0) {
                    left = annotationX * -1 + padding;
                    if (annotationX + annotationW < barCenter) {
                        left = annotationW - barCenter;
                    }
                }
                if (annotationX + left + barWidth + padding > canvasWidth) {
                    left = canvasWidth - annotationX - barWidth - padding;
                    if (left * -1 > barCenter) {
                        left = barCenter * -1;
                    }
                }
                contextbarElement.style.left = left + 'px';
            }
        }
    }
    selectAnnotation(annotation, preventEvent) {
        var _a, _b;
        if (this.selectionElement && this.context && this.annotationBorder) {
            this.selectedAnnotation = annotation;
            const pageRect = this.store.getState().document.pageRects[annotation.pdfRect.page];
            this.annotationBorder.deselectAnnotation();
            this.annotationBorder.setAnnotation(annotation, pageRect);
            const state = this.store.getState();
            if (((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) && this.contextBar) {
                const commands = (_b = state.viewer.contextBarItems[annotation.itemType]) !== null && _b !== void 0 ? _b : [];
                this.contextBar.setAnnotation({ annotation, commands });
            }
            this.context.canvas.style.display = 'none';
            this.selectionElement.style.display = 'block';
            this.barAtTop = true;
            this.selectionElement.classList.remove('pwv-contextbar-bottom');
            this.selectionElement.classList.add('pwv-contextbar-top');
            this.updateSelectionElementPosition(annotation);
            this.store.viewer.selectAnnotation(annotation);
            this.store.viewer.setCursorStyle(_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.DEFAULT);
            if (this.viewerCanvas && !preventEvent) {
                this.dispatchEvent('itemSelected', annotation);
            }
        }
    }
    deselectAnnotation() {
        if (this.context && this.selectionElement && this.annotationBorder) {
            const annot = this.selectedAnnotation;
            this.selectedAnnotation = null;
            this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
            this.annotationBorder.deselectAnnotation();
            this.context.canvas.style.display = 'none';
            this.selectionElement.style.display = 'none';
            this.store.viewer.deselectAnnotation();
            if (this.viewerCanvas && annot !== null) {
                this.dispatchEvent('itemDeselected', annot);
            }
        }
    }
    rotateAnnotation(id) {
        if (this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            item.rotation = (item.rotation + 90) % 360;
            this.pdfViewerApi.updateItem(item).then((item) => {
                if (this.annotationBorder) {
                    const annotation = item;
                    const pageRect = this.store.getState().document.pageRects[annotation.pdfRect.page];
                    this.annotationBorder.setAnnotation(annotation, pageRect);
                }
            });
        }
    }
    moveAnnotation(id, point) {
        var _a;
        if (this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            const newItemPos = this.pdfViewerApi.transformScreenPointToPdfPoint({
                x: point.x * window.devicePixelRatio,
                y: point.y * window.devicePixelRatio,
            }, item.page, true);
            if (newItemPos.pdfPoint.page === item.pdfRect.page) {
                switch (this.pdfViewerApi.getRotation()) {
                    case 0:
                        item.pdfRect.pdfX = newItemPos.pdfPoint.pdfX;
                        item.pdfRect.pdfY = newItemPos.pdfPoint.pdfY;
                        break;
                    case 90:
                        item.pdfRect.pdfX = newItemPos.pdfPoint.pdfX - item.pdfRect.pdfW;
                        item.pdfRect.pdfY = newItemPos.pdfPoint.pdfY;
                        break;
                    case 180:
                        item.pdfRect.pdfX = newItemPos.pdfPoint.pdfX - item.pdfRect.pdfW;
                        item.pdfRect.pdfY = newItemPos.pdfPoint.pdfY - item.pdfRect.pdfH;
                        break;
                    case 270:
                        item.pdfRect.pdfX = newItemPos.pdfPoint.pdfX;
                        item.pdfRect.pdfY = newItemPos.pdfPoint.pdfY - item.pdfRect.pdfH;
                        break;
                }
            }
            this.store.annotations.updateAnnotation(item);
            this.store.canvas.setCanvasInvalidated(true);
            if ((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) {
                this.pdfViewerApi.updateItem(item);
            }
        }
    }
    resizeAnnotation(id, rect) {
        var _a;
        if (this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            const newItemRect = this.pdfViewerApi.transformScreenRectToPdfRect({
                x: rect.x * window.devicePixelRatio,
                y: rect.y * window.devicePixelRatio,
                w: rect.w * window.devicePixelRatio,
                h: rect.h * window.devicePixelRatio,
            }, item.pdfRect.page);
            if (newItemRect.page === item.pdfRect.page) {
                item.pdfRect = newItemRect;
            }
            this.store.annotations.updateAnnotation(item);
            this.store.canvas.setCanvasInvalidated(true);
            if ((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) {
                this.pdfViewerApi.updateItem(item);
            }
        }
    }
    copyAnnotationText(id) {
        if (this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            if (item.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.HIGHLIGHT ||
                item.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.UNDERLINE ||
                item.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SQUIGGLY ||
                item.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.STRIKE_OUT) {
                const quadPointAnnotation = item;
                const firstRect = quadPointAnnotation.quadrilaterals[0];
                const lastRect = quadPointAnnotation.quadrilaterals[quadPointAnnotation.quadrilaterals.length - 1];
                const startPoint = {
                    pdfX: firstRect.topLeft.x,
                    pdfY: firstRect.topLeft.y,
                    page: firstRect.pageNumber,
                };
                const endPoint = {
                    pdfX: lastRect.bottomRight.x,
                    pdfY: lastRect.bottomRight.y,
                    page: lastRect.pageNumber,
                };
                const text = this.pdfViewerApi.getText(startPoint, endPoint);
                (0,_state_viewer__WEBPACK_IMPORTED_MODULE_2__.copyTextToClipboard)(text || '');
            }
        }
    }
    toggleLock(id) {
        var _a;
        if (((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) && this.pdfViewerApi) {
            const annot = this.pdfViewerApi.getItem(id);
            if (this.options.annotation.trackHistory) {
                (0,_custom_history__WEBPACK_IMPORTED_MODULE_5__.addHistoryEntry)(annot, annot.isLocked() ? 'unlock' : 'lock', this.options.viewer.general.user);
            }
            annot.setLock(!annot.isLocked());
            if (this.annotationBorder) {
                this.annotationBorder.deselectAnnotation();
                const pageRect = this.store.getState().document.pageRects[annot.pdfRect.page];
                this.annotationBorder.setAnnotation(annot, pageRect);
            }
            this.store.annotations.updateAnnotation(annot);
            this.pdfViewerApi.updateItem(annot);
        }
    }
    deleteAnnotation(id) {
        var _a;
        if (((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) && this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            if (this.options.annotation.hideOnDelete) {
                item.setHidden(true);
                item.popup.isOpen = false;
                if (this.options.annotation.trackHistory) {
                    (0,_custom_history__WEBPACK_IMPORTED_MODULE_5__.addHistoryEntry)(item, 'delete', this.options.viewer.general.user);
                }
                this.store.annotations.updateAnnotation(item);
                this.pdfViewerApi.updateItem(item);
                this.deselectAnnotation();
            }
            else {
                this.pdfViewerApi
                    .deleteItem(item)
                    .then(() => {
                    this.deselectAnnotation();
                })
                    .catch((error) => {
                    console.error(error);
                });
            }
        }
    }
    deletePopup(id) {
        var _a;
        if (((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) && this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            item.content = null;
            item.popup.isOpen = false;
            this.store.annotations.updateAnnotation(item);
            this.store.canvas.setCanvasInvalidated(true);
            this.pdfViewerApi.updateItem(item);
        }
    }
    createPopup(id) {
        var _a;
        if (((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) && this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            item.content = '';
            item.popup.isOpen = true;
            item.popup.pdfRect.pdfX = item.pdfRect.pdfX;
            item.popup.pdfRect.pdfY = item.pdfRect.pdfY - (item.popup.pdfRect.pdfH + 10);
            this.store.annotations.updateAnnotation(item);
            this.store.canvas.setCanvasInvalidated(true);
            this.pdfViewerApi.updateItem(item).then(() => {
                this.store.viewer.selectPopup({ id: item.id, focus: true });
            });
            this.deselectAnnotation();
        }
    }
    openPopup(id) {
        var _a, _b;
        if (this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            if (!((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate) && (!item.content || !item.content)) {
                return;
            }
            if (!item.popup) {
                return;
            }
            item.popup.isOpen = true;
            this.store.annotations.updateAnnotation(item);
            this.store.canvas.setCanvasInvalidated(true);
            if ((_b = this.viewerCanvas) === null || _b === void 0 ? void 0 : _b.licenseFeatures.annotate) {
                this.pdfViewerApi.updateItem(item).then(() => {
                    this.store.viewer.selectPopup({ id: item.id, focus: true });
                });
            }
            else {
                this.deselectAnnotation();
                this.store.viewer.selectPopup({ id: item.id, focus: true });
            }
        }
    }
    onItemDblClick(id) {
        if (this.pdfViewerApi) {
            const item = this.pdfViewerApi.getItem(id);
            const { behaviors } = item;
            if (item.isHidden()) {
                return;
            }
            if (item.itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.FREE_TEXT && !item.isReadOnly() && !item.isLocked()) {
                if (this.viewerCanvas) {
                    this.viewerCanvas.activateModule('FreetextAnnotationModule', item.id);
                }
            }
            else if (behaviors.canHavePopup && !item.isHidden()) {
                this.openPopup(id);
            }
        }
    }
    onItemSelected(item) {
        if (item.itemCategory === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemCategory.ANNOTATION) {
            this.selectAnnotation(item, true);
        }
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/BusyStateLayer.ts":
/*!*************************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/BusyStateLayer.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BusyStateLayer": () => (/* binding */ BusyStateLayer)
/* harmony export */ });
/* harmony import */ var _ViewLayerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewLayerBase */ "./src/pdf-viewer-canvas/view-layers/ViewLayerBase.ts");

class BusyStateLayer extends _ViewLayerBase__WEBPACK_IMPORTED_MODULE_0__.ViewLayerBase {
    constructor() {
        super();
    }
    create() {
        this.busyStateView = this.createHtmlLayer();
        this.busyStateView.classList.add('pwv-BusyLoader');
        this.busyStateView.style.display = 'none';
        const ct = document.createElement('div');
        this.busyStateView.appendChild(ct);
        const rects = ['rect-1', 'rect-2', 'rect-3', 'rect-4', 'rect-5'];
        rects.forEach((rect) => {
            const rectElement = document.createElement('div');
            rectElement.classList.add(rect);
            ct.appendChild(rectElement);
        });
    }
    render(timestamp, state) {
        if (this.busyStateView && state.document.busyStateChanged) {
            this.busyStateView.style.display = state.document.busyState ? 'block' : 'none';
        }
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/PdfDocumentLayer.ts":
/*!***************************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/PdfDocumentLayer.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PdfDocumentLayer": () => (/* binding */ PdfDocumentLayer)
/* harmony export */ });
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _ViewLayerBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ViewLayerBase */ "./src/pdf-viewer-canvas/view-layers/ViewLayerBase.ts");
/* harmony import */ var _state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _canvasShapes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./canvasShapes */ "./src/pdf-viewer-canvas/view-layers/canvasShapes.ts");




class PdfDocumentLayer extends _ViewLayerBase__WEBPACK_IMPORTED_MODULE_1__.ViewLayerBase {
    constructor() {
        super();
    }
    create() {
        this.context = this.createCanvas();
        this.canvas = this.context.canvas;
    }
    render(timestamp, state) {
        if (this.pdfViewerApi) {
            const draw = state.canvas.canvasInvalidated ||
                state.canvas.widthChanged ||
                state.canvas.heightChanged ||
                state.viewer.modeChanged ||
                state.viewer.textSelectionChanged ||
                state.pointer.stateChanged ||
                !state.search.painted;
            const defaultState = state.viewer.mode === _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.DEFAULT;
            if (defaultState && (state.pointer.positionChanged || state.pointer.stateChanged)) {
                const pointerPos = {
                    x: state.pointer.x.devicePixels,
                    y: state.pointer.y.devicePixels,
                };
                const pointerPdfPos = this.pdfViewerApi.transformScreenPointToPdfPoint(pointerPos);
                this.store.viewer.setCursorStyle(_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.DEFAULT);
                if (pointerPdfPos.isOnPage) {
                    const annotationsOnPoint = this.pdfViewerApi.getAnnotationsOnPoint(pointerPos);
                    const annotationOnPoint = annotationsOnPoint
                        ? annotationsOnPoint[annotationsOnPoint.length - 1]
                        : null;
                    if (annotationOnPoint) {
                        const itemType = annotationOnPoint.itemType;
                        if ((itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.HIGHLIGHT ||
                            itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.SQUIGGLY ||
                            itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.STRIKE_OUT) &&
                            this.pdfViewerApi.getTextFragmentOnPoint(pointerPos) !== null) {
                            this.store.viewer.setCursorStyle(_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.TEXT);
                        }
                        else if (itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.LINK) {
                            const link = annotationOnPoint;
                            this.store.viewer.setCursorStyle(_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.POINTER);
                            if (state.pointer.action === 'click') {
                                if (link.destination && link.actionType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfActionType.GO_TO) {
                                    this.pdfViewerApi.goTo(link.destination);
                                }
                                else if (link.uri && link.actionType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfActionType.URI) {
                                    window.open(link.uri);
                                }
                            }
                        }
                    }
                    else {
                        const textFragmentOnPoint = this.pdfViewerApi.getTextFragmentOnPoint(pointerPos);
                        if (textFragmentOnPoint) {
                            this.store.viewer.setCursorStyle(_state_viewer__WEBPACK_IMPORTED_MODULE_2__.CursorStyle.TEXT);
                        }
                    }
                }
            }
            if (draw) {
                const ctx = this.context;
                ctx.save();
                const { pageShadow, currentPageShadow } = this.options.viewer.general;
                if (state.viewer.mode === _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.MODULE_SELECTED) {
                    ctx.globalAlpha = 0.75;
                    this.pdfViewerApi.renderCanvas(ctx, { pageShadow, currentPageShadow });
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = 'rgb(255,255,255)';
                    ctx.globalCompositeOperation = 'destination-over';
                    for (const k in state.document.pageRects) {
                        if (state.document.pageRects[k]) {
                            const pageRect = state.document.pageRects[k];
                            ctx.fillRect(pageRect.x, pageRect.y, pageRect.w, pageRect.h);
                        }
                    }
                }
                else {
                    this.pdfViewerApi.renderCanvas(ctx, { pageShadow, currentPageShadow });
                }
                ctx.restore();
                if (state.search.match) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = this.options.viewer.general.searchMatchColor;
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    state.search.match.forEach((match) => {
                        if (match.pageNumber >= state.document.firstVisiblePage &&
                            match.pageNumber <= state.document.lastVisiblePage) {
                            const path = this.pdfViewerApi.transformQuadrilateralToViewport(match);
                            for (let k = 0; k < path.length; k++) {
                                const point = path[k];
                                if (k === 0) {
                                    ctx.moveTo(point.x, point.y);
                                }
                                else {
                                    ctx.lineTo(point.x, point.y);
                                }
                            }
                        }
                    });
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
                this.store.search.matchPainted();
                if (state.viewer.textSelection) {
                    ctx.save();
                    const selection = state.viewer.textSelection;
                    const screenSelection = [];
                    for (let i = 0; i < selection.quadrilaterals.length; i++) {
                        const path = this.pdfViewerApi.transformQuadrilateralToViewport(selection.quadrilaterals[i]);
                        screenSelection.push(path);
                    }
                    (0,_canvasShapes__WEBPACK_IMPORTED_MODULE_3__.renderTextSelection)(ctx, devicePixelRatio * state.document.zoom, this.options.viewer.general.textSelectionColor, screenSelection);
                    ctx.restore();
                    if (state.pointer.isDown &&
                        state.viewer.textSelectionState === 'selecting' &&
                        state.viewer.textSelectionType === 'rectangular') {
                        const { textSelection } = state.viewer;
                        const startPoint = this.pdfViewerApi.transformPdfPointToScreenPoint(textSelection.startPoint);
                        const endPoint = this.pdfViewerApi.transformPdfPointToScreenPoint(textSelection.endPoint);
                        ctx.save();
                        const lineWidth = 2 * devicePixelRatio;
                        ctx.lineWidth = lineWidth;
                        ctx.setLineDash([lineWidth, lineWidth]);
                        ctx.strokeStyle = this.options.viewer.general.textSelectionColor;
                        ctx.strokeRect(startPoint.x, startPoint.y, endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                        ctx.restore();
                    }
                }
            }
        }
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/ScrollLayer.ts":
/*!**********************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/ScrollLayer.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollLayer": () => (/* binding */ ScrollLayer)
/* harmony export */ });
/* harmony import */ var _ViewLayerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewLayerBase */ "./src/pdf-viewer-canvas/view-layers/ViewLayerBase.ts");
/* harmony import */ var _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/DragMoveHandler */ "./src/common/DragMoveHandler.ts");
/* harmony import */ var _state_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");



class ScrollLayer extends _ViewLayerBase__WEBPACK_IMPORTED_MODULE_0__.ViewLayerBase {
    constructor() {
        super();
        this.horizontalScrollEnabled = false;
        this.horizontalScrollBarVisible = false;
        this.horizontalScrollRatio = 0;
        this.horizontalScrollBarSize = 0;
        this.horizontalScrollHandleSize = 0;
        this.horizontalScrollHandlePos = 0;
        this.horizontalScrollTimer = 0;
        this.horizontalScrollExpanded = false;
        this.verticalScrollEnabled = false;
        this.verticalScrollBarVisible = false;
        this.verticalScrollRatio = 0;
        this.verticalScrollBarSize = 0;
        this.verticalScrollHandleSize = 0;
        this.verticalScrollHandlePos = 0;
        this.verticalScrollTimer = 0;
        this.verticalScrollExpanded = false;
        this.canScrollDown = false;
        this.canScrollUp = false;
        this.canScrollRight = false;
        this.canScrollLeft = false;
        this.isTouchScrolling = false;
        this.recentTouchPos = [];
        this.touchScrollAxis = null;
        this.autoscrollLastTimestamp = 0;
        this.autoscrollDist = 0;
        this.autoscrollDistTime = 0;
        this.autoscrollDx = 0;
        this.startVerticalScroll = this.startVerticalScroll.bind(this);
        this.verticalScroll = this.verticalScroll.bind(this);
        this.endVerticalScroll = this.endVerticalScroll.bind(this);
        this.startHorizontalScroll = this.startHorizontalScroll.bind(this);
        this.horizontalScroll = this.horizontalScroll.bind(this);
        this.endHorizontalScroll = this.endHorizontalScroll.bind(this);
        this.horizontalScrollBar = document.createElement('div');
        this.horizontalScrollBar.style.display = 'none';
        this.horizontalScrollBar.classList.add('pwv-horizontal-scrollbar');
        this.horizontalScrollHandle = document.createElement('div');
        this.horizontalScrollHandle.classList.add('pwv-scrollbar-handle');
        this.horizontalScrollBar.appendChild(this.horizontalScrollHandle);
        this.verticalScrollBar = document.createElement('div');
        this.verticalScrollBar.style.display = 'none';
        this.verticalScrollBar.classList.add('pwv-vertical-scrollbar');
        this.verticalScrollHandle = document.createElement('div');
        this.verticalScrollHandle.classList.add('pwv-scrollbar-handle');
        this.verticalScrollBar.appendChild(this.verticalScrollHandle);
        new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_1__.DragMoveHandler(this.verticalScrollHandle, this.startVerticalScroll, this.verticalScroll, this.endVerticalScroll);
        new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_1__.DragMoveHandler(this.horizontalScrollHandle, this.startHorizontalScroll, this.horizontalScroll, this.endHorizontalScroll);
    }
    create() {
        this.htmlLayerElement = this.createHtmlLayer();
        this.htmlLayerElement.appendChild(this.horizontalScrollBar);
        this.htmlLayerElement.appendChild(this.verticalScrollBar);
    }
    render(timestamp, state) {
        const canvasHeight = state.canvas.height.cssPixels;
        const documentHeight = state.document.height.cssPixels;
        if (state.document.heightChanged || state.canvas.heightChanged) {
            this.verticalScrollEnabled = documentHeight > canvasHeight;
            if (this.verticalScrollEnabled !== this.verticalScrollBarVisible) {
                this.verticalScrollBar.style.display = this.verticalScrollEnabled ? 'block' : 'none';
                this.verticalScrollBarVisible = this.verticalScrollEnabled;
            }
            if (this.verticalScrollEnabled) {
                this.verticalScrollBarSize = this.verticalScrollBar.clientHeight;
                this.verticalScrollHandleSize = (this.verticalScrollBarSize * canvasHeight) / documentHeight;
                if (this.verticalScrollHandleSize < 50) {
                    this.verticalScrollHandleSize = 50;
                }
                this.verticalScrollHandle.style.height = this.verticalScrollHandleSize + 'px';
                this.verticalScrollRatio =
                    (this.verticalScrollBarSize - this.verticalScrollHandleSize) /
                        (documentHeight - canvasHeight);
            }
            this.updateCanScrollVertical(state);
        }
        if (state.scroll.topPositionChanged) {
            this.verticalScrollHandlePos = state.scroll.top.cssPixels * this.verticalScrollRatio;
            this.verticalScrollHandle.style.top = this.verticalScrollHandlePos + 'px';
            if (this.verticalScrollTimer) {
                clearTimeout(this.verticalScrollTimer);
            }
            else {
                this.verticalScrollBar.classList.add('pwv-scrollbar-scrolling');
            }
            this.verticalScrollTimer = window.setTimeout(() => {
                this.verticalScrollTimer = 0;
                this.verticalScrollBar.classList.remove('pwv-scrollbar-scrolling');
            }, 500);
            this.updateCanScrollVertical(state);
        }
        const canvasWidth = state.canvas.width.cssPixels;
        const documentWidth = state.document.width.cssPixels;
        if (state.document.widthChanged || state.canvas.widthChanged) {
            this.horizontalScrollEnabled = documentWidth > canvasWidth;
            if (this.horizontalScrollEnabled !== this.horizontalScrollBarVisible) {
                this.horizontalScrollBar.style.display = this.horizontalScrollEnabled ? 'block' : 'none';
                this.horizontalScrollBarVisible = this.horizontalScrollEnabled;
            }
            if (this.horizontalScrollEnabled) {
                this.horizontalScrollBarSize = this.horizontalScrollBar.clientWidth;
                this.horizontalScrollHandleSize =
                    (this.horizontalScrollBarSize * canvasWidth) / documentWidth;
                if (this.horizontalScrollHandleSize < 50) {
                    this.horizontalScrollHandleSize = 50;
                }
                this.horizontalScrollHandle.style.width = this.horizontalScrollHandleSize + 'px';
                this.horizontalScrollRatio =
                    (this.horizontalScrollBarSize - this.horizontalScrollHandleSize) /
                        (documentWidth - canvasWidth);
            }
            this.updateCanScrollHorizontal(state);
        }
        if (state.scroll.leftPositionChanged) {
            this.horizontalScrollHandlePos = state.scroll.left.cssPixels * this.horizontalScrollRatio;
            this.horizontalScrollHandle.style.left = this.horizontalScrollHandlePos + 'px';
            if (this.horizontalScrollTimer) {
                clearTimeout(this.horizontalScrollTimer);
            }
            else {
                this.horizontalScrollBar.classList.add('pwv-scrollbar-scrolling');
            }
            this.horizontalScrollTimer = window.setTimeout(() => {
                this.horizontalScrollTimer = 0;
                this.horizontalScrollBar.classList.remove('pwv-scrollbar-scrolling');
            }, 500);
            this.updateCanScrollHorizontal(state);
        }
        if (state.pointer.positionChanged) {
            const pointerX = state.pointer.x.cssPixels;
            const pointerY = state.pointer.y.cssPixels;
            const xPos = canvasWidth - 40;
            const yPos = canvasHeight - 40;
            if (!this.verticalScrollExpanded && pointerX > xPos && pointerY < yPos) {
                this.verticalScrollBar.classList.add('pwv-scrollbar-hover');
                this.verticalScrollExpanded = true;
            }
            else if (this.verticalScrollExpanded && (pointerX < xPos || pointerY > yPos)) {
                this.verticalScrollBar.classList.remove('pwv-scrollbar-hover');
                this.verticalScrollExpanded = false;
            }
            if (!this.horizontalScrollExpanded && pointerY > yPos && pointerX < xPos) {
                this.horizontalScrollBar.classList.add('pwv-scrollbar-hover');
                this.horizontalScrollExpanded = true;
            }
            else if (this.horizontalScrollExpanded && (pointerY < yPos || pointerX > xPos)) {
                this.horizontalScrollBar.classList.remove('pwv-scrollbar-hover');
                this.horizontalScrollExpanded = false;
            }
        }
        const pointer = state.pointer;
        const touchScrollEnabled = pointer.type === 'touch' &&
            (state.viewer.mode === _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.DEFAULT ||
                state.viewer.mode === _state_viewer__WEBPACK_IMPORTED_MODULE_2__.ViewerMode.ANNOTATION_SELECTED);
        if (touchScrollEnabled && this.viewerCanvas) {
            if (state.pointer.isDown) {
                if (!this.isTouchScrolling) {
                    this.isTouchScrolling = true;
                    this.autoscrollDx = 0;
                    this.touchScrollAxis = null;
                    this.recentTouchPos = [];
                    this.recentTouchPos.unshift({
                        x: pointer.x.cssPixels,
                        y: pointer.y.cssPixels,
                        time: timestamp,
                    });
                }
                else if (pointer.positionChanged) {
                    this.recentTouchPos.unshift({
                        x: pointer.x.cssPixels,
                        y: pointer.y.cssPixels,
                        time: timestamp,
                    });
                    if (this.recentTouchPos.length > 3) {
                        this.recentTouchPos.pop();
                    }
                    const diffX = this.recentTouchPos[1].x - this.recentTouchPos[0].x;
                    const diffY = this.recentTouchPos[1].y - this.recentTouchPos[0].y;
                    const diffXabs = Math.abs(diffX);
                    const diffYabs = Math.abs(diffY);
                    const scrollAxis = this.touchScrollAxis !== null
                        ? this.touchScrollAxis
                        : diffYabs > diffXabs
                            ? 'y'
                            : diffXabs > diffYabs
                                ? 'x'
                                : null;
                    if (this.verticalScrollEnabled && scrollAxis === 'y') {
                        if ((diffY > 0 && this.canScrollDown) || (diffY < 0 && this.canScrollUp)) {
                            this.viewerCanvas.scrollDown(diffY);
                        }
                    }
                    else if (this.horizontalScrollEnabled && this.touchScrollAxis === 'x') {
                        if ((diffX > 0 && this.canScrollRight) || (diffX < 0 && this.canScrollLeft)) {
                            this.viewerCanvas.scrollRight(diffX);
                        }
                    }
                    if (this.touchScrollAxis === null && this.recentTouchPos.length >= 3) {
                        this.touchScrollAxis = diffYabs > diffXabs ? 'y' : diffXabs > diffYabs ? 'x' : null;
                    }
                }
            }
            else if (this.isTouchScrolling) {
                this.isTouchScrolling = false;
                if (this.touchScrollAxis === 'x') {
                    this.autoscrollDist = this.recentTouchPos[2].x - this.recentTouchPos[0].x;
                    this.autoscrollDistTime = this.recentTouchPos[0].time - this.recentTouchPos[2].time;
                    this.autoscrollDx = Math.abs(this.autoscrollDist / this.autoscrollDistTime);
                    this.autoscrollLastTimestamp = timestamp;
                }
                else if (this.touchScrollAxis === 'y') {
                    this.autoscrollDist = this.recentTouchPos[2].y - this.recentTouchPos[0].y;
                    this.autoscrollDistTime = this.recentTouchPos[0].time - this.recentTouchPos[2].time;
                    this.autoscrollDx = Math.abs(this.autoscrollDist / this.autoscrollDistTime);
                    this.autoscrollLastTimestamp = timestamp;
                }
            }
        }
        if (this.viewerCanvas && this.autoscrollDx !== 0) {
            const time = timestamp - this.autoscrollLastTimestamp;
            if (time > 1000 / 70) {
                if (this.autoscrollDx > 3) {
                    this.autoscrollDx = 3;
                }
                if (this.touchScrollAxis === 'y' &&
                    ((this.autoscrollDist > 0 && !this.canScrollDown) ||
                        (this.autoscrollDist < 0 && !this.canScrollUp))) {
                    this.autoscrollDx = 0;
                }
                else if (this.touchScrollAxis === 'x' &&
                    ((this.autoscrollDist > 0 && !this.canScrollRight) ||
                        (this.autoscrollDist < 0 && !this.canScrollLeft))) {
                    this.autoscrollDx = 0;
                }
                else {
                    const direction = Math.sign(this.autoscrollDist);
                    const distance = Math.abs(this.autoscrollDist);
                    const timeFactor = time / this.autoscrollDistTime;
                    const diff = Math.min(100, distance * this.autoscrollDx) * timeFactor;
                    const scrollDiff = diff * direction;
                    if (Math.abs(scrollDiff) < 1) {
                        this.autoscrollDx = 0;
                    }
                    else {
                        if (this.touchScrollAxis === 'y') {
                            this.viewerCanvas.scrollDown(scrollDiff);
                        }
                        else {
                            this.viewerCanvas.scrollRight(scrollDiff);
                        }
                    }
                    const throttleDiff = this.autoscrollDx * 0.08 * timeFactor;
                    this.autoscrollDx = this.autoscrollDx - throttleDiff;
                    this.autoscrollLastTimestamp = timestamp;
                }
            }
        }
    }
    updateCanScrollVertical(state) {
        this.canScrollUp = state.scroll.top.cssPixels > 0;
        this.canScrollDown =
            state.scroll.top.cssPixels + state.canvas.height.cssPixels <
                state.document.height.cssPixels - 1;
    }
    updateCanScrollHorizontal(state) {
        this.canScrollLeft = state.scroll.left.cssPixels > 0;
        this.canScrollRight =
            state.scroll.left.cssPixels + state.canvas.width.cssPixels <
                state.document.width.cssPixels - 1;
    }
    startVerticalScroll(e) {
        this.verticalScrollBar.classList.add('pwv-scrollbar-dragging');
    }
    verticalScroll(e) {
        if (this.viewerCanvas) {
            const scrollDiv = e.movementY / this.verticalScrollRatio;
            this.viewerCanvas.scrollDown(scrollDiv);
        }
    }
    endVerticalScroll(e) {
        this.verticalScrollBar.classList.remove('pwv-scrollbar-dragging');
    }
    startHorizontalScroll(e) {
        this.horizontalScrollBar.classList.add('pwv-scrollbar-dragging');
    }
    horizontalScroll(e) {
        if (this.viewerCanvas) {
            const scrollDiv = e.movementX / this.horizontalScrollRatio;
            this.viewerCanvas.scrollRight(scrollDiv);
        }
    }
    endHorizontalScroll(e) {
        this.horizontalScrollBar.classList.remove('pwv-scrollbar-dragging');
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/TextSelectionLayer.ts":
/*!*****************************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/TextSelectionLayer.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextSelectionLayer": () => (/* binding */ TextSelectionLayer)
/* harmony export */ });
/* harmony import */ var _ViewLayerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewLayerBase */ "./src/pdf-viewer-canvas/view-layers/ViewLayerBase.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _views_TextSelectionContextBar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./views/TextSelectionContextBar */ "./src/pdf-viewer-canvas/view-layers/views/TextSelectionContextBar.tsx");
/* harmony import */ var _common_Color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/Color */ "./src/common/Color.ts");
/* harmony import */ var _state_viewer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../state/viewer */ "./src/pdf-viewer-canvas/state/viewer.ts");
/* harmony import */ var _custom_history__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../custom/history */ "./src/custom/history.ts");






class TextSelectionLayer extends _ViewLayerBase__WEBPACK_IMPORTED_MODULE_0__.ViewLayerBase {
    constructor() {
        super();
        this.startPoint = null;
        this.selecting = false;
        this.contextBarElement = null;
        this.selectionType = null;
        this.createAnnotation = this.createAnnotation.bind(this);
        this.copyTextSelection = this.copyTextSelection.bind(this);
    }
    create() { }
    render(timestamp, state) {
        var _a;
        if (state.viewer.mode !== _state_viewer__WEBPACK_IMPORTED_MODULE_4__.ViewerMode.TEXT_SELECTED) {
            if (this.contextBarElement) {
                this.removeHtmlElements();
                this.contextBarElement = null;
            }
        }
        if (state.viewer.mode === _state_viewer__WEBPACK_IMPORTED_MODULE_4__.ViewerMode.MODULE_SELECTED) {
            return;
        }
        let updateContextBarPos = true;
        if (state.pointer.action === 'click') {
            this.endSelection();
        }
        else if (state.pointer.action === 'dblclick') {
            const clickPos = this.pdfViewerApi.transformScreenPointToPdfPoint({
                x: state.pointer.x.devicePixels,
                y: state.pointer.y.devicePixels,
            });
            const wordSelection = this.pdfViewerApi.getWordOnPoint(clickPos.pdfPoint);
            this.store.viewer.setTextSelection({ selection: wordSelection, type: 'normal' });
            this.selectionCreated();
        }
        else if (state.viewer.mode === _state_viewer__WEBPACK_IMPORTED_MODULE_4__.ViewerMode.DEFAULT &&
            !this.selecting &&
            ((state.pointer.type === 'mouse' && state.pointer.action === 'startdrag') ||
                state.pointer.action === 'longpress')) {
            const screenPos = {
                x: state.startPointer.x.devicePixels,
                y: state.startPointer.y.devicePixels,
            };
            const startPos = this.pdfViewerApi.transformScreenPointToPdfPoint(screenPos);
            const textOnPoint = this.pdfViewerApi.getTextFragmentOnPoint(screenPos);
            if (this.options.viewer.general.rectangularTextSelection === 'automatic') {
                this.selectionType = textOnPoint ? 'normal' : 'rectangular';
                this.startSelection(startPos.pdfPoint);
            }
            else {
                if (textOnPoint) {
                    this.startSelection(startPos.pdfPoint);
                }
            }
        }
        else if (this.selecting) {
            if (state.pointer.isDown) {
                if (state.pointer.positionChanged) {
                    const mousePos = this.pdfViewerApi.getClosestPointOnPdfByScreenPoint({
                        x: state.pointer.x.devicePixels,
                        y: state.pointer.y.devicePixels,
                    });
                    if (this.startPoint) {
                        const textSelection = this.selectionType === 'rectangular'
                            ? this.pdfViewerApi.getRectangularTextSelection(this.startPoint, mousePos)
                            : this.pdfViewerApi.getTextSelection(this.startPoint, mousePos);
                        this.store.viewer.setTextSelection({
                            selection: textSelection,
                            type: this.selectionType,
                        });
                        this.store.viewer.setTextSelectionState('selecting');
                    }
                }
            }
            else {
                if ((_a = state.viewer.textSelection) === null || _a === void 0 ? void 0 : _a.quadrilaterals.length) {
                    this.selectionCreated();
                }
                else {
                    this.endSelection();
                }
            }
        }
        if (this.selecting && state.pointer.y.devicePixels > -1) {
            const padding = 30;
            const dxScroll = 20;
            if (state.pointer.y.devicePixels > state.canvas.height.devicePixels - padding) {
                this.pdfViewerApi.setScrollPosition({
                    x: state.scroll.left.devicePixels,
                    y: state.scroll.top.devicePixels + dxScroll,
                });
            }
            else if (state.pointer.y.devicePixels < padding) {
                this.pdfViewerApi.setScrollPosition({
                    x: state.scroll.left.devicePixels,
                    y: state.scroll.top.devicePixels - dxScroll,
                });
            }
            else if (state.pointer.x.devicePixels > state.canvas.width.devicePixels - padding) {
                this.pdfViewerApi.setScrollPosition({
                    x: state.scroll.left.devicePixels + dxScroll,
                    y: state.scroll.top.devicePixels,
                });
            }
            else if (state.pointer.x.devicePixels < padding) {
                this.pdfViewerApi.setScrollPosition({
                    x: state.scroll.left.devicePixels - dxScroll,
                    y: state.scroll.top.devicePixels,
                });
            }
        }
        if (updateContextBarPos && this.contextBarElement && state.viewer.textSelectionRects) {
            const padding = 25;
            let barTopPos = padding;
            let barLeftPos = 0;
            let isTopPos = false;
            let isBottomPos = false;
            let screenRect = null;
            const { firstVisiblePage, lastVisiblePage } = state.document;
            Object.keys(state.viewer.textSelectionRects).forEach((page) => {
                const pageNumber = parseInt(page);
                if (pageNumber >= firstVisiblePage && pageNumber <= lastVisiblePage) {
                    if (state.viewer.textSelectionRects) {
                        const pageScreenRect = this.pdfViewerApi.transformPdfPageRectToScreenRect(state.viewer.textSelectionRects[page]);
                        if (pageScreenRect) {
                            screenRect = {
                                x1: pageScreenRect.x / devicePixelRatio,
                                y1: pageScreenRect.y / devicePixelRatio,
                                x2: pageScreenRect.x / devicePixelRatio + pageScreenRect.w / devicePixelRatio,
                                y2: pageScreenRect.y / devicePixelRatio + pageScreenRect.h / devicePixelRatio,
                            };
                        }
                    }
                }
            });
            if (screenRect) {
                const { x1, y1, x2, y2 } = screenRect;
                if (y1 > 90) {
                    barTopPos = y1 - 65;
                    isTopPos = true;
                }
                else if (state.canvas.height.cssPixels / 2 > y2) {
                    barTopPos = y2 + 15;
                    isBottomPos = true;
                }
                const barWidth = this.contextBarElement.clientWidth;
                barLeftPos = x1 + (x2 - x1 - barWidth) / 2;
                if (barLeftPos < 0) {
                    barLeftPos = 0;
                }
            }
            else {
                barTopPos = -90;
            }
            this.contextBarElement.style.top = barTopPos + 'px';
            this.contextBarElement.style.left = barLeftPos + 'px';
            if (isTopPos) {
                this.contextBarElement.classList.add('pwv-contextbar-top');
            }
            else {
                this.contextBarElement.classList.remove('pwv-contextbar-top');
            }
            if (isBottomPos) {
                this.contextBarElement.classList.add('pwv-contextbar-bottom');
            }
            else {
                this.contextBarElement.classList.remove('pwv-contextbar-bottom');
            }
        }
    }
    clearSelection() {
        this.endSelection();
    }
    clearHtmlDocumentSelection() {
        const documentSelection = document.getSelection();
        if (documentSelection && !documentSelection.isCollapsed) {
            documentSelection.empty();
        }
    }
    startSelection(startPoint) {
        this.clearHtmlDocumentSelection();
        this.removeHtmlElements();
        this.contextBarElement = null;
        this.selecting = true;
        if (this.startPoint === null) {
            this.startPoint = startPoint;
        }
        this.store.viewer.setCursorStyle(_state_viewer__WEBPACK_IMPORTED_MODULE_4__.CursorStyle.TEXT);
    }
    endSelection() {
        this.removeHtmlElements();
        this.contextBarElement = null;
        this.selecting = false;
        this.startPoint = null;
        this.clearHtmlDocumentSelection();
        window.setTimeout(() => {
            this.selectionType = null;
            this.store.viewer.setTextSelection({ selection: null, type: null });
            this.store.viewer.setTextSelectionState(null);
        }, 50);
    }
    selectionCreated() {
        var _a;
        this.selecting = false;
        if (this.contextBarElement) {
            this.removeHtmlElements();
        }
        this.store.viewer.setCursorStyle(_state_viewer__WEBPACK_IMPORTED_MODULE_4__.CursorStyle.DEFAULT);
        this.store.viewer.setTextSelectionState('textSelected');
        const isViewOnly = !((_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.licenseFeatures.annotate);
        const allowCopyText = this.options.viewer.permissions.allowCopyText;
        if (isViewOnly && !allowCopyText) {
            return;
        }
        this.contextBarElement = this.createHtmlLayer();
        this.contextBarElement.classList.add('pwv-textselection-contextbar');
        this.contextBarElement.classList.add('pwv-contextbar-top');
        (0,_views_TextSelectionContextBar__WEBPACK_IMPORTED_MODULE_2__.createTextSelectionContextBar)({
            highlightColors: this.options.annotation.colors.highlightColors,
            onCreateAnnotation: this.createAnnotation,
            onCopyText: this.copyTextSelection,
            isViewOnly,
            allowCopyText,
        }, this.contextBarElement);
        this.viewerCanvas.onTextSelected();
    }
    createAnnotation(itemType, color) {
        if (this.pdfViewerApi && this.store) {
            const selection = this.store.getState().viewer.textSelection;
            if (selection) {
                const selectionByPage = [];
                for (let i = 0; i < selection.quadrilaterals.length; i++) {
                    const quadrilateral = selection.quadrilaterals[i];
                    if (!selectionByPage[quadrilateral.pageNumber]) {
                        selectionByPage[quadrilateral.pageNumber] = [];
                    }
                    selectionByPage[quadrilateral.pageNumber].push(quadrilateral);
                }
                if (itemType === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.HIGHLIGHT) {
                    const colorObj = new _common_Color__WEBPACK_IMPORTED_MODULE_3__.Color(color);
                    colorObj.setOpacity(this.options.annotation.highlightOpacity);
                    color = colorObj.toRgba();
                }
                for (let i = 0; i < selectionByPage.length; i++) {
                    if (selectionByPage[i]) {
                        const quadrilaterals = selectionByPage[i];
                        const args = {
                            itemType,
                            page: i,
                            pdfRect: {
                                pdfX: 0,
                                pdfY: 0,
                                pdfW: 0,
                                pdfH: 0,
                                page: i,
                            },
                            color,
                            author: this.options.viewer.general.user,
                            quadrilaterals,
                        };
                        this.pdfViewerApi.createItem(args).then((annotation) => {
                            if (this.options.annotation.trackHistory) {
                                (0,_custom_history__WEBPACK_IMPORTED_MODULE_5__.addHistoryEntry)(annotation, 'create', this.options.viewer.general.user);
                                this.pdfViewerApi.updateItem(annotation);
                            }
                        });
                        this.endSelection();
                    }
                }
            }
        }
    }
    copyTextSelection() {
        var _a;
        const selectedText = (_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.getSelectedText();
        (0,_state_viewer__WEBPACK_IMPORTED_MODULE_4__.copyTextToClipboard)(selectedText || '');
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/ViewLayerBase.ts":
/*!************************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/ViewLayerBase.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewLayerBase": () => (/* binding */ ViewLayerBase)
/* harmony export */ });
/* harmony import */ var _custom_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../custom/history */ "./src/custom/history.ts");

class ViewLayerBase {
    constructor() {
        this.canvasContexts = [];
        this.htmlLayers = [];
    }
    get pdfViewerApi() {
        if (!this.pPdfViewerApi) {
            this.pPdfViewerApi = this.viewerCanvas.pdfViewerApi;
            if (!this.pPdfViewerApi) {
                throw new Error('pdfViewerApi in undefined');
            }
        }
        return this.pPdfViewerApi;
    }
    get store() {
        if (!this.pStore) {
            this.pStore = this.viewerCanvas.store;
            if (!this.pStore) {
                throw new Error('pStore in undefined');
            }
        }
        return this.pStore;
    }
    get options() {
        if (!this.pOptions) {
            this.pOptions = this.viewerCanvas.options;
            if (!this.pOptions) {
                throw new Error('options in undefined');
            }
        }
        return this.pOptions;
    }
    resize(width, height, pixelRatio) {
        try {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width * pixelRatio;
            tempCanvas.height = height * pixelRatio;
            const tempContext = tempCanvas.getContext('2d');
            this.canvasContexts.forEach((ctx) => {
                tempContext.drawImage(ctx.canvas, 0, 0);
                ctx.canvas.style.width = width + 'px';
                ctx.canvas.style.height = height + 'px';
                ctx.canvas.width = width * pixelRatio;
                ctx.canvas.height = height * pixelRatio;
                ctx.drawImage(tempContext.canvas, 0, 0);
            });
        }
        catch (err) {
            console.warn(err);
        }
    }
    register(viewerCanvas, dispatchEvent) {
        this.viewerCanvas = viewerCanvas;
        this.dispatchEvent = dispatchEvent;
        this.containerElement = this.viewerCanvas.viewLayersElement;
        this.create();
    }
    createHtmlLayer() {
        const element = document.createElement('div');
        this.htmlLayers.push(element);
        if (this.containerElement) {
            this.containerElement.appendChild(element);
        }
        return element;
    }
    createCanvas(className) {
        const element = document.createElement('canvas');
        element.style.position = 'absolute';
        element.style.top = '0';
        element.style.left = '0';
        element.style.right = '0';
        element.style.bottom = '0';
        if (className) {
            element.classList.add(className);
        }
        const context = element.getContext('2d');
        this.canvasContexts.push(context);
        if (this.containerElement) {
            this.containerElement.appendChild(element);
            const rect = this.containerElement.getBoundingClientRect();
            context.canvas.width = rect.width * devicePixelRatio;
            context.canvas.height = rect.height * devicePixelRatio;
        }
        return context;
    }
    removeHtmlElements() {
        if (this.containerElement) {
            for (let i = 0; i < this.htmlLayers.length; i++) {
                this.containerElement.removeChild(this.htmlLayers[i]);
            }
            this.htmlLayers = [];
        }
    }
    removeCanvasElements() {
        if (this.containerElement) {
            for (let i = 0; i < this.canvasContexts.length; i++) {
                this.containerElement.removeChild(this.canvasContexts[i].canvas);
            }
            this.canvasContexts = [];
        }
    }
    addDeleteHistory(annotation) {
        (0,_custom_history__WEBPACK_IMPORTED_MODULE_0__.addHistoryEntry)(annotation, 'delete', this.options.viewer.general.user);
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/canvasShapes.ts":
/*!***********************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/canvasShapes.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "renderAnnotationSelection": () => (/* binding */ renderAnnotationSelection),
/* harmony export */   "renderPopupMarker": () => (/* binding */ renderPopupMarker),
/* harmony export */   "renderStickyNote": () => (/* binding */ renderStickyNote),
/* harmony export */   "renderTextMarker": () => (/* binding */ renderTextMarker),
/* harmony export */   "renderTextSelection": () => (/* binding */ renderTextSelection)
/* harmony export */ });
const renderAnnotationSelection = (ctx, scale, color, rect, resizable) => {
    const handle = 10 * scale;
    const handleOffset = handle / 2;
    const padding = 4 * scale;
    const x = rect.x - padding;
    const y = rect.y - padding;
    const w = rect.w + 2 * padding;
    const h = rect.h + 2 * padding;
    ctx.lineWidth = 2 * scale;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    if (resizable) {
        const x1 = x - handleOffset;
        const x2 = x1 + w;
        const y1 = y - handleOffset;
        const y2 = y1 + h;
        ctx.fillRect(x1, y1, handle, handle);
        ctx.fillRect(x1, y2, handle, handle);
        ctx.fillRect(x2, y1, handle, handle);
        ctx.fillRect(x2, y2, handle, handle);
    }
    ctx.strokeRect(x, y, w, h);
};
const renderTextMarker = (ctx, scale, type, color, rect) => {
    ctx.save();
    const startType = type === 'start';
    const lineWidth = 2 * scale;
    const p = 3 * scale;
    const x = startType ? rect.x - lineWidth / 2 : rect.x + rect.w + lineWidth / 2;
    const y1 = startType ? rect.y - p : rect.y + rect.h + p;
    const y2 = startType ? rect.y + rect.h : rect.y;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.moveTo(x, y1);
    ctx.lineTo(x, y2);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
};
const renderTextSelection = (ctx, scale, color, selection) => {
    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = color;
    if (selection.length) {
        ctx.beginPath();
        for (let i = 0; i < selection.length; i++) {
            const path = selection[i];
            for (let k = 0; k < path.length; k++) {
                const point = path[k];
                if (k === 0) {
                    ctx.moveTo(point.x, point.y);
                }
                else {
                    ctx.lineTo(point.x, point.y);
                }
            }
        }
        ctx.closePath();
        ctx.fill();
    }
    ctx.restore();
};
const renderPopupMarker = (ctx, scale, color, pos) => {
    const posX = pos.x;
    const posY = pos.y;
    ctx.beginPath();
    ctx.moveTo(posX - 5 * scale, posY - 5 * scale);
    ctx.lineTo(posX + 6 * scale, posY - 5 * scale);
    ctx.lineTo(posX + 6 * scale, posY + 3 * scale);
    ctx.lineTo(posX + 3 * scale, posY + 3 * scale);
    ctx.lineTo(posX, posY + 6 * scale);
    ctx.lineTo(posX - 3 * scale, posY + 3 * scale);
    ctx.lineTo(posX - 5 * scale, posY + 3 * scale);
    ctx.closePath();
    ctx.stroke();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = color;
    ctx.fill();
    ctx.globalAlpha = 1;
};
const renderStickyNote = (ctx, scale, rect, fillColor, strokeColor) => {
    const w = rect.w;
    const h1 = rect.h * 0.8;
    const h2 = rect.h;
    const r = rect.w / 6;
    const s = rect.w / 10;
    const x1 = rect.x;
    const y1 = rect.y;
    const x1r = x1 + r;
    const y1r = y1 + r;
    const x2 = x1 + w;
    const y2 = y1 + h1;
    const x2r = x2 - r;
    const y2r = y2 - r;
    const xs1 = x1r + r;
    const xs2 = xs1 + r;
    const xs3 = x1r + s;
    const ys3 = y1 + h2;
    ctx.beginPath();
    ctx.moveTo(x1r, y1);
    ctx.lineTo(x2r, y1);
    ctx.arcTo(x2, y1, x2, y1r, r);
    ctx.lineTo(x2, y2r);
    ctx.arcTo(x2, y2, x2r, y2, r);
    ctx.lineTo(xs2, y2);
    ctx.lineTo(xs3, ys3);
    ctx.lineTo(xs1, y2);
    ctx.lineTo(x1r, y2);
    ctx.arcTo(x1, y2, x1, y2r, r);
    ctx.lineTo(x1, y1r);
    ctx.arcTo(x1, y1, x1r, y1, r);
    ctx.closePath();
    ctx.lineWidth = 0.75 * scale;
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.fill();
    ctx.stroke();
    const x1l = x1r + 1 * scale;
    const x2l = x2r - 1 * scale;
    const x3l = x2r - r;
    const y1l = y1r + 1 * scale;
    const y3l = y2r - 1 * scale;
    const y2l = y1l + (y3l - y1l) / 2;
    ctx.beginPath();
    ctx.moveTo(x1l, y1l);
    ctx.lineTo(x2l, y1l);
    ctx.closePath();
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x1l, y2l);
    ctx.lineTo(x2l, y2l);
    ctx.closePath();
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x1l, y3l);
    ctx.lineTo(x3l, y3l);
    ctx.closePath();
    ctx.stroke();
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/views/AnnotationBorder.ts":
/*!*********************************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/views/AnnotationBorder.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationBorder": () => (/* binding */ AnnotationBorder)
/* harmony export */ });
/* harmony import */ var _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/DragMoveHandler */ "./src/common/DragMoveHandler.ts");

var ResizeDir;
(function (ResizeDir) {
    ResizeDir[ResizeDir["NW"] = 1] = "NW";
    ResizeDir[ResizeDir["NE"] = 2] = "NE";
    ResizeDir[ResizeDir["SW"] = 3] = "SW";
    ResizeDir[ResizeDir["SE"] = 4] = "SE";
})(ResizeDir || (ResizeDir = {}));
const MIN_SIZE = 20;
class AnnotationBorder {
    constructor(element, onMoved, onResized, onDblClick, options, store, isViewOnly) {
        this.annotationId = null;
        this.movable = false;
        this.resizable = false;
        this.aspectRatio = null;
        this.pageRect = null;
        this.dragOffsetX = 0;
        this.dragOffsetY = 0;
        this.containerOffsetX = 0;
        this.containerOffsetY = 0;
        this.resizeDir = null;
        this.minSize = MIN_SIZE;
        this.startMove = this.startMove.bind(this);
        this.moving = this.moving.bind(this);
        this.endMove = this.endMove.bind(this);
        this.click = this.click.bind(this);
        this.dblClick = this.dblClick.bind(this);
        this.setAnnotation = this.setAnnotation.bind(this);
        this.deselectAnnotation = this.deselectAnnotation.bind(this);
        this.startResize = this.startResize.bind(this);
        this.resizing = this.resizing.bind(this);
        this.resizeNoAspectRatio = this.resizeNoAspectRatio.bind(this);
        this.resizeWithAspectRatio = this.resizeWithAspectRatio.bind(this);
        this.endResize = this.endResize.bind(this);
        this.dragElement = document.createElement('div');
        this.border = document.createElement('div');
        this.resizeElementNw = document.createElement('div');
        this.resizeElementNe = document.createElement('div');
        this.resizeElementSw = document.createElement('div');
        this.resizeElementSe = document.createElement('div');
        this.isViewOnly = isViewOnly;
        this.onMoved = onMoved;
        this.onResized = onResized;
        this.onDblClick = onDblClick;
        this.element = element;
        this.options = options;
        this.store = store;
        this.element.appendChild(this.dragElement);
        this.dragElement.classList.add('pwv-annotation-border-draghandle');
        this.dragElement.style.display = 'none';
        this.dragHandler = new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_0__.DragMoveHandler(this.dragElement, this.startMove, this.moving, this.endMove, this.click, this.dblClick);
        this.dragHandler.suspend();
        this.element.appendChild(this.border);
        this.border.classList.add('pwv-annotation-border');
        this.element.appendChild(this.resizeElementNw);
        this.resizeElementNw.classList.add('pwv-annotation-border-resizehandle-nw');
        this.resizeElementNw.style.display = 'none';
        this.resizeHandlerNw = new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_0__.DragMoveHandler(this.resizeElementNw, this.startResize, this.resizing, this.endResize);
        this.resizeHandlerNw.suspend();
        this.element.appendChild(this.resizeElementNe);
        this.resizeElementNe.classList.add('pwv-annotation-border-resizehandle-ne');
        this.resizeElementNe.style.display = 'none';
        this.resizeHandlerNe = new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_0__.DragMoveHandler(this.resizeElementNe, this.startResize, this.resizing, this.endResize);
        this.resizeHandlerNe.suspend();
        this.element.appendChild(this.resizeElementSw);
        this.resizeElementSw.classList.add('pwv-annotation-border-resizehandle-sw');
        this.resizeElementSw.style.display = 'none';
        this.resizeHandlerSw = new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_0__.DragMoveHandler(this.resizeElementSw, this.startResize, this.resizing, this.endResize);
        this.resizeHandlerSw.suspend();
        this.element.appendChild(this.resizeElementSe);
        this.resizeElementSe.classList.add('pwv-annotation-border-resizehandle-se');
        this.resizeElementSe.style.display = 'none';
        this.resizeHandlerSe = new _common_DragMoveHandler__WEBPACK_IMPORTED_MODULE_0__.DragMoveHandler(this.resizeElementSe, this.startResize, this.resizing, this.endResize);
        this.resizeHandlerSe.suspend();
    }
    setAnnotation(annotation, pageRect) {
        const { behaviors } = annotation;
        const isReadOnly = annotation.isReadOnly();
        const isLocked = annotation.isLocked() && !this.options.viewer.permissions.allowEditLockedAnnotations;
        this.annotationId = annotation.id;
        this.movable = behaviors.movable && !isLocked && !isReadOnly;
        this.resizable = behaviors.resizable && !isLocked && !isReadOnly;
        this.aspectRatio = behaviors.aspectRatioChangeable
            ? null
            : annotation.pdfRect.pdfW / annotation.pdfRect.pdfH;
        this.pageRect = pageRect;
        if (this.movable) {
            this.dragElement.style.display = 'block';
        }
        if (this.resizable) {
            this.resizeElementNw.style.display = 'block';
            this.resizeElementNe.style.display = 'block';
            this.resizeElementSw.style.display = 'block';
            this.resizeElementSe.style.display = 'block';
        }
        window.setTimeout(() => {
            if (this.movable) {
                this.dragHandler.resume();
            }
            if (this.resizable) {
                this.resizeHandlerNw.resume();
                this.resizeHandlerNe.resume();
                this.resizeHandlerSw.resume();
                this.resizeHandlerSe.resume();
            }
        }, 100);
    }
    deselectAnnotation() {
        this.annotationId = null;
        this.movable = false;
        this.resizable = false;
        this.aspectRatio = 0;
        this.pageRect = null;
        this.dragHandler.suspend();
        this.resizeHandlerNw.suspend();
        this.resizeHandlerNe.suspend();
        this.resizeHandlerSw.suspend();
        this.resizeHandlerSe.suspend();
        this.dragElement.style.display = 'none';
        this.resizeElementNw.style.display = 'none';
        this.resizeElementNe.style.display = 'none';
        this.resizeElementSw.style.display = 'none';
        this.resizeElementSe.style.display = 'none';
    }
    updatePageRect(pageRect) {
        this.pageRect = pageRect;
    }
    click() { }
    dblClick() {
        if (this.annotationId) {
            this.onDblClick(this.annotationId);
        }
    }
    startResize(e) {
        if (e.element.classList.contains('pwv-annotation-border-resizehandle-nw')) {
            this.resizeDir = ResizeDir.NW;
        }
        else if (e.element.classList.contains('pwv-annotation-border-resizehandle-ne')) {
            this.resizeDir = ResizeDir.NE;
        }
        else if (e.element.classList.contains('pwv-annotation-border-resizehandle-sw')) {
            this.resizeDir = ResizeDir.SW;
        }
        else if (e.element.classList.contains('pwv-annotation-border-resizehandle-se')) {
            this.resizeDir = ResizeDir.SE;
        }
        this.element.classList.add('pwv-annotation-resizing');
    }
    resizing(e) {
        if (this.aspectRatio !== null) {
            this.resizeWithAspectRatio(e.clientX, e.clientY);
        }
        else {
            this.resizeNoAspectRatio(e.clientX, e.clientY);
        }
    }
    updateMinSize() {
        const { document } = this.store.getState();
        this.minSize = document.zoom * MIN_SIZE;
    }
    resizeNoAspectRatio(clientX, clientY) {
        if (this.element && this.element.offsetParent && this.pageRect) {
            this.updateMinSize();
            const offsetRect = this.element.offsetParent.getBoundingClientRect();
            const elementRect = this.element.getBoundingClientRect();
            const minLeft = this.pageRect.x / window.devicePixelRatio;
            const maxLeft = minLeft + this.pageRect.w / window.devicePixelRatio;
            const minTop = this.pageRect.y / window.devicePixelRatio;
            const maxTop = minTop + this.pageRect.h / window.devicePixelRatio;
            let pointerX = clientX - offsetRect.left;
            if (pointerX < minLeft) {
                pointerX = minLeft;
            }
            else if (pointerX > maxLeft) {
                pointerX = maxLeft;
            }
            let pointerY = clientY - offsetRect.top;
            if (pointerY < minTop) {
                pointerY = minTop;
            }
            else if (pointerY > maxTop) {
                pointerY = maxTop;
            }
            let topPos = elementRect.top - offsetRect.top;
            let leftPos = elementRect.left - offsetRect.left;
            let width = elementRect.width;
            let height = elementRect.height;
            if (this.resizeDir === ResizeDir.NE || this.resizeDir === ResizeDir.SE) {
                width = pointerX - leftPos;
                if (width < this.minSize) {
                    width = this.minSize;
                }
            }
            if (this.resizeDir === ResizeDir.NW || this.resizeDir === ResizeDir.SW) {
                width = leftPos + width - pointerX;
                if (width < this.minSize) {
                    width = this.minSize;
                    leftPos = elementRect.left - offsetRect.left + elementRect.width - width;
                }
                else {
                    leftPos = pointerX;
                }
            }
            if (this.resizeDir === ResizeDir.SE || this.resizeDir === ResizeDir.SW) {
                height = pointerY - topPos;
                if (height < this.minSize) {
                    height = this.minSize;
                }
            }
            if (this.resizeDir === ResizeDir.NE || this.resizeDir === ResizeDir.NW) {
                height = topPos + height - pointerY;
                if (height < this.minSize) {
                    height = this.minSize;
                    topPos = elementRect.top - offsetRect.top + elementRect.height - height;
                }
                else {
                    topPos = pointerY;
                }
            }
            this.element.style.top = topPos + 'px';
            this.element.style.left = leftPos + 'px';
            this.element.style.width = width + 'px';
            this.element.style.height = height + 'px';
        }
    }
    resizeWithAspectRatio(clientX, clientY) {
        if (this.pageRect && this.aspectRatio !== null && this.element && this.element.offsetParent) {
            this.updateMinSize();
            const offsetRect = this.element.offsetParent.getBoundingClientRect();
            const elementRect = this.element.getBoundingClientRect();
            const minLeft = this.pageRect.x / window.devicePixelRatio;
            const maxLeft = minLeft + this.pageRect.w / window.devicePixelRatio;
            const minTop = this.pageRect.y / window.devicePixelRatio;
            const maxTop = minTop + this.pageRect.h / window.devicePixelRatio;
            let pointerX = clientX - offsetRect.left;
            if (pointerX < minLeft) {
                pointerX = minLeft;
            }
            else if (pointerX > maxLeft) {
                pointerX = maxLeft;
            }
            let pointerY = clientY - offsetRect.top;
            if (pointerY < minTop) {
                pointerY = minTop;
            }
            else if (pointerY > maxTop) {
                pointerY = maxTop;
            }
            let topPos = elementRect.top - offsetRect.top;
            let leftPos = elementRect.left - offsetRect.left;
            let width = elementRect.width;
            let height = elementRect.height;
            const calcSize = (w, h, r) => {
                if (this.store.getState().document.rotation % 180 !== 0)
                    r = 1 / r;
                const size = { w, h };
                if (w / h < r) {
                    size.w = Math.max(w, this.minSize);
                    size.h = size.w / r;
                    if (size.h < this.minSize) {
                        size.h = this.minSize;
                        size.w = size.h * r;
                    }
                }
                else {
                    size.h = Math.max(h, this.minSize);
                    size.w = size.h * r;
                    if (size.w < this.minSize) {
                        size.w = this.minSize;
                        size.h = size.w * r;
                    }
                }
                return size;
            };
            if (this.resizeDir === ResizeDir.NW) {
                const w = leftPos + width - pointerX;
                const h = topPos + height - pointerY;
                const size = calcSize(w, h, this.aspectRatio);
                leftPos = leftPos + width - size.w;
                topPos = topPos + height - size.h;
                width = size.w;
                height = size.h;
            }
            if (this.resizeDir === ResizeDir.NE) {
                const w = pointerX - leftPos;
                const h = topPos + height - pointerY;
                const size = calcSize(w, h, this.aspectRatio);
                topPos = topPos + height - size.h;
                width = size.w;
                height = size.h;
            }
            if (this.resizeDir === ResizeDir.SW) {
                const w = leftPos + width - pointerX;
                const h = pointerY - topPos;
                const size = calcSize(w, h, this.aspectRatio);
                leftPos = leftPos + width - size.w;
                width = size.w;
                height = size.h;
            }
            if (this.resizeDir === ResizeDir.SE) {
                const w = pointerX - leftPos;
                const h = pointerY - topPos;
                const size = calcSize(w, h, this.aspectRatio);
                width = size.w;
                height = size.h;
            }
            this.element.style.top = topPos + 'px';
            this.element.style.left = leftPos + 'px';
            this.element.style.width = width + 'px';
            this.element.style.height = height + 'px';
        }
    }
    endResize(e) {
        if (e.moved && this.annotationId) {
            this.onResized(this.annotationId, {
                x: this.element.offsetLeft,
                y: this.element.offsetTop,
                w: this.element.offsetWidth,
                h: this.element.offsetHeight,
            });
        }
        this.element.classList.remove('pwv-annotation-resizing');
    }
    startMove(e) {
        const elementRect = this.element.getBoundingClientRect();
        const offsetParent = this.element.offsetParent;
        const offsetParentRect = offsetParent.getBoundingClientRect();
        this.dragOffsetX = e.clientX - elementRect.left;
        this.dragOffsetY = e.clientY - elementRect.top;
        this.containerOffsetX = offsetParentRect.left;
        this.containerOffsetY = offsetParentRect.top;
        this.element.classList.add('pwv-annotation-moving');
    }
    moving(e) {
        if (this.pageRect) {
            const minLeft = this.pageRect.x / devicePixelRatio;
            const maxLeft = minLeft + this.pageRect.w / devicePixelRatio - this.element.offsetWidth;
            const minTop = this.pageRect.y / devicePixelRatio;
            const maxTop = minTop + this.pageRect.h / devicePixelRatio - this.element.offsetHeight;
            let topPos = e.clientY - this.containerOffsetY - this.dragOffsetY;
            let leftPos = e.clientX - this.containerOffsetX - this.dragOffsetX;
            if (topPos < minTop) {
                topPos = minTop;
            }
            else if (topPos > maxTop) {
                topPos = maxTop;
            }
            if (leftPos < minLeft) {
                leftPos = minLeft;
            }
            else if (leftPos > maxLeft) {
                leftPos = maxLeft;
            }
            this.element.style.top = topPos + 'px';
            this.element.style.left = leftPos + 'px';
        }
    }
    endMove(e) {
        if (e.moved && this.annotationId) {
            this.onMoved(this.annotationId, {
                x: this.element.offsetLeft,
                y: this.element.offsetTop + this.element.offsetHeight,
            });
        }
        this.element.classList.remove('pwv-annotation-moving');
    }
}


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/views/AnnotationContextBar.tsx":
/*!**************************************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/views/AnnotationContextBar.tsx ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAnnotationContextBar": () => (/* binding */ createAnnotationContextBar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_Contextbar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../common/Contextbar */ "./src/common/Contextbar.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _state_annotations__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../state/annotations */ "./src/pdf-viewer-canvas/state/annotations.ts");









const createAnnotationContextBar = (props, element) => {
    const state = {
        annotation: null,
        isReadOnly: false,
        hasPopup: false,
        canRotate: false,
        deletable: false,
        canCopy: false,
        isLocked: false,
        canHavePopup: false,
        canDeletePopup: true,
        showConfirmDelete: false,
        commands: [],
    };
    const actions = {
        setAnnotation: (payload) => ($state) => {
            const { annotation, commands } = payload;
            const { behaviors } = annotation;
            const isReadOnly = annotation.isReadOnly();
            return Object.assign(Object.assign({}, $state), { showConfirmDelete: false, commands, annotation: annotation, isReadOnly, hasPopup: (0,_state_annotations__WEBPACK_IMPORTED_MODULE_8__.annotationHasPopup)(annotation), canRotate: behaviors.rotatable, deletable: behaviors.deletable, canCopy: behaviors.text && props.allowCopyText, isLocked: annotation.isLocked(), canHavePopup: behaviors.canHavePopup, canDeletePopup: (0,_state_annotations__WEBPACK_IMPORTED_MODULE_8__.annotationHasPopup)(annotation) && annotation.itemType !== _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.TEXT });
        },
        startDelete: () => ($state) => {
            return Object.assign(Object.assign({}, $state), { showConfirmDelete: true });
        },
        cancelDelete: () => ($state) => {
            return Object.assign(Object.assign({}, $state), { showConfirmDelete: false });
        },
        delete: () => ($state) => {
            props.onDeleteAnnotation($state.annotation ? $state.annotation.id : 0);
            return Object.assign({}, $state);
        },
        rotate: () => ($state) => {
            props.onRotateAnnotation($state.annotation ? $state.annotation.id : 0);
            return Object.assign({}, $state);
        },
        copyText: () => ($state) => {
            props.onCopy($state.annotation ? $state.annotation.id : 0);
            return Object.assign({}, $state);
        },
        addPopup: () => ($state) => {
            props.onCreatePopup($state.annotation ? $state.annotation.id : 0);
            return Object.assign(Object.assign({}, $state), { hasPopup: true });
        },
        editPopup: () => ($state) => {
            props.onOpenPopup($state.annotation ? $state.annotation.id : 0);
            return Object.assign({}, $state);
        },
        deletePopup: () => ($state) => {
            props.onDeletePopup($state.annotation ? $state.annotation.id : 0);
            return Object.assign(Object.assign({}, $state), { hasPopup: false });
        },
        toggleLock: () => ($state) => {
            props.onToggleLock($state.annotation ? $state.annotation.id : 0);
            return Object.assign(Object.assign({}, $state), { isLocked: !$state.isLocked });
        },
    };
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(ContextBar, null);
    const ContextBar = ({}) => ($state, $actions) => {
        if ($state.isReadOnly) {
            if ($state.canCopy || ($state.canHavePopup && $state.hasPopup)) {
                return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Contextbar__WEBPACK_IMPORTED_MODULE_6__.Contextbar, null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_3__.Toolbar, null,
                        $state.canCopy && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.copyText'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.copy, onClick: $actions.copyText })),
                        $state.canHavePopup && $state.hasPopup && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.openPopup'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.stickyNote, onClick: $actions.editPopup })))));
            }
            return null;
        }
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Contextbar__WEBPACK_IMPORTED_MODULE_6__.Contextbar, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_3__.Toolbar, null, $state.showConfirmDelete ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { onClick: $actions.delete }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.confirmDelete')),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { onClick: $actions.cancelDelete }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.cancelDelete')))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
                !$state.isReadOnly &&
                    $state.commands.map((cmd) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { icon: cmd.icon, tooltip: cmd.tooltip, onClick: () => {
                            cmd.onCmd($state.annotation ? $state.annotation.id : 0);
                        }, disabled: ($state.isLocked && !props.allowEditLockedAnnotations) || $state.isReadOnly }))),
                $state.canCopy && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.copyText'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.copy, onClick: $actions.copyText })),
                $state.canRotate && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.rotate'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.rotate, onClick: $actions.rotate, disabled: ($state.isLocked && !props.allowEditLockedAnnotations) || $state.isReadOnly })),
                $state.canHavePopup &&
                    !$state.isReadOnly &&
                    !($state.isLocked && !props.allowEditLockedAnnotations) &&
                    !$state.hasPopup && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.addPopup'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.stickyNoteAdd, onClick: $actions.addPopup, disabled: ($state.isLocked && !props.allowEditLockedAnnotations) || $state.isReadOnly })),
                $state.canHavePopup && $state.hasPopup && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText(($state.isLocked && !props.allowEditLockedAnnotations) || $state.isReadOnly
                        ? 'contextbar.openPopup'
                        : 'contextbar.editPopup'), icon: ($state.isLocked && !props.allowEditLockedAnnotations) || $state.isReadOnly
                        ? _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.stickyNote
                        : _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.stickyNoteEdit, onClick: $actions.editPopup })),
                $state.canDeletePopup && $state.hasPopup && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.deletePopup'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.stickyNoteRemove, onClick: $actions.deletePopup, disabled: ($state.isLocked && !props.allowEditLockedAnnotations) || $state.isReadOnly })),
                !$state.isReadOnly && props.allowLockAnnotations && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText($state.isLocked ? 'contextbar.unlock' : 'contextbar.lock'), icon: $state.isLocked ? _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.lock : _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons.unlock, onClick: $actions.toggleLock, disabled: $state.isReadOnly })),
                $state.deletable && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.delete'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_7__.icons["delete"], onClick: $actions.startDelete, disabled: ($state.isLocked && !props.allowEditLockedAnnotations) || $state.isReadOnly })))))));
    };
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/pdf-viewer-canvas/view-layers/views/TextSelectionContextBar.tsx":
/*!*****************************************************************************!*\
  !*** ./src/pdf-viewer-canvas/view-layers/views/TextSelectionContextBar.tsx ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTextSelectionContextBar": () => (/* binding */ createTextSelectionContextBar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../common/ColorPicker */ "./src/common/ColorPicker.tsx");
/* harmony import */ var _common_Contextbar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../common/Contextbar */ "./src/common/Contextbar.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../common/icons */ "./src/common/icons.ts");









const createTextSelectionContextBar = (props, element) => {
    const state = {
        highlightColors: props.highlightColors,
    };
    const actions = {};
    const App = () => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(ContextBar, null);
    const ContextBar = ({}) => ($state) => {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Contextbar__WEBPACK_IMPORTED_MODULE_7__.Contextbar, null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_3__.Toolbar, null, props.isViewOnly ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.copyText'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.copy, onClick: props.onCopyText }))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, null,
                props.allowCopyText && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.copyText'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.copy, onClick: props.onCopyText })),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.highlightText'), colors: $state.highlightColors, icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.highlighter, color: "#000000ff", onChange: (color) => {
                        props.onCreateAnnotation(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.HIGHLIGHT, color);
                    } }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.underlineText'), colors: $state.highlightColors, icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.underline, color: "#000000ff", onChange: (color) => {
                        props.onCreateAnnotation(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.UNDERLINE, color);
                    } }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.squigglyText'), colors: $state.highlightColors, icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.squiggly, color: "#000000ff", onChange: (color) => {
                        props.onCreateAnnotation(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.SQUIGGLY, color);
                    } }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ColorPicker__WEBPACK_IMPORTED_MODULE_6__.ColorPicker, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('contextbar.strikeOutText'), colors: $state.highlightColors, icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.strikethrough, color: "#000000ff", onChange: (color) => {
                        props.onCreateAnnotation(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfItemType.STRIKE_OUT, color);
                    } }))))));
    };
    return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.app)(state, actions, App, element);
};


/***/ }),

/***/ "./src/pdf-web-viewer/PdfWebViewer.ts":
/*!********************************************!*\
  !*** ./src/pdf-web-viewer/PdfWebViewer.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PdfWebViewer": () => (/* binding */ PdfWebViewer)
/* harmony export */ });
/* harmony import */ var _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pdf-tools/four-heights-pdf-viewing */ "../../node_modules/@pdf-tools/four-heights-pdf-viewing/es6/PdfViewing.js");
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _views_App__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./views/App */ "./src/pdf-web-viewer/views/App.tsx");
/* harmony import */ var _pdf_viewer_api_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pdf-viewer-api/types */ "./src/pdf-viewer-api/types.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _pdf_viewer_canvas_PdfViewerCanvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pdf-viewer-canvas/PdfViewerCanvas */ "./src/pdf-viewer-canvas/PdfViewerCanvas.ts");
/* harmony import */ var _state_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./state/index */ "./src/pdf-web-viewer/state/index.ts");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./state/layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_TooltipManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/TooltipManager */ "./src/common/TooltipManager.ts");
/* harmony import */ var _WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./WebViewerOptions */ "./src/pdf-web-viewer/WebViewerOptions.ts");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../common/utils */ "./src/common/utils.ts");












class PdfWebViewer {
    constructor(containerElement, license, options) {
        this.visiblePageRange = {
            firstPage: 0,
            lastPage: 0,
        };
        this.eventListeners = new Map();
        this.loadThumbnailsQueue = [];
        this.loadPageThumbnailsTimer = null;
        if (!containerElement) {
            throw { error: 'PdfWebViewer container element is null' };
        }
        this.licenseKey = license;
        this.element = containerElement;
        this.options = new _WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.WebViewerOptions(options);
        if (options) {
            this.verifyOptions(options, this.options);
        }
        this.handleKeyboardShortcuts = this.handleKeyboardShortcuts.bind(this);
        this.createView = this.createView.bind(this);
        this.loadPageThumbnails = this.loadPageThumbnails.bind(this);
        this.loadDocumentOutlines = this.loadDocumentOutlines.bind(this);
        this.handleAppLoaded = this.handleAppLoaded.bind(this);
        this.handleResize = this.handleResize.bind(this);
        this.getScreenSize = this.getScreenSize.bind(this);
        this.handleDocumentOpened = this.handleDocumentOpened.bind(this);
        this.handleDocumentClosed = this.handleDocumentClosed.bind(this);
        this.handleFirstVisiblePageChanged = this.handleFirstVisiblePageChanged.bind(this);
        this.handleLastVisiblePageChanged = this.handleLastVisiblePageChanged.bind(this);
        this.handlePageNumberChanged = this.handlePageNumberChanged.bind(this);
        this.handleZoomChanged = this.handleZoomChanged.bind(this);
        this.handleRotationChanged = this.handleRotationChanged.bind(this);
        this.handleFitModeChanged = this.handleFitModeChanged.bind(this);
        this.handlePageLayoutModeChanged = this.handlePageLayoutModeChanged.bind(this);
        this.handleBusyStateChanged = this.handleBusyStateChanged.bind(this);
        this.handlePageChanged = this.handlePageChanged.bind(this);
        this.handleTextSelected = this.handleTextSelected.bind(this);
        this.handleError = this.handleError.bind(this);
        this.addPagesToThumbnailsQueue = this.addPagesToThumbnailsQueue.bind(this);
        this.handleAnnotationCreated = this.handleAnnotationCreated.bind(this);
        this.handleAnnotationUpdated = this.handleAnnotationUpdated.bind(this);
        this.handleAnnotationDeleted = this.handleAnnotationDeleted.bind(this);
        this.handleAnnotationSelected = this.handleAnnotationSelected.bind(this);
        this.handleAnnotationDeselected = this.handleAnnotationDeselected.bind(this);
        this.showUnconfirmedChangesDialog = this.showUnconfirmedChangesDialog.bind(this);
        document.addEventListener('keydown', this.handleKeyboardShortcuts, false);
        const resizeObserver = new ResizeObserver(this.handleResize);
        resizeObserver.observe(this.element);
        _common_TooltipManager__WEBPACK_IMPORTED_MODULE_9__.tooltipManager.setType(this.options.viewer.general.tooltips || 'title');
        const initialState = (0,_state_index__WEBPACK_IMPORTED_MODULE_6__.createState)(this.options);
        initialState.layout.deviceType = /iPhone|iPad|iPod|Android|mobile/i.test(navigator.userAgent)
            ? _state_layout__WEBPACK_IMPORTED_MODULE_7__.DeviceType.Mobile
            : _state_layout__WEBPACK_IMPORTED_MODULE_7__.DeviceType.Desktop;
        initialState.layout.screenSize = this.getScreenSize();
        this.view = this.createView(_lib_hyperapp__WEBPACK_IMPORTED_MODULE_1__.app)(initialState, _state_index__WEBPACK_IMPORTED_MODULE_6__.actions, _views_App__WEBPACK_IMPORTED_MODULE_2__.App, this.element);
    }
    open(pdfFile, fdfFiles, password, viewOptions, renderOptions) {
        var _a;
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.api.open({
            pdfFile,
            fdfFiles,
            password,
            viewOptions,
            renderOptions,
        });
    }
    openFile(file, password, pdfAuthorization) {
        let inputFile = undefined;
        if (typeof file === 'string') {
            inputFile = { uri: file };
            if (pdfAuthorization) {
                inputFile.httpOptions = {
                    headers: {
                        Authorization: pdfAuthorization,
                    },
                };
            }
        }
        else {
            inputFile = { data: file };
        }
        this.open(inputFile, null, password);
    }
    openFDF(pdfFile, fdfFile, password, pdfAuthorization, fdfAuthorization) {
        let pdfInputFile = undefined;
        if (typeof pdfFile === 'string') {
            pdfInputFile = { uri: pdfFile };
            if (pdfAuthorization) {
                pdfInputFile.httpOptions = {
                    headers: {
                        Authorization: pdfAuthorization,
                    },
                };
            }
        }
        else {
            pdfInputFile = { data: pdfFile };
        }
        const fdfInputFile = typeof fdfFile === 'string'
            ? { uri: fdfFile }
            : { data: fdfFile };
        this.open(pdfInputFile, [fdfInputFile], password);
    }
    save(saveOptions) {
        return this.viewerCanvas ? this.viewerCanvas.save(saveOptions) : null;
    }
    saveFile(asFdf) {
        return new Promise((resolve, reject) => {
            var _a;
            const fileType = asFdf ? _pdf_viewer_api_types__WEBPACK_IMPORTED_MODULE_3__.FileType.Fdf : _pdf_viewer_api_types__WEBPACK_IMPORTED_MODULE_3__.FileType.Pdf;
            (_a = this.save({ fileType })) === null || _a === void 0 ? void 0 : _a.then((blob) => {
                resolve(blob.arrayBuffer());
            });
        });
    }
    downloadFile(saveOptions) {
        if (this.view) {
            return this.view.api.downloadFile(saveOptions);
        }
    }
    close() {
        if (this.view) {
            return this.view.api.close();
        }
    }
    destroy() {
        var _a;
        document.removeEventListener('keydown', this.handleKeyboardShortcuts, false);
        this.eventListeners.clear();
        if (this.viewerCanvas) {
            this.viewerCanvas.removeEventListener('appLoaded', this.handleAppLoaded);
            this.viewerCanvas.removeEventListener('firstVisiblePage', this.handleFirstVisiblePageChanged);
            this.viewerCanvas.removeEventListener('lastVisiblePage', this.handleLastVisiblePageChanged);
            this.viewerCanvas.removeEventListener('pageNumber', this.handlePageNumberChanged);
            this.viewerCanvas.removeEventListener('zoom', this.handleZoomChanged);
            this.viewerCanvas.removeEventListener('fitMode', this.handleFitModeChanged);
            this.viewerCanvas.removeEventListener('pageLayoutMode', this.handlePageLayoutModeChanged);
            this.viewerCanvas.removeEventListener('busyState', this.handleBusyStateChanged);
            this.viewerCanvas.removeEventListener('rotation', this.handleRotationChanged);
            this.viewerCanvas.removeEventListener('pageChanged', this.handlePageChanged);
            this.viewerCanvas.removeEventListener('error', this.handleError);
            this.viewerCanvas.removeEventListener('itemCreated', this.handleAnnotationCreated);
            this.viewerCanvas.removeEventListener('itemUpdated', this.handleAnnotationUpdated);
            this.viewerCanvas.removeEventListener('itemDeleted', this.handleAnnotationDeleted);
            this.viewerCanvas.removeEventListener('itemSelected', this.handleAnnotationSelected);
            this.viewerCanvas.removeEventListener('itemDeselected', this.handleAnnotationDeselected);
        }
        (_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.destroy();
        this.viewerCanvas = undefined;
        this.view = undefined;
        this.loadThumbnailsQueue = [];
        if (this.loadPageThumbnailsTimer) {
            clearTimeout(this.loadPageThumbnailsTimer);
        }
        while (this.element.firstChild) {
            this.element.removeChild(this.element.firstChild);
        }
    }
    getPageCount() {
        return this.viewerCanvas ? this.viewerCanvas.getPageCount() : null;
    }
    getPageNumber() {
        if (this.viewerCanvas) {
            return this.viewerCanvas.getPageNumber();
        }
        return null;
    }
    setPageNumber(pageNumber) {
        if (this.viewerCanvas) {
            this.viewerCanvas.setPageNumber(pageNumber);
        }
    }
    rotatePage(pageNumber, direction) {
        if (this.viewerCanvas) {
            this.viewerCanvas.rotatePage(pageNumber, direction);
        }
    }
    nextPage() {
        if (this.viewerCanvas) {
            this.viewerCanvas.nextPage();
        }
    }
    previousPage() {
        if (this.viewerCanvas) {
            this.viewerCanvas.previousPage();
        }
    }
    getZoom() {
        if (this.viewerCanvas) {
            return this.viewerCanvas.getZoom();
        }
        return null;
    }
    setZoom(zoom) {
        if (this.viewerCanvas) {
            this.viewerCanvas.setZoom(zoom);
        }
    }
    zoomIn() {
        var _a;
        (_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.zoomIn();
    }
    zoomOut() {
        var _a;
        (_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.zoomOut();
    }
    getFitMode() {
        if (this.viewerCanvas) {
            return this.viewerCanvas.getFitMode();
        }
        return null;
    }
    setFitMode(fitMode) {
        if (this.viewerCanvas) {
            this.viewerCanvas.setFitMode(fitMode);
        }
    }
    getPageLayoutMode() {
        if (this.viewerCanvas) {
            return this.viewerCanvas.getPageLayoutMode();
        }
        return null;
    }
    setPageLayoutMode(pageLayoutMode) {
        if (this.viewerCanvas) {
            this.viewerCanvas.setPageLayoutMode(pageLayoutMode);
        }
    }
    getRotation() {
        if (this.viewerCanvas) {
            return this.viewerCanvas.getRotation();
        }
        return null;
    }
    setRotation(rotation) {
        if (this.viewerCanvas) {
            this.viewerCanvas.setRotation(rotation);
        }
    }
    getProductVersion() {
        return _pdf_tools_four_heights_pdf_viewing__WEBPACK_IMPORTED_MODULE_0__.PdfViewing.Sdk.version;
    }
    hasChanges() {
        if (this.view) {
            return this.view.api.hasChanges();
        }
        return null;
    }
    showInformationPane(selectedPane) {
        if (this.view) {
            if (selectedPane) {
                this.view.navigationPanel.selectNavigation(selectedPane);
            }
            else {
                this.view.navigationPanel.showNavigationPanel();
            }
        }
    }
    hideInformationPane() {
        if (this.view) {
            this.view.navigationPanel.hideNavigationPanel();
        }
    }
    toggleInformationPane() {
        if (this.view) {
            this.view.navigationPanel.toggleNavigationPanel();
        }
    }
    startSearch(searchString, searchOptions) {
        if (this.view && this.viewerCanvas) {
            const { startPage, isCaseSensitive, isWrappingEnabled, isRegex, hideToolbar } = searchOptions || {};
            const caseSensitive = Boolean(isCaseSensitive);
            const wrappingEnabled = Boolean(isWrappingEnabled);
            const regex = Boolean(isRegex);
            if (!hideToolbar) {
                this.view.search.openSearch();
                this.view.search.updateToSearch(searchString);
                this.view.search.setCaseSensitive(caseSensitive);
                this.view.search.setWrappingSearch(wrappingEnabled);
                this.view.search.setRegex(regex);
            }
            this.viewerCanvas.startSearch(searchString, startPage || 1, caseSensitive, wrappingEnabled, regex);
        }
    }
    nextSearchMatch() {
        if (this.viewerCanvas) {
            this.viewerCanvas.nextSearchMatch();
        }
    }
    previousSearchMatch() {
        if (this.viewerCanvas) {
            this.viewerCanvas.previousSearchMatch();
        }
    }
    endSearch() {
        if (this.view) {
            this.view.api.endSearch();
            this.view.search.closeSearch();
        }
    }
    print() {
        var _a;
        (_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.print();
    }
    getSelectedText() {
        var _a, _b;
        return (_b = (_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.getSelectedText()) !== null && _b !== void 0 ? _b : '';
    }
    addEventListener(type, listener) {
        if (this.eventListeners.has(type)) {
            ;
            this.eventListeners.get(type).push(listener);
        }
        else {
            this.eventListeners.set(type, [listener]);
        }
    }
    removeEventListener(type, listener) {
        if (this.eventListeners.has(type)) {
            let listeners = this.eventListeners.get(type);
            listeners = listeners.filter((listenerInArray) => listenerInArray !== listener);
            if (listeners.length !== 0) {
                this.eventListeners.set(type, listeners);
            }
            else {
                this.eventListeners.delete(type);
            }
        }
    }
    dispatchEvent(type, args) {
        if (this.eventListeners.has(type)) {
            const listeners = this.eventListeners.get(type);
            listeners.forEach((listener) => listener(args));
        }
    }
    createView(nextApp) {
        return (state, a, view, element) => {
            a.initialize = () => {
                const loadTranslationPromise = _common_TranslationManager__WEBPACK_IMPORTED_MODULE_8__.translationManager.loadTranslations(this.options.viewer.general.language || 'en');
                Promise.all([window.PdfToolsPromise, loadTranslationPromise])
                    .then(() => {
                    var _a;
                    (_a = this.view) === null || _a === void 0 ? void 0 : _a.loadScriptsCompleted();
                })
                    .catch((err) => {
                    this.handleError(err);
                });
            };
            a.createCanvasView = (elm) => {
                try {
                    this.viewerCanvas = new _pdf_viewer_canvas_PdfViewerCanvas__WEBPACK_IMPORTED_MODULE_5__.PdfViewerCanvas(elm, this.licenseKey, this.options);
                }
                catch (err) {
                    this.handleError(err);
                    return;
                }
                this.viewerCanvas.addEventListener('appLoaded', this.handleAppLoaded);
                this.viewerCanvas.addEventListener('firstVisiblePage', this.handleFirstVisiblePageChanged);
                this.viewerCanvas.addEventListener('lastVisiblePage', this.handleLastVisiblePageChanged);
                this.viewerCanvas.addEventListener('pageNumber', this.handlePageNumberChanged);
                this.viewerCanvas.addEventListener('zoom', this.handleZoomChanged);
                this.viewerCanvas.addEventListener('fitMode', this.handleFitModeChanged);
                this.viewerCanvas.addEventListener('rotation', this.handleRotationChanged);
                this.viewerCanvas.addEventListener('pageLayoutMode', this.handlePageLayoutModeChanged);
                this.viewerCanvas.addEventListener('busyState', this.handleBusyStateChanged);
                this.viewerCanvas.addEventListener('pageChanged', this.handlePageChanged);
                this.viewerCanvas.addEventListener('textSelected', this.handleTextSelected);
                this.viewerCanvas.addEventListener('error', this.handleError);
                this.viewerCanvas.addEventListener('itemCreated', this.handleAnnotationCreated);
                this.viewerCanvas.addEventListener('itemUpdated', this.handleAnnotationUpdated);
                this.viewerCanvas.addEventListener('itemDeleted', this.handleAnnotationDeleted);
                this.viewerCanvas.addEventListener('itemSelected', this.handleAnnotationSelected);
                this.viewerCanvas.addEventListener('itemDeselected', this.handleAnnotationDeselected);
                const params = new URLSearchParams(location.search);
                if (params) {
                    const pdfUrl = params.get('url');
                    if (pdfUrl) {
                        this.open({ uri: pdfUrl, sourceTag: '' });
                    }
                }
            };
            a.removeCanvasView = (elm) => {
                if (this.viewerCanvas) {
                    this.viewerCanvas.removeEventListener('firstVisiblePage', this.handleFirstVisiblePageChanged);
                    this.viewerCanvas.removeEventListener('lastVisiblePage', this.handleLastVisiblePageChanged);
                    this.viewerCanvas.removeEventListener(`pageNumber`, this.handlePageNumberChanged);
                    this.viewerCanvas.removeEventListener('zoom', this.handleZoomChanged);
                    this.viewerCanvas.removeEventListener('fitMode', this.handleFitModeChanged);
                    this.viewerCanvas.removeEventListener('pageLayoutMode', this.handlePageLayoutModeChanged);
                    this.viewerCanvas.removeEventListener('busyState', this.handleBusyStateChanged);
                    this.viewerCanvas.removeEventListener('error', this.handleError);
                    this.viewerCanvas = undefined;
                }
            };
            a.api = {
                open: (args) => {
                    if (this.view) {
                        this.view.loadDocumentBegin();
                        if (this.viewerCanvas) {
                            if (!this.beforeOpen(args)) {
                                return;
                            }
                            if (this.viewerCanvas) {
                                this.viewerCanvas
                                    .open(args.pdfFile, args.fdfFiles, args.password, args.viewOptions, args.renderOptions)
                                    .then(() => {
                                    this.openResolve(args);
                                })
                                    .catch((error) => {
                                    this.openReject(args, error);
                                });
                            }
                        }
                    }
                },
                close: () => {
                    if (this.view && this.viewerCanvas) {
                        if (this.showUnconfirmedChangesDialog()) {
                            this.view.showConfirmUnsavedChangesDialog(null, this.handleDocumentClosed);
                            return;
                        }
                        this.handleDocumentClosed();
                    }
                },
                downloadFile: (saveOptions) => {
                    return new Promise((resolve, reject) => {
                        if (this.view && this.viewerCanvas) {
                            this.view.saveDocumentBegin();
                            const viewState = this.view.getState();
                            const filename = viewState.pdfDocument.filename;
                            const mimetype = viewState.pdfDocument.mimetype;
                            this.viewerCanvas
                                .save(saveOptions)
                                .then((data) => {
                                const newBlob = new Blob([data], { type: mimetype });
                                const dataUrl = window.URL.createObjectURL(newBlob);
                                const link = document.createElement('a');
                                link.style.position = 'absolute';
                                link.style.left = '-1000px';
                                link.href = dataUrl;
                                link.download = filename || 'download.pdf';
                                this.element.appendChild(link);
                                link.click();
                                setTimeout(() => {
                                    var _a;
                                    this.element.removeChild(link);
                                    window.URL.revokeObjectURL(dataUrl);
                                    (_a = this.view) === null || _a === void 0 ? void 0 : _a.saveDocumentFulfilled();
                                }, 100);
                                resolve();
                            })
                                .catch((error) => {
                                var _a;
                                console.error(error);
                                (_a = this.view) === null || _a === void 0 ? void 0 : _a.saveDocumentRejected(error);
                            });
                        }
                    });
                },
                hasChanges: () => {
                    if (this.viewerCanvas) {
                        return this.viewerCanvas.hasChanges();
                    }
                    return null;
                },
                setZoom: (zoom) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.setZoom(zoom / 100);
                    }
                },
                getZoom: () => {
                    if (this.viewerCanvas) {
                        return this.viewerCanvas.getZoom();
                    }
                    return null;
                },
                zoomIn: () => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.zoomIn();
                    }
                },
                zoomOut: () => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.zoomOut();
                    }
                },
                setPageNumber: (page) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.setPageNumber(page);
                    }
                },
                getPageNumber: () => {
                    if (this.viewerCanvas) {
                        return this.viewerCanvas.getPageNumber();
                    }
                    return null;
                },
                getPageCount: () => {
                    if (this.viewerCanvas) {
                        return this.viewerCanvas.getPageCount();
                    }
                    return null;
                },
                nextPage: () => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.nextPage();
                    }
                },
                previousPage: () => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.previousPage();
                    }
                },
                setFitMode: (fitMode) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.setFitMode(fitMode);
                    }
                },
                getFitMode: () => {
                    if (this.viewerCanvas) {
                        return this.viewerCanvas.getFitMode();
                    }
                    return null;
                },
                setPageLayoutMode: (layoutMode) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.setPageLayoutMode(layoutMode);
                    }
                },
                getPageLayoutMode: () => {
                    if (this.viewerCanvas) {
                        return this.viewerCanvas.getPageLayoutMode();
                    }
                    return null;
                },
                rotatePage: (pageRotation) => {
                    if (this.viewerCanvas) {
                        return this.viewerCanvas.rotatePage(pageRotation.page, pageRotation.direction);
                    }
                },
                rotate: () => {
                    if (this.viewerCanvas) {
                        const r = this.viewerCanvas.getRotation();
                        const rotation = r >= 270 ? 0 : r + 90;
                        this.viewerCanvas.setRotation(rotation);
                    }
                },
                setRotation: (rotation) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.setRotation(rotation);
                    }
                },
                getRotation: () => {
                    if (this.viewerCanvas) {
                        return this.viewerCanvas.getRotation();
                    }
                    return null;
                },
                startSearch: () => {
                    if (this.view && this.viewerCanvas) {
                        const s = this.view.getState().search;
                        this.viewerCanvas.startSearch(s.searchString, 1, s.caseSensitive, s.wrapSearch, s.useRegex);
                    }
                },
                nextSearchMatch: () => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.nextSearchMatch();
                    }
                },
                previousSearchMatch: () => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.previousSearchMatch();
                    }
                },
                endSearch: () => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.endSearch();
                    }
                },
                updateCanvasSearchState: (state) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.updateCanvasSearchState(state);
                    }
                },
                goTo: (pdfDestination) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.goTo(pdfDestination);
                    }
                },
                goToAnnotation: (target) => {
                    if (this.viewerCanvas) {
                        if (target.annotation.isHidden()) {
                            this.handleAnnotationSelected(target.annotation);
                        }
                        else {
                            try {
                                this.viewerCanvas.goToAnnotation(target.annotation, target.action);
                            }
                            catch (err) {
                                console.error(err);
                            }
                        }
                    }
                },
                resetViewerMode: (pdfDestination) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.resetViewerMode();
                    }
                },
                loadNavigationItems: () => {
                    if (this.view) {
                        this.loadPageThumbnails();
                        this.loadAnnotations();
                        const viewState = this.view.getState();
                        if (!viewState.navigationPanel.outlineItemsLoaded) {
                            this.loadDocumentOutlines();
                        }
                    }
                },
                addPageRangeToThumbnailsQueue: (pageRange) => {
                    this.addPagesToThumbnailsQueue(pageRange.from, pageRange.to);
                },
                print: () => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.print();
                    }
                },
                activateModule: (moduleName, args) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.activateModule(moduleName, args);
                    }
                },
                deactivateModule: (moduleName) => {
                    if (this.viewerCanvas) {
                        this.viewerCanvas.deactivateModule(moduleName);
                    }
                },
            };
            a.initialize();
            return nextApp(state, a, view, element);
        };
    }
    getScreenSize() {
        var _a;
        const widthToScreenSize = (width) => {
            if (width <= _state_layout__WEBPACK_IMPORTED_MODULE_7__.ScreenSize.Small) {
                return _state_layout__WEBPACK_IMPORTED_MODULE_7__.ScreenSize.Small;
            }
            if (width <= _state_layout__WEBPACK_IMPORTED_MODULE_7__.ScreenSize.Medium) {
                return _state_layout__WEBPACK_IMPORTED_MODULE_7__.ScreenSize.Medium;
            }
            return _state_layout__WEBPACK_IMPORTED_MODULE_7__.ScreenSize.Large;
        };
        const viewerElm = this.element.firstChild;
        if (!this.view || !viewerElm) {
            return widthToScreenSize(this.element.getBoundingClientRect().width);
        }
        if (viewerElm.offsetWidth && viewerElm.offsetHeight && viewerElm.getClientRects().length) {
            return widthToScreenSize(viewerElm.getBoundingClientRect().width);
        }
        return (_a = this.view) === null || _a === void 0 ? void 0 : _a.getState().layout.screenSize;
    }
    handleResize() {
        if (this.view) {
            const screenSize = this.getScreenSize();
            if (this.view.getState().layout.screenSize !== screenSize) {
                this.view.layout.setScreenSize(screenSize);
            }
        }
    }
    handleKeyboardShortcuts(e) {
        var _a, _b, _c;
        const rect = this.element.getBoundingClientRect();
        if (rect.width + rect.height === 0) {
            return;
        }
        const { shortcuts } = this.options;
        if (Object.keys(shortcuts).length > 0) {
            const keyboardCommands = (0,_common_utils__WEBPACK_IMPORTED_MODULE_11__.getKeyboardCommands)(e, shortcuts);
            if (!keyboardCommands.length) {
                return;
            }
            keyboardCommands.forEach((cmd) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
                switch (cmd) {
                    case 'save': {
                        const { allowSaveFile } = this.options.viewer.permissions;
                        if (allowSaveFile) {
                            e.preventDefault();
                            if (this.options.viewer.callbacks.onSaveFileButtonClicked) {
                                this.options.viewer.onSaveFileButtonClicked();
                            }
                            else {
                                this.downloadFile();
                            }
                        }
                        break;
                    }
                    case 'print': {
                        const { allowPrinting } = this.options.viewer.permissions;
                        if (allowPrinting) {
                            e.preventDefault();
                            (_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.print();
                        }
                        break;
                    }
                    case 'cancelPrint': {
                        const { allowPrinting } = this.options.viewer.permissions;
                        if (allowPrinting) {
                            (_b = this.viewerCanvas) === null || _b === void 0 ? void 0 : _b.deactivateModule('PrintServiceModule');
                        }
                        break;
                    }
                    case 'search': {
                        const { enableSearch } = this.options.viewer.permissions;
                        if (enableSearch) {
                            e.preventDefault();
                            (_c = this.view) === null || _c === void 0 ? void 0 : _c.search.openSearch();
                        }
                        break;
                    }
                    case 'searchNext': {
                        const { enableSearch } = this.options.viewer.permissions;
                        if (enableSearch) {
                            const state = (_d = this.view) === null || _d === void 0 ? void 0 : _d.getState();
                            if (state && state.search && state.search.showSearch && state.search.searchString) {
                                (_e = this.viewerCanvas) === null || _e === void 0 ? void 0 : _e.nextSearchMatch();
                            }
                            e.preventDefault();
                        }
                        break;
                    }
                    case 'searchPrevious': {
                        const { enableSearch } = this.options.viewer.permissions;
                        if (enableSearch) {
                            const state = (_f = this.view) === null || _f === void 0 ? void 0 : _f.getState();
                            if (state && state.search && state.search.showSearch && state.search.searchString) {
                                (_g = this.viewerCanvas) === null || _g === void 0 ? void 0 : _g.previousSearchMatch();
                            }
                            e.preventDefault();
                        }
                        break;
                    }
                    case 'closeSearch': {
                        const { enableSearch } = this.options.viewer.permissions;
                        if (enableSearch) {
                            e.preventDefault();
                            (_h = this.viewerCanvas) === null || _h === void 0 ? void 0 : _h.endSearch();
                            (_j = this.view) === null || _j === void 0 ? void 0 : _j.search.closeSearch();
                        }
                        break;
                    }
                    case 'toggleSidePane': {
                        const { sidebar } = this.options.viewer;
                        if (sidebar.annotationNavigation ||
                            sidebar.outlineNavigation ||
                            sidebar.annotationNavigation) {
                            e.preventDefault();
                            (_k = this.view) === null || _k === void 0 ? void 0 : _k.navigationPanel.toggleNavigationPanel();
                        }
                        break;
                    }
                    case 'showAnnotations': {
                        const { sidebar } = this.options.viewer;
                        if (sidebar.annotationNavigation) {
                            e.preventDefault();
                            (_l = this.view) === null || _l === void 0 ? void 0 : _l.navigationPanel.selectNavigation('annotation');
                        }
                        break;
                    }
                    case 'showOutline': {
                        const { sidebar } = this.options.viewer;
                        if (sidebar.outlineNavigation) {
                            e.preventDefault();
                            (_m = this.view) === null || _m === void 0 ? void 0 : _m.navigationPanel.selectNavigation('outline');
                        }
                        break;
                    }
                    case 'showThumbnails': {
                        const { sidebar } = this.options.viewer;
                        if (sidebar.thumbnailNavigation) {
                            e.preventDefault();
                            (_o = this.view) === null || _o === void 0 ? void 0 : _o.navigationPanel.selectNavigation('thumbnail');
                        }
                        break;
                    }
                }
            });
        }
        else if (e.key === 'Escape') {
            (_a = this.viewerCanvas) === null || _a === void 0 ? void 0 : _a.deactivateModule('PrintServiceModule');
            (_b = this.viewerCanvas) === null || _b === void 0 ? void 0 : _b.endSearch();
            (_c = this.view) === null || _c === void 0 ? void 0 : _c.search.closeSearch();
        }
    }
    showUnconfirmedChangesDialog() {
        if (this.view && this.viewerCanvas) {
            const currentState = this.view.getState();
            const hasChanges = this.viewerCanvas.hasChanges();
            return (!currentState.unsavedChangesDialogDontSave &&
                currentState.hasDocument &&
                hasChanges &&
                this.options.viewer.general.promptOnUnsavedChange &&
                this.options.viewer.permissions.allowSaveFile);
        }
    }
    beforeOpen(args) {
        if (this.view && this.viewerCanvas) {
            if (this.showUnconfirmedChangesDialog()) {
                this.view.showConfirmUnsavedChangesDialog(args);
                return false;
            }
            this.view.navigationPanel.clear();
            this.view.loadDocumentBegin();
            return true;
        }
    }
    openResolve(fileOpenArgs) {
        if (this.view && this.viewerCanvas) {
            this.view.pdfDocument.setFileInfo(fileOpenArgs.pdfFile);
            this.view.pdfDocument.setHasChanges(false);
            const pageCount = this.viewerCanvas.getPageCount();
            this.view.pdfDocument.setPageCount(pageCount);
            this.handleDocumentOpened();
            this.view.loadDocumentFulfilled();
            this.view.api.loadNavigationItems();
            const inputFile = fileOpenArgs.pdfFile;
            const eventArg = inputFile.uri
                ? inputFile.uri
                : new File([], inputFile.sourceTag, { type: 'application/pdf' });
            this.dispatchEvent('documentLoaded', eventArg);
        }
    }
    openReject(fileOpenArgs, error) {
        if (this.view) {
            if (error.message === 'password required') {
                this.view.loadDocumentPasswordForm(fileOpenArgs);
            }
            else {
                this.view.loadDocumentRejected(error.message);
            }
        }
    }
    handleDocumentOpened() {
        if (this.view && this.viewerCanvas) {
            const pageCount = this.viewerCanvas.getPageCount();
            this.view.navigationPanel.setThumbnailPlaceholders(pageCount);
            const viewerState = this.view.getState();
            this.view.navigationPanel.clearAnnotations();
            if (viewerState.navigationPanel.showNavigation) {
                if (viewerState.navigationPanel.selectedNavigation === 'thumbnail') {
                    this.loadPageThumbnails();
                }
                else if (viewerState.navigationPanel.selectedNavigation === 'outline') {
                    this.loadDocumentOutlines();
                }
                else {
                    this.loadAnnotations();
                }
            }
        }
    }
    loadDocumentOutlines() {
        if (this.viewerCanvas) {
            this.viewerCanvas.getDocumentOutline().then((outlines) => {
                if (this.view) {
                    this.view.navigationPanel.setOutlines(outlines);
                }
            });
        }
    }
    loadPageThumbnails() {
        if (this.view && this.viewerCanvas) {
            const state = this.view.getState();
            const fromPage = state.pdfDocument.firstVisiblePage - 5;
            const toPage = state.pdfDocument.lastVisiblePage + 5;
            this.addPagesToThumbnailsQueue(fromPage, toPage);
        }
    }
    addPagesToThumbnailsQueue(fromPage, toPage) {
        if (this.view && this.viewerCanvas) {
            const state = this.view.getState();
            if (fromPage < 1) {
                fromPage = 1;
            }
            if (toPage < fromPage) {
                toPage = state.pdfDocument.firstVisiblePage + 5;
            }
            if (toPage > state.pdfDocument.pageCount) {
                toPage = state.pdfDocument.pageCount;
            }
            const pagesToLoad = state.navigationPanel.pages
                .filter((p) => p.pageNumber >= fromPage &&
                p.pageNumber <= toPage &&
                p.thumbnail === null &&
                p.loading === null)
                .map((p) => p.pageNumber);
            pagesToLoad.forEach((p) => {
                var _a;
                if (this.loadThumbnailsQueue.indexOf(p) < 0) {
                    (_a = this.view) === null || _a === void 0 ? void 0 : _a.navigationPanel.updateThumbnail({
                        pageNumber: p,
                        thumbnail: null,
                        loading: true,
                    });
                    this.loadThumbnailsQueue.push(p);
                }
            });
            const getPageThumbnail = (pageNumber) => {
                this.updatePageThumbnail(pageNumber).then(() => {
                    const nextPage = this.loadThumbnailsQueue.shift();
                    if (nextPage) {
                        getPageThumbnail(nextPage);
                    }
                });
            };
            const firstPage = this.loadThumbnailsQueue.shift();
            if (firstPage) {
                getPageThumbnail(firstPage);
            }
        }
    }
    updatePageThumbnail(pageNumber) {
        return new Promise((resolve, reject) => {
            if (this.view && this.viewerCanvas) {
                this.viewerCanvas
                    .renderPage(pageNumber, 200, 200)
                    .then((thumbnail) => {
                    var _a;
                    const canvasElement = document.createElement('canvas');
                    canvasElement.width = thumbnail.imageData.width;
                    canvasElement.height = thumbnail.imageData.height;
                    const ctx = canvasElement.getContext('2d');
                    ctx && ctx.putImageData(thumbnail.imageData, 0, 0);
                    const imageData = canvasElement.toDataURL('image/png');
                    (_a = this.view) === null || _a === void 0 ? void 0 : _a.navigationPanel.updateThumbnail({
                        pageNumber: thumbnail.page,
                        thumbnail: imageData,
                        loading: false,
                    });
                    resolve();
                })
                    .catch((error) => reject(error));
            }
            else {
                reject();
            }
        });
    }
    loadAnnotations() {
        if (!this.options.viewer.sidebar.annotationNavigation) {
            return;
        }
        if (this.view) {
            const state = this.view.getState();
            if (state.navigationPanel.annotationsLoaded) {
                return;
            }
            this.view.navigationPanel.initAnnotations(state.pdfDocument.pageCount);
            const loadNext = (pages) => {
                if (this.viewerCanvas) {
                    const pageNumber = pages.shift();
                    if (typeof pageNumber === 'number') {
                        this.viewerCanvas
                            .getAnnotationsFromPage(pageNumber)
                            .then((itemsOnPage) => {
                            var _a, _b;
                            const selectableItems = itemsOnPage.items.filter((item) => { var _a; return (_a = item.behaviors) === null || _a === void 0 ? void 0 : _a.selectable; });
                            if (selectableItems.length) {
                                (_a = this.view) === null || _a === void 0 ? void 0 : _a.navigationPanel.setPageAnnotations({
                                    page: itemsOnPage.page,
                                    itemCategory: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_4__.PdfItemCategory.ANNOTATION,
                                    items: selectableItems,
                                });
                            }
                            if (pages.length > 0) {
                                loadNext(pages);
                            }
                            else {
                                (_b = this.view) === null || _b === void 0 ? void 0 : _b.navigationPanel.setAnnotationLoaded();
                            }
                        });
                    }
                }
            };
            const pageCount = this.getPageCount() || 0;
            const pageNumbers = [];
            for (let i = 1; i <= pageCount; i++) {
                pageNumbers.push(i);
            }
            loadNext(pageNumbers);
        }
    }
    handleDocumentClosed() {
        var _a, _b;
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.closeDocument();
        (_b = this.viewerCanvas) === null || _b === void 0 ? void 0 : _b.close();
        this.handleResize();
        this.dispatchEvent('documentClosed', undefined);
        return;
    }
    handleAppLoaded(loaded) {
        if (this.view && this.viewerCanvas) {
            this.view.initializeAppFulfilled({ licenseFeatures: this.viewerCanvas.licenseFeatures });
            const canvasModules = this.viewerCanvas.getModules();
            this.view.setCanvasModules(canvasModules);
            this.dispatchEvent('appLoaded', loaded);
        }
    }
    handleFirstVisiblePageChanged(page) {
        if (this.view) {
            this.visiblePageRange.firstPage = page;
            this.updateVisiblePageRange();
            this.view.pdfDocument.setFirstVisiblePage(page);
        }
    }
    handleLastVisiblePageChanged(page) {
        if (this.view) {
            this.visiblePageRange.lastPage = page;
            this.updateVisiblePageRange();
            this.view.pdfDocument.setLastVisiblePage(page);
        }
    }
    handlePageNumberChanged(page) {
        if (this.view) {
            this.view.pdfDocument.setPageNumber(page);
            const { navigationPanel } = this.view.getState();
            if (navigationPanel.showNavigation && navigationPanel.selectedNavigation === 'thumbnail') {
                const elm = this.element.querySelector(`#pwv-thumbnail-navigation-page_${page}`);
                const container = this.element.querySelector('.pwv-NavigationPanel__Content');
                if (elm && container) {
                    const containerBoundingRect = container.getBoundingClientRect();
                    const pageBoundingRect = elm.getBoundingClientRect();
                    if (pageBoundingRect.top < containerBoundingRect.top ||
                        pageBoundingRect.bottom > containerBoundingRect.bottom) {
                        elm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }
            this.dispatchEvent('pageNumberChanged', page);
        }
    }
    updateVisiblePageRange() {
        if (this.view) {
            const state = this.view.getState();
            if (state.navigationPanel.showNavigation &&
                state.navigationPanel.selectedNavigation === 'thumbnail') {
                if (this.loadPageThumbnailsTimer) {
                    window.clearTimeout(this.loadPageThumbnailsTimer);
                }
                this.loadPageThumbnailsTimer = window.setTimeout(() => {
                    this.loadPageThumbnailsTimer = null;
                    this.loadPageThumbnails();
                }, 100);
            }
        }
    }
    handleZoomChanged(zoom) {
        if (this.view) {
            this.view.pdfDocument.setZoom(zoom * 100);
            this.dispatchEvent('zoomChanged', zoom);
        }
    }
    handleFitModeChanged(fitMode) {
        if (this.view) {
            this.view.pdfDocument.setFitMode(fitMode);
        }
        this.dispatchEvent('fitModeChanged', fitMode);
    }
    handlePageLayoutModeChanged(layoutMode) {
        if (this.view) {
            this.view.pdfDocument.setPageLayoutMode(layoutMode);
        }
        this.dispatchEvent('pageLayoutModeChanged', layoutMode);
    }
    handleRotationChanged(rotation) {
        this.dispatchEvent('rotationChanged', rotation);
    }
    handleBusyStateChanged(state) {
        this.dispatchEvent('busyState', state);
    }
    handleAnnotationSelected(item) {
        if (this.view) {
            const annotation = item;
            this.view.navigationPanel.selectAnnotation(annotation);
            const { navigationPanel } = this.view.getState();
            if (navigationPanel.showNavigation && navigationPanel.selectedNavigation === 'annotation') {
                const elm = this.element.querySelector(`#pwv-annotation-navigation-item-${annotation.id}`);
                if (elm) {
                    elm.scrollIntoView({ behavior: 'smooth' });
                }
            }
        }
    }
    handleAnnotationDeselected(item) {
        if (this.view) {
            this.view.navigationPanel.deselectAnnotation();
        }
    }
    handleAnnotationCreated(item) {
        if (this.view) {
            const annotation = item;
            this.view.navigationPanel.updateAnnotation(annotation);
            const { navigationPanel } = this.view.getState();
            if (navigationPanel.showNavigation && navigationPanel.selectedNavigation === 'annotation') {
                window.setTimeout(() => {
                    const elm = this.element.querySelector(`#pwv-annotation-navigation-item-${annotation.id}`);
                    if (elm) {
                        elm.scrollIntoView({ behavior: 'smooth' });
                    }
                }, 10);
            }
        }
    }
    handleAnnotationUpdated(item) {
        if (this.view) {
            const annotation = item;
            this.view.navigationPanel.updateAnnotation(annotation);
        }
    }
    handleAnnotationDeleted(deletedItem) {
        if (this.view) {
            this.view.navigationPanel.deleteAnnotation(deletedItem);
        }
    }
    handlePageChanged(pageNumber) {
        if (this.view) {
            const pageNavigationItem = this.view.getState().navigationPanel.pages[pageNumber - 1];
            if (pageNavigationItem && pageNavigationItem.thumbnail !== null) {
                this.updatePageThumbnail(pageNumber);
            }
            this.dispatchEvent('documentChanged', undefined);
        }
    }
    handleTextSelected(text) {
        this.dispatchEvent('textSelected', text);
    }
    verifyOptions(clientOptions, defaultOptions) {
        if (clientOptions.annotation && clientOptions.annotation.colors) {
            Object.keys(_WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.OptionsToVerify).forEach((k) => {
                if (clientOptions.annotation && clientOptions.annotation.colors[k]) {
                    if (!this.isContainedInArray(clientOptions.annotation.colors[k], defaultOptions.annotation.colors[_WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.OptionsToVerify[k]])) {
                        throw new Error(`Invalid ${k}: ${defaultOptions.annotation.colors[k]} has not been found in ${_WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.OptionsToVerify[k]}.\n` +
                            `Valid values are: ${defaultOptions.annotation.colors[_WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.OptionsToVerify[k]]}`);
                    }
                }
            });
            Object.keys(_WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.ColorPaletteMap).forEach((k) => {
                if (clientOptions.annotation &&
                    clientOptions.annotation.colors[k] &&
                    !clientOptions.annotation.colors[_WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.ColorPaletteMap[k]]) {
                    throw new Error(`Cannot set ${k} without setting ${_WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.ColorPaletteMap[k]}. Preset ${_WebViewerOptions__WEBPACK_IMPORTED_MODULE_10__.ColorPaletteMap[k]} might not be in ${k}`);
                }
            });
        }
    }
    isContainedInArray(item, list) {
        if (!list.find((el) => el === item)) {
            return false;
        }
        return true;
    }
    handleError(error) {
        if (this.view) {
            this.view.setError(error.message);
        }
        this.dispatchEvent('error', error);
    }
}


/***/ }),

/***/ "./src/pdf-web-viewer/UserSettings.ts":
/*!********************************************!*\
  !*** ./src/pdf-web-viewer/UserSettings.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UserSettings": () => (/* binding */ UserSettings)
/* harmony export */ });
class UserSettings {
    constructor() {
        this.localStorageAccessible = false;
        let settingsStr = null;
        try {
            settingsStr = localStorage.getItem('PDFToolsAG.ViewerSettings');
            this.localStorageAccessible = true;
        }
        catch (err) {
            console.warn('local storage not accessible');
        }
        try {
            this.toolSettings = settingsStr ? JSON.parse(settingsStr) : {};
        }
        catch (_a) {
            this.toolSettings = {};
        }
        this.save = this.save.bind(this);
        this.getItem = this.getItem.bind(this);
        this.setItem = this.setItem.bind(this);
    }
    save() {
        if (this.localStorageAccessible) {
            const settings = JSON.stringify(this.toolSettings);
            localStorage.setItem('PDFToolsAG.ViewerSettings', settings);
        }
    }
    getItem(key, defaultValue) {
        if (this.localStorageAccessible && this.toolSettings.hasOwnProperty(key)) {
            return this.toolSettings[key];
        }
        return defaultValue;
    }
    setItem(key, value) {
        if (this.localStorageAccessible) {
            this.toolSettings[key] = value;
            this.save();
        }
    }
}


/***/ }),

/***/ "./src/pdf-web-viewer/WebViewerOptions.ts":
/*!************************************************!*\
  !*** ./src/pdf-web-viewer/WebViewerOptions.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationColorOptions": () => (/* binding */ AnnotationColorOptions),
/* harmony export */   "AnnotationFontOptions": () => (/* binding */ AnnotationFontOptions),
/* harmony export */   "AnnotationOptions": () => (/* binding */ AnnotationOptions),
/* harmony export */   "ColorPaletteMap": () => (/* binding */ ColorPaletteMap),
/* harmony export */   "FormsOptions": () => (/* binding */ FormsOptions),
/* harmony export */   "GeneralOptions": () => (/* binding */ GeneralOptions),
/* harmony export */   "OptionsToVerify": () => (/* binding */ OptionsToVerify),
/* harmony export */   "SidebarOptions": () => (/* binding */ SidebarOptions),
/* harmony export */   "ViewerOptions": () => (/* binding */ ViewerOptions),
/* harmony export */   "WebViewerOptions": () => (/* binding */ WebViewerOptions),
/* harmony export */   "defaultAnnotationColorOptions": () => (/* binding */ defaultAnnotationColorOptions),
/* harmony export */   "defaultAnnotationFontOptions": () => (/* binding */ defaultAnnotationFontOptions),
/* harmony export */   "defaultAnnotationOptions": () => (/* binding */ defaultAnnotationOptions),
/* harmony export */   "defaultAnnotationStamps": () => (/* binding */ defaultAnnotationStamps),
/* harmony export */   "defaultFormsOptions": () => (/* binding */ defaultFormsOptions),
/* harmony export */   "defaultGeneralOptions": () => (/* binding */ defaultGeneralOptions),
/* harmony export */   "defaultKeyboardShortcuts": () => (/* binding */ defaultKeyboardShortcuts),
/* harmony export */   "defaultPermissions": () => (/* binding */ defaultPermissions),
/* harmony export */   "defaultSidebarOptions": () => (/* binding */ defaultSidebarOptions),
/* harmony export */   "defaultViewerModules": () => (/* binding */ defaultViewerModules),
/* harmony export */   "defaultViewerOptions": () => (/* binding */ defaultViewerOptions),
/* harmony export */   "defaultWebViewerOptions": () => (/* binding */ defaultWebViewerOptions)
/* harmony export */ });
/* harmony import */ var _UserSettings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UserSettings */ "./src/pdf-web-viewer/UserSettings.ts");
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules */ "./src/modules/index.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");



const defaultAnnotationColorOptions = {
    highlightColors: ['#2ADB1A', '#FFEA02', '#FF7F1F', '#FF2882', '#008AD1'],
    foregroundColors: ['#323232', '#FFFFFF', '#FFEA02', '#2ADB1A', '#0066CC', '#D82F32'],
    backgroundColors: ['#FFFFFF', '#FCF5E2', '#323232', '#FFEA02', '#D82F32', '#0066CC'],
    defaultHighlightColor: '#FFEA02',
    defaultBackgroundColor: '#FCF5E2',
    defaultForegroundColor: '#323232',
};
const defaultAnnotationFontOptions = {
    fontFamilies: ['Helvetica', 'Times', 'Courier', 'Symbol', 'ZapfDingbats'],
    fontSizes: [9, 10, 12, 14, 16, 18, 20, 24],
    defaultFontFamily: 'Helvetica',
    defaultFontSize: 12,
};
const defaultAnnotationStamps = [
    { translation_key: 'stamptext.approved', color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.GREEN },
    { translation_key: 'stamptext.notApproved', color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.RED },
    { translation_key: 'stamptext.draft', color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.BLUE },
    { translation_key: 'stamptext.final', color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.GREEN },
    { translation_key: 'stamptext.completed', color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.GREEN },
    {
        translation_key: 'stamptext.confidential',
        color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.BLUE,
    },
    { translation_key: 'stamptext.forPublic', color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.BLUE },
    {
        translation_key: 'stamptext.notForPublic',
        color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.BLUE,
    },
    { translation_key: 'stamptext.void', color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.RED },
    { translation_key: 'stamptext.forComment', color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.BLUE },
    {
        translation_key: 'stamptext.preliminaryResults',
        color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.BLUE,
    },
    {
        translation_key: 'stamptext.informationOnly',
        color: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.StampAnnotationColor.BLUE,
    },
];
const defaultAnnotationOptions = {
    colors: defaultAnnotationColorOptions,
    stamps: defaultAnnotationStamps,
    fonts: defaultAnnotationFontOptions,
    highlightOpacity: 0.5,
    strokeWidths: [0, 1, 2, 3, 5, 8, 13, 21],
    defaultStampWidth: 120,
    defaultBorderWidth: 1,
    eraserRadius: 5,
    hideAnnotationSubject: false,
    trackHistory: false,
    onlyAuthorCanEdit: false,
    hideOnDelete: false,
    selectedStamp: 0,
};
const defaultGeneralOptions = {
    user: '',
    language: 'en',
    annotationBarPosition: 'left',
    promptOnUnsavedChange: true,
    searchMatchColor: '#3ABCFF',
    textSelectionColor: '#006395',
    rectangularTextSelection: 'none',
    pageShadow: {
        shadowBlur: 4,
        shadowColor: 'rgba(90,90,90,0.2)',
        shadowOffsetX: 0,
        shadowOffsetY: 0,
    },
    pageLayoutModes: [
        _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfPageLayoutMode.ONE_COLUMN,
        _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfPageLayoutMode.SINGLE_PAGE,
        _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfPageLayoutMode.TWO_COLUMN_LEFT,
        _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfPageLayoutMode.TWO_COLUMN_RIGHT,
        _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfPageLayoutMode.TWO_PAGE_LEFT,
        _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_2__.PdfPageLayoutMode.TWO_PAGE_RIGHT,
    ],
    defaultZoomLevels: [
        0.1, 0.15, 0.2, 0.25, 0.35, 0.4, 0.5, 0.65, 0.8, 1, 1.25, 1.5, 2.0, 2.5, 3.0, 4.0,
    ],
    tooltips: 'title',
    viewOnly: false,
    disableMainToolbar: false,
    disableAnnotationToolbar: false,
};
const defaultKeyboardShortcuts = {
    zoomIn: { key: '+' },
    zoomOut: { key: '-' },
    nextPage: { key: 'PageDown' },
    previousPage: { key: 'PageUp' },
    firstPage: { key: 'Home' },
    lastPage: { key: 'End' },
    scrollUp: { key: 'ArrowUp' },
    scrollDown: { key: 'ArrowDown' },
    scrollLeft: { key: 'ArrowLeft' },
    scrollRight: { key: 'ArrowRight' },
    releaseSelection: { key: 'Escape' },
    copy: {
        key: 'c',
        ctrlKey: true,
    },
    print: {
        key: 'p',
        ctrlKey: true,
    },
    cancelPrint: {
        key: 'Escape',
    },
    resetZoom: {
        key: 'z',
        altKey: true,
    },
    fitToPage: {
        key: 'p',
        altKey: true,
    },
    fitToWidth: {
        key: 'w',
        altKey: true,
    },
    rotateView: {
        key: 'r',
        altKey: true,
    },
    save: {
        key: 's',
        ctrlKey: true,
    },
    search: {
        key: 'f',
        ctrlKey: true,
    },
    searchNext: { key: 'F3' },
    searchPrevious: {
        key: 'F3',
        shiftKey: true,
    },
    closeSearch: { key: 'Escape' },
    toggleSidePane: {
        key: 's',
        altKey: true,
    },
    showAnnotations: {
        key: 'a',
        altKey: true,
    },
    showOutline: {
        key: 'o',
        altKey: true,
    },
    showThumbnails: {
        key: 't',
        altKey: true,
    },
    cancelEditAnnotation: { key: 'Escape' },
};
const defaultSidebarOptions = {
    annotationNavigation: true,
    thumbnailNavigation: true,
    outlineNavigation: true,
};
const defaultFormsOptions = {
    enabled: true,
};
const defaultPermissions = {
    allowOpenFile: true,
    allowCloseFile: false,
    allowFileDrop: true,
    allowPrinting: false,
    allowSaveFile: true,
    allowCopyText: true,
    allowRotateView: true,
    allowLockAnnotations: true,
    allowEditLockedAnnotations: false,
    allowRotatePages: true,
    enablePageLayoutMode: true,
    enableSearch: true,
};
const defaultViewerOptions = {
    general: defaultGeneralOptions,
    sidebar: defaultSidebarOptions,
    permissions: defaultPermissions,
    callbacks: {},
    customButtons: {
        annotationbar: [],
        documentbar: [],
        informationbar: [],
    },
};
const defaultViewerModules = [
    _modules__WEBPACK_IMPORTED_MODULE_1__.PopupModule,
    _modules__WEBPACK_IMPORTED_MODULE_1__.TextAnnotationModule,
    _modules__WEBPACK_IMPORTED_MODULE_1__.InkAnnotationModule,
    _modules__WEBPACK_IMPORTED_MODULE_1__.EraserModule,
    _modules__WEBPACK_IMPORTED_MODULE_1__.FreetextAnnotationModule,
    _modules__WEBPACK_IMPORTED_MODULE_1__.HighlightAnnotationModule,
    _modules__WEBPACK_IMPORTED_MODULE_1__.StampAnnotationModule,
    _modules__WEBPACK_IMPORTED_MODULE_1__.ShapeAnnotationModule,
    _modules__WEBPACK_IMPORTED_MODULE_1__.ImageAnnotationModule,
];
const defaultWebViewerOptions = {
    viewer: defaultViewerOptions,
    modules: defaultViewerModules,
    annotation: defaultAnnotationOptions,
    forms: defaultFormsOptions,
    shortcuts: defaultKeyboardShortcuts,
};
const OptionsToVerify = {
    defaultHighlightAnnotationColor: 'highlightColors',
    defaultFreetextBgColor: 'backgroundColors',
    defaultFreetextFontColor: 'foregroundColors',
    defaultFreetextFontFamily: 'fontFamilies',
    defaultFreetextFontSize: 'fontSizes',
    defaultInkColor: 'foregroundColors',
    defaultStickyNoteColor: 'highlightColors',
    defaultBackgroundColor: 'backgroundColors',
    defaultForegroundColor: 'foregroundColors',
    defaultHighlightColor: 'highlightColors',
    defaultFontSize: 'fontSizes',
};
const ColorPaletteMap = {
    highlightColors: 'defaultHighlightColor',
    backgroundColors: 'defaultBackgroundColor',
    foregroundColors: 'defaultForegroundColor',
};
class StorageClass {
    constructor() {
        this.internalStorage = new _UserSettings__WEBPACK_IMPORTED_MODULE_0__.UserSettings();
    }
    get storage() {
        return this.internalStorage;
    }
}
class GeneralOptions extends StorageClass {
    constructor(_options) {
        super();
        this.options = Object.assign(Object.assign({}, defaultGeneralOptions), _options);
    }
    get user() {
        return this.options.user;
    }
    get language() {
        return this.options.language;
    }
    get annotationBarPosition() {
        return this.options.annotationBarPosition;
    }
    set annotationBarPosition(position) {
        this.storage.setItem('annotationBarPosition', position);
    }
    get promptOnUnsavedChange() {
        return this.options.promptOnUnsavedChange;
    }
    get textSelectionColor() {
        return this.options.textSelectionColor;
    }
    get rectangularTextSelection() {
        return this.options.rectangularTextSelection;
    }
    get searchMatchColor() {
        return this.options.searchMatchColor;
    }
    get pageLayoutModes() {
        return this.options.pageLayoutModes;
    }
    get defaultZoomLevels() {
        return this.options.defaultZoomLevels;
    }
    get pageShadow() {
        return this.options.pageShadow;
    }
    get currentPageShadow() {
        return this.options.currentPageShadow;
    }
    get viewOnly() {
        return this.options.viewOnly;
    }
    get tooltips() {
        return this.options.tooltips;
    }
    get disableMainToolbar() {
        return this.options.disableMainToolbar;
    }
    get disableAnnotationToolbar() {
        return this.options.disableAnnotationToolbar;
    }
}
class SidebarOptions {
    constructor(_options) {
        this.options = Object.assign(Object.assign({}, defaultSidebarOptions), _options);
    }
    get thumbnailNavigation() {
        return this.options.thumbnailNavigation;
    }
    get outlineNavigation() {
        return this.options.outlineNavigation;
    }
    get annotationNavigation() {
        return this.options.annotationNavigation;
    }
}
class FormsOptions {
    constructor(_options) {
        this.options = Object.assign(Object.assign({}, defaultFormsOptions), _options);
    }
    get enabled() {
        return this.options.enabled;
    }
}
class ViewerOptions {
    constructor(_options) {
        var _a, _b, _c, _d, _e, _f;
        this.options = {
            general: Object.assign(Object.assign({}, defaultViewerOptions.general), _options === null || _options === void 0 ? void 0 : _options.general),
            sidebar: Object.assign(Object.assign({}, defaultViewerOptions.sidebar), _options === null || _options === void 0 ? void 0 : _options.sidebar),
            permissions: Object.assign(Object.assign({}, defaultViewerOptions.permissions), _options === null || _options === void 0 ? void 0 : _options.permissions),
            callbacks: Object.assign(Object.assign({}, defaultViewerOptions.callbacks), _options === null || _options === void 0 ? void 0 : _options.callbacks),
            customButtons: {
                annotationbar: ((_a = _options === null || _options === void 0 ? void 0 : _options.customButtons) === null || _a === void 0 ? void 0 : _a.annotationbar)
                    ? (_b = _options === null || _options === void 0 ? void 0 : _options.customButtons) === null || _b === void 0 ? void 0 : _b.annotationbar
                    : [],
                documentbar: ((_c = _options === null || _options === void 0 ? void 0 : _options.customButtons) === null || _c === void 0 ? void 0 : _c.documentbar)
                    ? (_d = _options === null || _options === void 0 ? void 0 : _options.customButtons) === null || _d === void 0 ? void 0 : _d.documentbar
                    : [],
                informationbar: ((_e = _options === null || _options === void 0 ? void 0 : _options.customButtons) === null || _e === void 0 ? void 0 : _e.informationbar)
                    ? (_f = _options === null || _options === void 0 ? void 0 : _options.customButtons) === null || _f === void 0 ? void 0 : _f.informationbar
                    : [],
            },
        };
        this.generalOptions = new GeneralOptions(_options === null || _options === void 0 ? void 0 : _options.general);
    }
    get general() {
        return this.generalOptions;
    }
    get sidebar() {
        return this.options.sidebar;
    }
    get permissions() {
        return this.options.permissions;
    }
    get callbacks() {
        return this.options.callbacks;
    }
    get customButtons() {
        return this.options.customButtons;
    }
}
class AnnotationColorOptions extends StorageClass {
    constructor(_options) {
        super();
        this.options = Object.assign(Object.assign({}, defaultAnnotationColorOptions), _options);
    }
    get highlightColors() {
        return this.options.highlightColors;
    }
    get foregroundColors() {
        return this.options.foregroundColors;
    }
    get backgroundColors() {
        return this.options.backgroundColors;
    }
    get defaultHighlightColor() {
        return this.options.defaultHighlightColor;
    }
    get defaultForegroundColor() {
        return this.options.defaultForegroundColor;
    }
    get defaultBackgroundColor() {
        return this.options.defaultBackgroundColor;
    }
    get highlightAnnotationColor() {
        return this.storage.getItem('highlightAnnotationColor', this.defaultHighlightColor);
    }
    set highlightAnnotationColor(color) {
        this.storage.setItem('highlightAnnotationColor', color);
    }
    get stickyNoteColor() {
        return this.storage.getItem('stickyNoteColor', this.options.defaultHighlightColor);
    }
    set stickyNoteColor(color) {
        this.storage.setItem('stickyNoteColor', color);
    }
    get freetextBackgroundColor() {
        return this.storage.getItem('freetextBackgroundColor', this.defaultBackgroundColor);
    }
    set freetextBackgroundColor(color) {
        this.storage.setItem('freetextBackgroundColor', color);
    }
    set freetextFontColor(color) {
        this.storage.setItem('freetextFontColor', color);
    }
    get freetextFontColor() {
        return this.storage.getItem('freetextFontColor', this.options.defaultForegroundColor);
    }
    get inkColor() {
        return this.storage.getItem('inkColor', this.options.defaultForegroundColor);
    }
    set inkColor(color) {
        this.storage.setItem('inkColor', color);
    }
    get inkOpacity() {
        return this.storage.getItem('inkOpacity', 100);
    }
    set inkOpacity(opacity) {
        this.storage.setItem('inkOpacity', opacity);
    }
    set shapeColor(color) {
        this.storage.setItem('shapeAnnotationColor', color);
    }
    get shapeColor() {
        return this.storage.getItem('shapeAnnotationColor', this.options.defaultForegroundColor);
    }
    set shapeFillColor(color) {
        this.storage.setItem('shapeFillColor', color);
    }
    get shapeFillColor() {
        return this.storage.getItem('shapeFillColor', this.defaultHighlightColor);
    }
}
class AnnotationFontOptions extends StorageClass {
    constructor(_options) {
        super();
        this.options = Object.assign(Object.assign({}, defaultAnnotationFontOptions), _options);
    }
    get fontFamilies() {
        return this.options.fontFamilies;
    }
    get fontSizes() {
        return this.options.fontSizes;
    }
    get defaultFontFamily() {
        return this.options.defaultFontFamily;
    }
    get defaultFontSize() {
        return this.options.defaultFontSize;
    }
    get freetextFontSize() {
        return this.storage.getItem('freetextFontSize', this.defaultFontSize);
    }
    get freetextFontFamily() {
        return this.storage.getItem('freetextFontFamily', this.defaultFontFamily);
    }
}
class AnnotationOptions extends StorageClass {
    constructor(_options) {
        super();
        this.options = Object.assign(Object.assign({}, defaultAnnotationOptions), _options);
        this.colorOptions = new AnnotationColorOptions(_options === null || _options === void 0 ? void 0 : _options.colors);
        this.fontOptions = new AnnotationFontOptions(_options === null || _options === void 0 ? void 0 : _options.fonts);
    }
    get stamps() {
        return this.options.stamps;
    }
    get colors() {
        return this.colorOptions;
    }
    get fonts() {
        return this.fontOptions;
    }
    get highlightOpacity() {
        return this.options.highlightOpacity;
    }
    get strokeWidths() {
        return this.options.strokeWidths;
    }
    set shapeStrokeWidth(width) {
        this.storage.setItem('shapeStrokeWidth', width);
    }
    get shapeStrokeWidth() {
        return this.storage.getItem('shapeStrokeWidth', this.options.defaultBorderWidth);
    }
    set shapeStrokeStyle(style) {
        this.storage.setItem('shapeStrokeStyle', style);
    }
    get shapeStrokeStyle() {
        return this.storage.getItem('shapeStrokeStyle', 0);
    }
    set inkWidth(width) {
        this.storage.setItem('inkWidth', width);
    }
    get inkWidth() {
        return this.storage.getItem('inkWidth', this.options.defaultBorderWidth);
    }
    set freetextBorderWidth(width) {
        this.storage.setItem('freetextBorderWidth', width);
    }
    get freetextBorderWidth() {
        return this.storage.getItem('freetextBorderWidth', this.options.defaultBorderWidth);
    }
    get defaultBorderWidth() {
        return this.options.defaultBorderWidth;
    }
    get defaultStampWidth() {
        return this.options.defaultStampWidth;
    }
    get hideOnDelete() {
        return this.options.hideOnDelete;
    }
    get trackHistory() {
        return this.options.trackHistory;
    }
    get hideAnnotationSubject() {
        return this.options.hideAnnotationSubject;
    }
    get onlyAuthorCanEdit() {
        return this.options.onlyAuthorCanEdit;
    }
    get annotationPermissionCallback() {
        return this.options.annotationPermissionCallback;
    }
    get selectedStamp() {
        return this.storage.getItem('selectedStamp', 0);
    }
    set selectedStamp(stampNumber) {
        this.storage.setItem('selectedStamp', stampNumber);
    }
    set eraserRadius(width) {
        this.storage.setItem('eraserRadius', width);
    }
    get eraserRadius() {
        return this.storage.getItem('eraserRadius', 5);
    }
}
class WebViewerOptions {
    constructor(_options) {
        var _a, _b, _c;
        const mergedOptions = Object.assign(Object.assign({}, defaultWebViewerOptions), _options);
        if (!mergedOptions.modules.find((m) => m === _modules__WEBPACK_IMPORTED_MODULE_1__.PrintServiceModule)) {
            (_a = mergedOptions.modules) === null || _a === void 0 ? void 0 : _a.push(_modules__WEBPACK_IMPORTED_MODULE_1__.PrintServiceModule);
        }
        if (((_b = mergedOptions.forms) === null || _b === void 0 ? void 0 : _b.enabled) && !mergedOptions.modules.find((m) => m === _modules__WEBPACK_IMPORTED_MODULE_1__.FormFieldModule)) {
            (_c = mergedOptions.modules) === null || _c === void 0 ? void 0 : _c.push(_modules__WEBPACK_IMPORTED_MODULE_1__.FormFieldModule);
        }
        if ((_options === null || _options === void 0 ? void 0 : _options.shortcuts) === null) {
            ;
            mergedOptions.shortcuts = {};
        }
        else {
            mergedOptions.shortcuts = Object.assign(Object.assign({}, defaultWebViewerOptions.shortcuts), _options === null || _options === void 0 ? void 0 : _options.shortcuts);
        }
        this.options = mergedOptions;
        this.viewerOptions = new ViewerOptions(mergedOptions ? mergedOptions.viewer : mergedOptions);
        this.annotationOptions = new AnnotationOptions(mergedOptions ? mergedOptions.annotation : mergedOptions);
        this.formsOptions = new FormsOptions(mergedOptions ? mergedOptions.forms : mergedOptions);
    }
    get viewer() {
        return this.viewerOptions;
    }
    get annotation() {
        return this.annotationOptions;
    }
    get forms() {
        return this.formsOptions;
    }
    get modules() {
        return this.options.modules;
    }
    set modules(modules) {
        this.options.modules = modules;
    }
    get shortcuts() {
        return this.options.shortcuts;
    }
}


/***/ }),

/***/ "./src/pdf-web-viewer/state/index.ts":
/*!*******************************************!*\
  !*** ./src/pdf-web-viewer/state/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "createState": () => (/* binding */ createState)
/* harmony export */ });
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _passwordForm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./passwordForm */ "./src/pdf-web-viewer/state/passwordForm.ts");
/* harmony import */ var _navigationPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./navigationPanel */ "./src/pdf-web-viewer/state/navigationPanel.ts");
/* harmony import */ var _pdfDocument__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pdfDocument */ "./src/pdf-web-viewer/state/pdfDocument.ts");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./search */ "./src/pdf-web-viewer/state/search.ts");
/* harmony import */ var _WebViewerOptions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../WebViewerOptions */ "./src/pdf-web-viewer/WebViewerOptions.ts");






const defaultState = {
    licenseFeatures: {
        annotate: false,
        fillFormFields: false,
        pageRotation: false,
    },
    scriptsLoaded: false,
    appInitialized: false,
    fileDropEnabled: false,
    hasDocument: false,
    showPasswordForm: false,
    passwordDialogTempPdfFile: null,
    passwordDialogTempFdfFile: null,
    showOpenFileErrorDialog: false,
    showUnsavedChangesDialog: false,
    fileOpenArgs: null,
    unsavedChangesDialogDontSave: false,
    showLoadingIndicator: false,
    showSaveIndicator: false,
    hasError: false,
    errorMessage: '',
    layout: _layout__WEBPACK_IMPORTED_MODULE_0__.state,
    passwordForm: _passwordForm__WEBPACK_IMPORTED_MODULE_1__.state,
    navigationPanel: _navigationPanel__WEBPACK_IMPORTED_MODULE_2__.state,
    pdfDocument: _pdfDocument__WEBPACK_IMPORTED_MODULE_3__.state,
    search: _search__WEBPACK_IMPORTED_MODULE_4__.state,
    options: _WebViewerOptions__WEBPACK_IMPORTED_MODULE_5__.defaultWebViewerOptions,
    canvasModules: [],
    closeCallback: undefined,
};
const createState = (options) => {
    const state = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(defaultState))), { options });
    const { sidebar } = options.viewer;
    if (sidebar.selectedNavigation) {
        state.navigationPanel.selectedNavigation = sidebar.selectedNavigation;
        state.navigationPanel.showNavigation = true;
    }
    else if (!sidebar.thumbnailNavigation) {
        state.navigationPanel.selectedNavigation = sidebar.outlineNavigation ? 'outline' : 'annotation';
    }
    return state;
};
const actions = {
    layout: _layout__WEBPACK_IMPORTED_MODULE_0__.actions,
    passwordForm: _passwordForm__WEBPACK_IMPORTED_MODULE_1__.actions,
    navigationPanel: _navigationPanel__WEBPACK_IMPORTED_MODULE_2__.actions,
    pdfDocument: _pdfDocument__WEBPACK_IMPORTED_MODULE_3__.actions,
    search: _search__WEBPACK_IMPORTED_MODULE_4__.actions,
    loadScriptsCompleted: () => ($state) => (Object.assign(Object.assign({}, $state), { scriptsLoaded: true })),
    initializeAppFulfilled: (settings) => ($state) => (Object.assign(Object.assign({}, $state), { licenseFeatures: settings.licenseFeatures, appInitialized: true, fileDropEnabled: true })),
    initializeAppRejected: (error) => ($state) => (Object.assign(Object.assign({}, $state), { hasError: true, errorMessage: error, appInitialized: true })),
    setCanvasModules: (canvasModules) => ($state) => (Object.assign(Object.assign({}, $state), { canvasModules: canvasModules })),
    loadDocumentBegin: () => ($state) => {
        return Object.assign(Object.assign({}, $state), { fileDropEnabled: false, showLoadingIndicator: true, unsavedChangesDialogDontSave: false });
    },
    loadDocumentFulfilled: () => ($state) => {
        return Object.assign(Object.assign({}, $state), { hasDocument: true, fileDropEnabled: true, showPasswordForm: false, passwordDialogTempPdfFile: null, showLoadingIndicator: false });
    },
    loadDocumentCancel: () => ($state) => (Object.assign(Object.assign({}, $state), { fileDropEnabled: true, showPasswordForm: false, passwordDialogTempPdfFile: null, showLoadingIndicator: false })),
    loadDocumentRejected: (error) => ($state) => (Object.assign(Object.assign({}, $state), { fileDropEnabled: false, passwordDialogTempPdfFile: null, showPasswordForm: false, showLoadingIndicator: false, showOpenFileErrorDialog: true })),
    loadDocumentConfirmRejected: () => ($state) => (Object.assign(Object.assign({}, $state), { fileDropEnabled: true, showOpenFileErrorDialog: false })),
    loadDocumentPasswordForm: (fileOpenArgs) => ($state) => {
        $state.passwordForm.invalidPasswordError = $state.passwordDialogTempPdfFile !== null;
        return Object.assign(Object.assign({}, $state), { fileOpenArgs, showPasswordForm: true, showLoadingIndicator: false });
    },
    closeDocument: () => ($state) => (Object.assign(Object.assign({}, JSON.parse(JSON.stringify(defaultState))), { appInitialized: true, scriptsLoaded: true, fileDropEnabled: true, options: $state.options, licenseFeatures: $state.licenseFeatures })),
    showConfirmUnsavedChangesDialog: (fileOpenArgs, closeCallback) => ($state) => {
        return Object.assign(Object.assign({}, $state), { fileOpenArgs,
            closeCallback, showUnsavedChangesDialog: true });
    },
    unsavedChangesDialogCancel: () => ($state) => {
        return Object.assign(Object.assign({}, $state), { showUnsavedChangesDialog: false, showLoadingIndicator: false, hasDocument: true, closeCallback: undefined });
    },
    unsavedChangesDialogFileSaved: () => ($state) => {
        return Object.assign(Object.assign({}, $state), { unsavedChangesDialogTempPdfFile: null, unsavedChangesDialogTempFdfFile: null, showUnsavedChangesDialog: false, closeCallback: undefined });
    },
    unsavedChangesDialogDontSave: () => ($state) => {
        return Object.assign(Object.assign({}, $state), { unsavedChangesDialogDontSave: false, showUnsavedChangesDialog: false, hasDocument: false });
    },
    saveDocumentBegin: (error) => ($state) => (Object.assign(Object.assign({}, $state), { showSaveIndicator: true })),
    saveDocumentFulfilled: (error) => ($state) => (Object.assign(Object.assign({}, $state), { showSaveIndicator: false })),
    saveDocumentRejected: (error) => ($state) => (Object.assign(Object.assign({}, $state), { hasError: true, errorMessage: error, appInitialized: true, showSaveIndicator: false })),
    setError: (error) => ($state) => (Object.assign(Object.assign({}, $state), { hasError: true, errorMessage: error })),
    getState: () => ($state) => {
        return Object.assign({}, $state);
    },
    open: (file) => ($state) => (Object.assign({}, $state)),
};


/***/ }),

/***/ "./src/pdf-web-viewer/state/layout.ts":
/*!********************************************!*\
  !*** ./src/pdf-web-viewer/state/layout.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DeviceType": () => (/* binding */ DeviceType),
/* harmony export */   "ScreenSize": () => (/* binding */ ScreenSize),
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
var DeviceType;
(function (DeviceType) {
    DeviceType[DeviceType["Mobile"] = 0] = "Mobile";
    DeviceType[DeviceType["Desktop"] = 1] = "Desktop";
})(DeviceType || (DeviceType = {}));
var ScreenSize;
(function (ScreenSize) {
    ScreenSize[ScreenSize["Small"] = 600] = "Small";
    ScreenSize[ScreenSize["Medium"] = 900] = "Medium";
    ScreenSize[ScreenSize["Large"] = 1200] = "Large";
})(ScreenSize || (ScreenSize = {}));
const state = {
    screenSize: ScreenSize.Medium,
    deviceType: DeviceType.Desktop,
};
const actions = {
    setScreenSize: (screenSize) => ($state) => (Object.assign(Object.assign({}, $state), { screenSize })),
    setDeviceType: (deviceType) => ($state) => (Object.assign(Object.assign({}, $state), { deviceType })),
};


/***/ }),

/***/ "./src/pdf-web-viewer/state/navigationPanel.ts":
/*!*****************************************************!*\
  !*** ./src/pdf-web-viewer/state/navigationPanel.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
const state = {
    showNavigation: false,
    selectedNavigation: 'thumbnail',
    outlineItemsLoaded: false,
    annotationsLoaded: false,
    pages: [],
    outlines: [],
    annotations: {},
};
const actions = {
    clear: () => ($state) => (Object.assign(Object.assign({}, $state), { outlineItemsLoaded: false, pages: [], outlines: [], annotations: [] })),
    setThumbnailPlaceholders: (pageCount) => ($state) => {
        const pages = [];
        for (let i = 0; i < pageCount; i++) {
            pages.push({
                thumbnail: null,
                loading: null,
                pageNumber: i + 1,
            });
        }
        return Object.assign(Object.assign({}, $state), { pages });
    },
    updateThumbnail: (newThumbnail) => ($state) => (Object.assign(Object.assign({}, $state), { pages: $state.pages.map((p) => (p.pageNumber === newThumbnail.pageNumber ? newThumbnail : p)) })),
    setOutlines: (outlines) => ($state) => (Object.assign(Object.assign({}, $state), { outlineItemsLoaded: true, outlines })),
    toggleNavigationPanel: () => ($state) => (Object.assign(Object.assign({}, $state), { showNavigation: !$state.showNavigation })),
    showNavigationPanel: () => ($state) => (Object.assign(Object.assign({}, $state), { showNavigation: true })),
    hideNavigationPanel: () => ($state) => (Object.assign(Object.assign({}, $state), { showNavigation: false })),
    selectNavigation: (navigation) => ($state) => (Object.assign(Object.assign({}, $state), { showNavigation: true, selectedNavigation: navigation })),
    toggleOutlineItem: (path) => ($state) => {
        const newState = Object.assign({}, $state);
        let currentItem = { descendants: newState.outlines, open: false };
        path.forEach((id) => {
            const nextItem = currentItem.descendants.find((item) => item.id.toString() === id);
            if (nextItem) {
                currentItem = nextItem;
            }
        });
        currentItem.open = !currentItem.open;
        return newState;
    },
    clearAnnotations: () => ($state) => (Object.assign(Object.assign({}, $state), { annotations: {}, selectedAnnotation: undefined, annotationsLoaded: false })),
    setAnnotationLoaded: () => ($state) => (Object.assign(Object.assign({}, $state), { annotationsLoaded: true })),
    initAnnotations: (pageCount) => ($state) => {
        const annotations = {};
        for (let i = 1; i <= pageCount; i++) {
            annotations[i] = {};
        }
        return Object.assign(Object.assign({}, $state), { annotations });
    },
    setPageAnnotations: (itemsOnPage) => ($state) => {
        const itemState = {};
        itemsOnPage.items.forEach((an) => {
            const annotation = an;
            itemState[annotation.id] = annotation;
        });
        return Object.assign(Object.assign({}, $state), { annotations: Object.assign(Object.assign({}, $state.annotations), { [itemsOnPage.page]: itemState }) });
    },
    updateAnnotation: (annotation) => ($state) => {
        const page = annotation.pdfRect.page;
        const id = annotation.id;
        const itemsOnPage = $state.annotations[page] ? Object.assign({}, $state.annotations[page]) : {};
        itemsOnPage[id] = annotation;
        return Object.assign(Object.assign({}, $state), { annotations: Object.assign(Object.assign({}, $state.annotations), { [page]: itemsOnPage }) });
    },
    deleteAnnotation: (deletedItem) => ($state) => {
        const page = deletedItem.page;
        const id = deletedItem.id;
        const itemsOnPage = $state.annotations[page];
        if (!itemsOnPage) {
            return Object.assign({}, $state);
        }
        delete itemsOnPage[id];
        return Object.assign(Object.assign({}, $state), { annotations: Object.assign(Object.assign({}, $state.annotations), { [page]: itemsOnPage }) });
    },
    selectAnnotation: (annotation) => ($state) => {
        return Object.assign(Object.assign({}, $state), { selectedAnnotation: {
                page: annotation.pdfRect.page,
                annotationId: annotation.id,
            } });
    },
    deselectAnnotation: () => ($state) => (Object.assign(Object.assign({}, $state), { selectedAnnotation: undefined })),
};


/***/ }),

/***/ "./src/pdf-web-viewer/state/passwordForm.ts":
/*!**************************************************!*\
  !*** ./src/pdf-web-viewer/state/passwordForm.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
const state = {
    password: '',
    passwordRequiredError: false,
    invalidPasswordError: false,
};
const actions = {
    clear: () => ($state) => ({
        password: '',
        passwordRequiredError: false,
        invalidPasswordError: false,
    }),
    updatePassword: (password) => ($state) => {
        return Object.assign(Object.assign({}, $state), { password });
    },
    validateForm: () => ($state) => {
        return Object.assign(Object.assign({}, $state), { invalidPasswordError: false, passwordRequiredError: $state.password === '' });
    },
    setInvalidPasswordError: () => ($state) => (Object.assign(Object.assign({}, $state), { invalidPasswordError: true })),
};


/***/ }),

/***/ "./src/pdf-web-viewer/state/pdfDocument.ts":
/*!*************************************************!*\
  !*** ./src/pdf-web-viewer/state/pdfDocument.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");

const state = {
    filename: '',
    mimetype: '',
    hasChanges: false,
    zoom: 100,
    fitMode: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfFitMode.NONE,
    pageLayoutMode: _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_0__.PdfPageLayoutMode.ONE_COLUMN,
    firstVisiblePage: 0,
    lastVisiblePage: 0,
    pageNumber: 0,
    pageCount: 0,
};
const actions = {
    setZoom: (zoom) => ($state) => (Object.assign(Object.assign({}, $state), { zoom })),
    setFitMode: (fitMode) => ($state) => (Object.assign(Object.assign({}, $state), { fitMode })),
    setPageLayoutMode: (pageLayoutMode) => ($state) => (Object.assign(Object.assign({}, $state), { pageLayoutMode })),
    setHasChanges: (hasChanges) => ($state) => (Object.assign(Object.assign({}, $state), { hasChanges })),
    setFirstVisiblePage: (page) => ($state) => {
        const firstVisiblePage = page <= 1 ? 1 : page < $state.pageCount ? page : $state.pageCount;
        return Object.assign(Object.assign({}, $state), { firstVisiblePage });
    },
    setLastVisiblePage: (page) => ($state) => {
        const lastVisiblePage = page <= 1 ? 1 : page < $state.pageCount ? page : $state.pageCount;
        return Object.assign(Object.assign({}, $state), { lastVisiblePage });
    },
    setPageNumber: (page) => ($state) => {
        let pageNumber;
        if ($state.pageCount === 0)
            pageNumber = page;
        else
            pageNumber = page = page <= 1 ? 1 : page < $state.pageCount ? page : $state.pageCount;
        return Object.assign(Object.assign({}, $state), { pageNumber });
    },
    setPageCount: (pageCount) => ($state) => {
        return Object.assign(Object.assign({}, $state), { pageCount });
    },
    setFileInfo: (inputDocument) => ($state) => (Object.assign(Object.assign({}, $state), { filename: inputDocument.sourceTag, mimetype: 'application/pdf' })),
};


/***/ }),

/***/ "./src/pdf-web-viewer/state/search.ts":
/*!********************************************!*\
  !*** ./src/pdf-web-viewer/state/search.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "actions": () => (/* binding */ actions),
/* harmony export */   "state": () => (/* binding */ state)
/* harmony export */ });
const state = {
    showSearch: false,
    searchString: '',
    caseSensitive: false,
    wrapSearch: false,
    useRegex: false,
    page: 1,
    match: null,
    painted: false,
};
const actions = {
    updateToSearch: (searchString) => ($state) => (Object.assign(Object.assign({}, $state), { searchString })),
    openSearch: () => ($state) => (Object.assign(Object.assign({}, $state), { showSearch: true })),
    closeSearch: () => ($state) => (Object.assign(Object.assign({}, $state), { searchString: '', showSearch: false })),
    toggleCaseSensitive: () => ($state) => (Object.assign(Object.assign({}, $state), { caseSensitive: !$state.caseSensitive })),
    toggleWrappingSearch: () => ($state) => (Object.assign(Object.assign({}, $state), { wrapSearch: !$state.wrapSearch })),
    toggleRegex: () => ($state) => (Object.assign(Object.assign({}, $state), { useRegex: !$state.useRegex })),
    setCaseSensitive: (enabled) => ($state) => (Object.assign(Object.assign({}, $state), { caseSensitive: enabled })),
    setWrappingSearch: (enabled) => ($state) => (Object.assign(Object.assign({}, $state), { wrapSearch: enabled })),
    setRegex: (enabled) => ($state) => (Object.assign(Object.assign({}, $state), { useRegex: enabled })),
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/App.tsx":
/*!******************************************!*\
  !*** ./src/pdf-web-viewer/views/App.tsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "App": () => (/* binding */ App)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../state/layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Layout */ "./src/pdf-web-viewer/views/Layout.tsx");
/* harmony import */ var _DropZone__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DropZone */ "./src/pdf-web-viewer/views/DropZone.tsx");
/* harmony import */ var _modal_Modal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modal/Modal */ "./src/pdf-web-viewer/views/modal/Modal.tsx");






const App = () => (state, actions) => {
    const sizeCssClassName = state.layout.screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_2__.ScreenSize.Small
        ? 'sm'
        : state.layout.screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_2__.ScreenSize.Medium
            ? 'md'
            : 'lg';
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_DropZone__WEBPACK_IMPORTED_MODULE_4__.DropZone, { className: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-WebViewer', `pwv-WebViewer--${sizeCssClassName}`), enabled: state.options.viewer.permissions.allowFileDrop &&
            state.fileDropEnabled &&
            state.options.viewer.permissions.allowOpenFile, onFileSelected: (file) => actions.api.open({ pdfFile: { data: file, sourceTag: file.name } }) },
        state.scriptsLoaded && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Layout__WEBPACK_IMPORTED_MODULE_3__.Layout, null),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_modal_Modal__WEBPACK_IMPORTED_MODULE_5__.Modal, null)));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/CustomButtons.tsx":
/*!****************************************************!*\
  !*** ./src/pdf-web-viewer/views/CustomButtons.tsx ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomButtons": () => (/* binding */ CustomButtons)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TooltipManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/TooltipManager */ "./src/common/TooltipManager.ts");


const CustomButtons = ({ location, style }) => (state, actions) => {
    const { customButtons } = state.options.viewer;
    if (!customButtons ||
        !customButtons.hasOwnProperty(location) ||
        !customButtons[location].length) {
        return null;
    }
    const buttons = customButtons[location];
    return style === 'button' ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-CustomButtons" }, buttons.map((ca) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({ oncreate: _common_TooltipManager__WEBPACK_IMPORTED_MODULE_1__.tooltipManager.bindCssTooltip }, _common_TooltipManager__WEBPACK_IMPORTED_MODULE_1__.tooltipManager.createTooltip(ca.text), { class: "pwv-ToolbarButton", onclick: ca.onClick }),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-icon" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("img", { src: ca.icon }))))))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, buttons.map((ca) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: ca.onClick },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-icon" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("img", { src: ca.icon })),
        ca.text)))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/DropZone.tsx":
/*!***********************************************!*\
  !*** ./src/pdf-web-viewer/views/DropZone.tsx ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DropZone": () => (/* binding */ DropZone)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/classNames */ "./src/common/classNames.ts");


let allowDropTimer = 0;
const DropZone = ({ className, enabled, onFileSelected }, children) => {
    const handleDragOver = (e) => {
        e.preventDefault();
        if (!enabled) {
            return;
        }
        if (e.dataTransfer) {
            const dropContainer = e.currentTarget;
            const items = e.dataTransfer.items;
            if (items && items.length === 1 && items[0].type === 'application/pdf') {
                dropContainer.classList.add('pwv-dropzone-dragover');
                clearTimeout(allowDropTimer);
                allowDropTimer = window.setTimeout(() => {
                    dropContainer.classList.remove('pwv-dropzone-dragover');
                }, 150);
            }
        }
    };
    const handleDrop = (e) => {
        e.preventDefault();
        if (e.dataTransfer) {
            let pdfFile = null;
            if (e.dataTransfer.items) {
                for (let i = 0; i < e.dataTransfer.items.length; i++) {
                    const item = e.dataTransfer.items[i];
                    if (item.kind === 'file' && item.type === 'application/pdf') {
                        pdfFile = item.getAsFile();
                        break;
                    }
                }
            }
            else {
                for (let i = 0; i < e.dataTransfer.files.length; i++) {
                    const file = e.dataTransfer.files[i];
                    if (file.type === 'application/pdf') {
                        pdfFile = file;
                        break;
                    }
                }
            }
            if (enabled && pdfFile !== null) {
                onFileSelected(pdfFile);
            }
        }
    };
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)(className, 'pwv-dropzone'), ondragover: handleDragOver, ondrop: handleDrop }, children));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/Layout.tsx":
/*!*********************************************!*\
  !*** ./src/pdf-web-viewer/views/Layout.tsx ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Layout": () => (/* binding */ Layout)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _appbar_AppBar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./appbar/AppBar */ "./src/pdf-web-viewer/views/appbar/AppBar.tsx");
/* harmony import */ var _annotationbar_Annotationbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./annotationbar/Annotationbar */ "./src/pdf-web-viewer/views/annotationbar/Annotationbar.tsx");
/* harmony import */ var _navigation_NavigationPanel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./navigation/NavigationPanel */ "./src/pdf-web-viewer/views/navigation/NavigationPanel.tsx");





const Layout = ({}) => (state, actions) => {
    const { disableAnnotationToolbar, annotationBarPosition } = state.options.viewer.general;
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-Viewer', {
            'pwv-Viewer--loadFile': state.showLoadingIndicator,
            'pwv-Viewer--saveFile': state.showSaveIndicator,
        }) },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_appbar_AppBar__WEBPACK_IMPORTED_MODULE_2__.AppBar, null),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ViewerContent" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-document-view', `pwv-annotationbar-${annotationBarPosition}`) },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { oncreate: (element) => {
                        const a = actions;
                        a.createCanvasView(element);
                    } }),
                !disableAnnotationToolbar && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_annotationbar_Annotationbar__WEBPACK_IMPORTED_MODULE_3__.Annotationbar, null)),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_navigation_NavigationPanel__WEBPACK_IMPORTED_MODULE_4__.NavigationPanel, null))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/annotationbar/Annotationbar.tsx":
/*!******************************************************************!*\
  !*** ./src/pdf-web-viewer/views/annotationbar/Annotationbar.tsx ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Annotationbar": () => (/* binding */ Annotationbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../state/layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _CustomButtons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../CustomButtons */ "./src/pdf-web-viewer/views/CustomButtons.tsx");







const Annotationbar = ({}) => (state, actions) => {
    const smallScreen = state.layout.screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_1__.ScreenSize.Small;
    if (smallScreen || !state.licenseFeatures.annotate) {
        return null;
    }
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_4__.classNames)('pwv-annotationbar', `pwv-annotationbar-${state.options.viewer.general.annotationBarPosition}`) },
        state.options.modules
            .filter(({ moduleInfo }) => moduleInfo.requiredFeatures.annotate)
            .map((m) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_5__.icons[m.moduleInfo.icon], tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText(m.moduleInfo.translationKey), onClick: () => {
                actions.api.activateModule(m.moduleInfo.name, undefined);
            } }))),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_CustomButtons__WEBPACK_IMPORTED_MODULE_6__.CustomButtons, { location: "annotationbar", style: "button" })));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/AddonsToolbar.tsx":
/*!***********************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/AddonsToolbar.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddonsToolbar": () => (/* binding */ AddonsToolbar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../state/layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _AnnotationsMenu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AnnotationsMenu */ "./src/pdf-web-viewer/views/appbar/AnnotationsMenu.tsx");
/* harmony import */ var _CustomButtons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../CustomButtons */ "./src/pdf-web-viewer/views/CustomButtons.tsx");








const AddonsToolbar = ({}) => (state, actions) => {
    const smallScreen = state.layout.screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_1__.ScreenSize.Small;
    const mediumScreen = state.layout.screenSize <= _state_layout__WEBPACK_IMPORTED_MODULE_1__.ScreenSize.Medium;
    const { sidebar } = state.options.viewer;
    const { disableAnnotationToolbar } = state.options.viewer.general;
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, { className: "pwv-AddonsBar" },
        !disableAnnotationToolbar && smallScreen && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_AnnotationsMenu__WEBPACK_IMPORTED_MODULE_6__.AnnotationsMenu, null),
        state.options.viewer.permissions.enableSearch && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { name: "toggleSearch", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('toolbar.search'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_3__.icons.search, onClick: () => {
                if (!state.search.showSearch) {
                    actions.api.resetViewerMode();
                    actions.search.openSearch();
                }
                else {
                    actions.api.endSearch();
                    actions.search.closeSearch();
                }
            }, active: state.search.showSearch })),
        !smallScreen &&
            (sidebar.thumbnailNavigation ||
                sidebar.outlineNavigation ||
                sidebar.annotationNavigation) && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { name: "toggleSidePane", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('toolbar.toggleSidePane'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_3__.icons.docNavigation, onClick: () => {
                actions.api.loadNavigationItems();
                actions.navigationPanel.toggleNavigationPanel();
            }, active: state.navigationPanel.showNavigation })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_CustomButtons__WEBPACK_IMPORTED_MODULE_7__.CustomButtons, { location: "informationbar", style: "button" })));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/AnnotationsMenu.tsx":
/*!*************************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/AnnotationsMenu.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationsMenu": () => (/* binding */ AnnotationsMenu)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_DropdownMenu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/DropdownMenu */ "./src/common/DropdownMenu.tsx");
/* harmony import */ var _CustomButtons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../CustomButtons */ "./src/pdf-web-viewer/views/CustomButtons.tsx");





const AnnotationsMenu = ({}) => (state, actions) => {
    if (!state.licenseFeatures.annotate) {
        return null;
    }
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_DropdownMenu__WEBPACK_IMPORTED_MODULE_3__.DropdownMenu, { className: "pwv-LgHidden pwv-AnnotationMenu", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.annotationsMenuButton'), icon: _common_Icon__WEBPACK_IMPORTED_MODULE_2__.icons.edit },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
            state.options.modules
                .filter((m) => m.moduleInfo.requiredFeatures.annotate)
                .map((m) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: () => {
                    actions.api.activateModule(m.moduleInfo.name, undefined);
                } },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_2__.icons[m.moduleInfo.icon] }),
                ' ',
                _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText(m.moduleInfo.translationKey)))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_CustomButtons__WEBPACK_IMPORTED_MODULE_4__.CustomButtons, { location: "annotationbar", style: "listItem" }))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/AppBar.tsx":
/*!****************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/AppBar.tsx ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppBar": () => (/* binding */ AppBar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../state/layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _Menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Menu */ "./src/pdf-web-viewer/views/appbar/Menu.tsx");
/* harmony import */ var _DocumentBar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DocumentBar */ "./src/pdf-web-viewer/views/appbar/DocumentBar.tsx");
/* harmony import */ var _NavigationBar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./NavigationBar */ "./src/pdf-web-viewer/views/appbar/NavigationBar.tsx");
/* harmony import */ var _ZoomBar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ZoomBar */ "./src/pdf-web-viewer/views/appbar/ZoomBar.tsx");
/* harmony import */ var _SearchBar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SearchBar */ "./src/pdf-web-viewer/views/appbar/SearchBar.tsx");
/* harmony import */ var _ViewBar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ViewBar */ "./src/pdf-web-viewer/views/appbar/ViewBar.tsx");
/* harmony import */ var _AddonsToolbar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./AddonsToolbar */ "./src/pdf-web-viewer/views/appbar/AddonsToolbar.tsx");











const AppBar = ({}) => (state, actions) => {
    const mediumScreen = state.layout.screenSize <= _state_layout__WEBPACK_IMPORTED_MODULE_1__.ScreenSize.Medium;
    const { disableMainToolbar } = state.options.viewer.general;
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-AppBar" },
        !state.options.viewer.general.disableMainToolbar && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { allowWrap: true },
            mediumScreen ? (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_Menu__WEBPACK_IMPORTED_MODULE_4__.Menu, null) : (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_DocumentBar__WEBPACK_IMPORTED_MODULE_5__.DocumentBar, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_NavigationBar__WEBPACK_IMPORTED_MODULE_6__.NavigationBar, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_3__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_ZoomBar__WEBPACK_IMPORTED_MODULE_7__.ZoomBar, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_3__.ToolbarSeparator, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_ViewBar__WEBPACK_IMPORTED_MODULE_9__.ViewBar, null),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_AddonsToolbar__WEBPACK_IMPORTED_MODULE_10__.AddonsToolbar, null))),
        state.search.showSearch && state.options.viewer.permissions.enableSearch && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_SearchBar__WEBPACK_IMPORTED_MODULE_8__.SearchBar, null)));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/DocumentBar.tsx":
/*!*********************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/DocumentBar.tsx ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DocumentBar": () => (/* binding */ DocumentBar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_ToolbarFileButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/ToolbarFileButton */ "./src/common/ToolbarFileButton.tsx");
/* harmony import */ var _CustomButtons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../CustomButtons */ "./src/pdf-web-viewer/views/CustomButtons.tsx");







const DocumentBar = ({}) => (state, actions) => {
    const { permissions, callbacks } = state.options.viewer;
    const onSaveFileButtonClicked = () => {
        if (callbacks.onSaveFileButtonClicked) {
            callbacks.onSaveFileButtonClicked();
        }
        else {
            actions.api.downloadFile();
        }
    };
    const onCloseFileButtonClicked = () => {
        if (callbacks.onCloseFileButtonClicked) {
            callbacks.onCloseFileButtonClicked();
        }
        else {
            actions.api.close();
        }
    };
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__.ToolbarItemGroup, { className: "pwv-DocumentBar" },
        permissions.allowOpenFile && !callbacks.onOpenFileButtonClicked && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarFileButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarFileButton, { name: "openDocument", className: "pwv-MdHidden pwv-SmHidden", icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.openFile, accept: ".pdf", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.openDocument'), onFileSelected: (file) => actions.api.open({ pdfFile: { data: file } }) })),
        permissions.allowOpenFile && callbacks.onOpenFileButtonClicked && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { name: "openDocument", className: "pwv-MdHidden pwv-SmHidden", icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.openFile, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.openDocument'), onClick: callbacks.onOpenFileButtonClicked })),
        permissions.allowSaveFile && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { name: "saveDocument", className: "pwv-MdHidden pwv-SmHidden", icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.saveFile, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.saveDocument'), onClick: onSaveFileButtonClicked })),
        permissions.allowCloseFile && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { name: "closeDocument", className: "pwv-MdHidden pwv-SmHidden", icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.closeFile, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.closeDocument'), onClick: onCloseFileButtonClicked })),
        permissions.allowPrinting && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { name: "print", className: "pwv-MdHidden pwv-SmHidden", icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.print, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.print'), onClick: actions.api.print })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_CustomButtons__WEBPACK_IMPORTED_MODULE_6__.CustomButtons, { location: "documentbar", style: "button" })));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/Menu.tsx":
/*!**************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/Menu.tsx ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Menu": () => (/* binding */ Menu)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../state/layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_DropdownMenu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/DropdownMenu */ "./src/common/DropdownMenu.tsx");
/* harmony import */ var _common_DropdownSeparator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../common/DropdownSeparator */ "./src/common/DropdownSeparator.tsx");
/* harmony import */ var _CustomButtons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../CustomButtons */ "./src/pdf-web-viewer/views/CustomButtons.tsx");








const Menu = ({}) => (state, actions) => {
    const { permissions, callbacks } = state.options.viewer;
    const { outlineNavigation, annotationNavigation } = state.options.viewer.sidebar;
    const { screenSize } = state.layout;
    const onSaveFileButtonClicked = () => {
        if (callbacks.onSaveFileButtonClicked) {
            callbacks.onSaveFileButtonClicked();
        }
        else {
            actions.api.downloadFile();
        }
    };
    const onCloseFileButtonClicked = () => {
        if (callbacks.onCloseFileButtonClicked) {
            callbacks.onCloseFileButtonClicked();
        }
        else {
            actions.api.close();
        }
    };
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { className: "pwv-DocumentBar" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_DropdownMenu__WEBPACK_IMPORTED_MODULE_5__.DropdownMenu, { className: "pwv-LgHidden", icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.bars },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                permissions.allowOpenFile && !callbacks.onOpenFileButtonClicked && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("label", { class: "pwv-DropdownItem" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.openFile }),
                    " ",
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('toolbar.openDocument'),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { accept: ".pdf", type: "file", onchange: (e) => {
                            if (e.currentTarget.files && e.currentTarget.files.length) {
                                const file = e.currentTarget.files[0];
                                actions.api.open({ pdfFile: { data: file } });
                            }
                        }, style: { display: 'none' } }))),
                permissions.allowOpenFile && callbacks.onOpenFileButtonClicked && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: callbacks.onOpenFileButtonClicked },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.openFile }),
                    " ",
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('toolbar.openDocument'))),
                permissions.allowSaveFile && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: onSaveFileButtonClicked },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.saveFile }),
                    " ",
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('toolbar.saveDocument'))),
                permissions.allowCloseFile && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: onCloseFileButtonClicked },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.closeFile }),
                    ' ',
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('toolbar.closeDocument'))),
                permissions.allowPrinting && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: actions.api.print },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.print }),
                    " ",
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('toolbar.print'))),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_CustomButtons__WEBPACK_IMPORTED_MODULE_7__.CustomButtons, { location: "documentbar", style: "listItem" }),
                permissions.allowRotateView && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_DropdownSeparator__WEBPACK_IMPORTED_MODULE_6__.DropdownSeparator, null),
                permissions.allowRotateView && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: actions.api.rotate },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.rotate }),
                    " ",
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('toolbar.rotateView'))),
                screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_1__.ScreenSize.Small && (outlineNavigation || annotationNavigation) && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_DropdownSeparator__WEBPACK_IMPORTED_MODULE_6__.DropdownSeparator, null)),
                screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_1__.ScreenSize.Small && outlineNavigation && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: () => {
                        actions.api.loadNavigationItems();
                        actions.navigationPanel.selectNavigation('outline');
                    } },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.sidePaneOutline }),
                    ' ',
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('sideNavigation.outline'))),
                screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_1__.ScreenSize.Small && annotationNavigation && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-DropdownItem", onclick: () => {
                        actions.api.loadNavigationItems();
                        actions.navigationPanel.selectNavigation('annotation');
                    } },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_4__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.sidePaneAnnotation }),
                    ' ',
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('sideNavigation.annotation')))))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/NavigationBar.tsx":
/*!***********************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/NavigationBar.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavigationBar": () => (/* binding */ NavigationBar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/icons */ "./src/common/icons.ts");





const resizeObserver = new ResizeObserver((e) => {
    if (e.length) {
        e.forEach((elm) => {
            if (elm.target && elm.target.parentElement) {
                const input = elm.target.parentElement.querySelector('input');
                if (input) {
                    input.style.minWidth = `${elm.contentRect.width + 4}px`;
                }
            }
        });
    }
});
const NavigationBar = ({}) => (state, actions) => {
    const { pdfDocument } = state;
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_2__.ToolbarItemGroup, { className: "pwv-NavigationBar" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { name: "previewsPage", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.previewsPage'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_4__.icons.previousPage, onClick: () => actions.api.previousPage(), disabled: pdfDocument.pageNumber <= 1 }),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ToolbarItem pwv-navigation-toolbar-pageinput" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { name: "pageNumber", value: pdfDocument.pageNumber, onkeydown: (e) => {
                    if (e.key === 'ArrowDown') {
                        actions.api.nextPage();
                    }
                    else if (e.key === 'ArrowUp') {
                        actions.api.previousPage();
                    }
                    else if (e.key === 'Enter') {
                        const input = e.currentTarget;
                        if (input && input.value) {
                            actions.api.setPageNumber(parseInt(input.value, undefined));
                        }
                    }
                    else if ((e.key.charCodeAt(0) >= 48 && e.key.charCodeAt(0) <= 57) ||
                        e.key === 'Delete' ||
                        e.key === 'Backspace' ||
                        e.key === 'ArrowLeft' ||
                        e.key === 'ArrowRight' ||
                        e.key === 'Tab') {
                    }
                    else {
                        e.preventDefault();
                    }
                    e.stopPropagation();
                }, onblur: (e) => {
                    let page = parseInt(e.target.value, undefined);
                    if (Number.isNaN(page)) {
                        page = actions.api.getPageNumber();
                    }
                    else if (page < 1) {
                        page = 1;
                    }
                    else {
                        const pageCount = actions.api.getPageCount();
                        if (page > pageCount) {
                            page = pageCount;
                        }
                    }
                    ;
                    e.target.value = page.toString();
                    actions.api.setPageNumber(page);
                }, disabled: pdfDocument.pageCount < 1 }),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.pageOf')),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("label", { oncreate: (label) => {
                    resizeObserver.observe(label);
                }, onremove: (label) => {
                    resizeObserver.unobserve(label);
                } }, pdfDocument.pageCount)),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_3__.ToolbarButton, { name: "nextPage", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.nextPage'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_4__.icons.nextPage, onClick: () => actions.api.nextPage(), disabled: pdfDocument.pageNumber === pdfDocument.pageCount })));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/SearchBar.tsx":
/*!*******************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/SearchBar.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SearchBar": () => (/* binding */ SearchBar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/ToolbarSeparator */ "./src/common/ToolbarSeparator.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../common/utils */ "./src/common/utils.ts");
/* harmony import */ var _SearchOptions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SearchOptions */ "./src/pdf-web-viewer/views/appbar/SearchOptions.tsx");









const SearchBar = ({}) => (state, actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_2__.Toolbar, { className: "pwv-SearchBar" },
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, null,
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ToolbarItem pwv-searchbar-input" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { value: state.search.searchString, class: "pwv-SearchInputField", oncreate: (element) => {
                    element.focus();
                    element.addEventListener('keydown', (e) => {
                        e.cancelBubble = true;
                        const { shortcuts } = state.options;
                        const cmd = (0,_common_utils__WEBPACK_IMPORTED_MODULE_7__.getKeyboardCommands)(e, shortcuts, []);
                        if ((cmd === null || cmd === void 0 ? void 0 : cmd.length) &&
                            (cmd.includes('searchNext') ||
                                cmd.includes('searchPrevious') ||
                                cmd.includes('closeSearch'))) {
                            e.preventDefault();
                        }
                    }, false);
                    element.addEventListener('input', (e) => {
                        const inputValue = e.currentTarget.value;
                        actions.search.updateToSearch(inputValue);
                        if (inputValue !== '') {
                            actions.api.startSearch();
                        }
                        else {
                            actions.api.endSearch();
                        }
                    });
                    element.addEventListener('keyup', (e) => {
                        e.cancelBubble = true;
                        const inputValue = e.currentTarget.value;
                        const { shortcuts } = state.options;
                        const cmd = (0,_common_utils__WEBPACK_IMPORTED_MODULE_7__.getKeyboardCommands)(e, shortcuts, []);
                        if (cmd === null || cmd === void 0 ? void 0 : cmd.includes('searchNext')) {
                            e.preventDefault();
                            actions.api.nextSearchMatch();
                        }
                        else if (cmd === null || cmd === void 0 ? void 0 : cmd.includes('searchPrevious')) {
                            e.preventDefault();
                            actions.api.previousSearchMatch();
                        }
                        else if (cmd === null || cmd === void 0 ? void 0 : cmd.includes('closeSearch')) {
                            e.preventDefault();
                            actions.api.endSearch();
                            actions.search.closeSearch();
                        }
                        else if (e.key === 'Enter' || e.key === 'ArrowDown') {
                            if (inputValue !== '') {
                                actions.api.nextSearchMatch();
                            }
                        }
                        else if (e.key === 'ArrowUp') {
                            if (inputValue !== '') {
                                actions.api.previousSearchMatch();
                            }
                        }
                        else if (e.key === 'Escape') {
                            actions.api.endSearch();
                            actions.search.closeSearch();
                        }
                    }, false);
                } })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('search.previousMatch'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.previousPage, disabled: state.search.searchString === '', onClick: actions.api.previousSearchMatch }),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('search.nextMatch'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.nextPage, disabled: state.search.searchString === '', onClick: actions.api.nextSearchMatch }),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_SearchOptions__WEBPACK_IMPORTED_MODULE_8__.SearchOptions, null),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarSeparator__WEBPACK_IMPORTED_MODULE_5__.ToolbarSeparator, null)),
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { pushRight: true },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_6__.icons.close, onClick: () => {
                actions.api.endSearch();
                actions.search.closeSearch();
            } }))));


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/SearchOptions.tsx":
/*!***********************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/SearchOptions.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SearchOptions": () => (/* binding */ SearchOptions)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Dropdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/Dropdown */ "./src/common/Dropdown.tsx");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TooltipManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/TooltipManager */ "./src/common/TooltipManager.ts");





const SearchOptions = (props) => ($state, actions) => {
    if (props.disabled) {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { title: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('search.options'), class: "pwv-Dropdown pwv-searchoptions pwv-disabled pwv-Dropdown--alignRight" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-text" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.options })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-caret" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.dropdownCaret }))));
    }
    else {
        return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-Dropdown pwv-searchoptions pwv-Dropdown--alignRight" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", Object.assign({}, _common_TooltipManager__WEBPACK_IMPORTED_MODULE_4__.tooltipManager.createTooltip(_common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('search.options')), { oncreate: _common_Dropdown__WEBPACK_IMPORTED_MODULE_2__.DropdownComponent.create, onremove: _common_Dropdown__WEBPACK_IMPORTED_MODULE_2__.DropdownComponent.remove }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-text" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.options })),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-Dropdown-caret" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.dropdownCaret }))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-DropdownPanel" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("ul", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", { class: "pwv-checkbox-btn", onclick: (e) => {
                            const s = actions.search.toggleCaseSensitive();
                            e.preventDefault();
                            e.cancelBubble = true;
                            if (s.searchString !== '') {
                                actions.api.startSearch();
                            }
                        } },
                        $state.search.caseSensitive ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.checkboxChecked })) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.checkbox })),
                        _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('search.optionCaseSensitive')),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", { class: "pwv-checkbox-btn", onclick: (e) => {
                            const s = actions.search.toggleWrappingSearch();
                            e.preventDefault();
                            e.cancelBubble = true;
                            if (s.searchString !== '') {
                                actions.api.startSearch();
                            }
                        } },
                        $state.search.wrapSearch ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.checkboxChecked })) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.checkbox })),
                        _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('search.optionWrap')),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", { class: "pwv-checkbox-btn", onclick: (e) => {
                            const s = actions.search.toggleRegex();
                            e.preventDefault();
                            e.cancelBubble = true;
                            if (s.searchString !== '') {
                                actions.api.startSearch();
                            }
                        } },
                        $state.search.useRegex ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.checkboxChecked })) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.checkbox })),
                        _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('search.optionRegularExpression'))))));
    }
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/ViewBar.tsx":
/*!*****************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/ViewBar.tsx ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewBar": () => (/* binding */ ViewBar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../state/layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_Dropdown__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../common/Dropdown */ "./src/common/Dropdown.tsx");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../common/icons */ "./src/common/icons.ts");









function getPageLayoutModeTranslation(layoutMode) {
    switch (layoutMode) {
        case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfPageLayoutMode.ONE_COLUMN:
            return _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('pageLayoutMode.oneColumn');
        case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfPageLayoutMode.SINGLE_PAGE:
            return _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('pageLayoutMode.singlePage');
        case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfPageLayoutMode.TWO_COLUMN_LEFT:
            return _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('pageLayoutMode.twoColumnLeft');
        case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfPageLayoutMode.TWO_COLUMN_RIGHT:
            return _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('pageLayoutMode.twoColumnRight');
        case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfPageLayoutMode.TWO_PAGE_LEFT:
            return _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('pageLayoutMode.twoPageLeft');
        case _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfPageLayoutMode.TWO_PAGE_RIGHT:
            return _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('pageLayoutMode.twoPageRight');
    }
}
const ViewBar = ({}) => (state, actions) => {
    const { pdfDocument } = state;
    const { screenSize } = state.layout;
    const layoutModeItems = state.options.viewer.general.pageLayoutModes.map((m) => ({
        text: getPageLayoutModeTranslation(m),
        value: m,
        renderItem: (i) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { className: "pwv-page-layout-mode-item" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_7__.Icon, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons[`pageLayoutMode${i.value}`], className: "pwv-page-layout-mode-icon" }),
            i.text)),
    }));
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_4__.ToolbarItemGroup, { className: "pwv-ViewBar" },
        pdfDocument.fitMode === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode.NONE && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { name: "fitMode", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('fitMode.none'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.fitActualSize, onClick: () => {
                actions.api.setFitMode(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode.FIT_PAGE);
            } })),
        pdfDocument.fitMode === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode.FIT_PAGE && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { name: "fitMode", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('fitMode.page'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.fitPage, onClick: () => {
                actions.api.setFitMode(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode.FIT_WIDTH);
            } })),
        pdfDocument.fitMode === _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode.FIT_WIDTH && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { name: "fitMode", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('fitMode.width'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.fitWidth, onClick: () => {
                actions.api.setFitMode(_pdf_viewer_api__WEBPACK_IMPORTED_MODULE_1__.PdfFitMode.NONE);
                actions.api.setZoom(100);
            } })),
        state.options.viewer.permissions.enablePageLayoutMode && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Dropdown__WEBPACK_IMPORTED_MODULE_6__.Dropdown, { name: "pageLayoutMode", tooltip: getPageLayoutModeTranslation(pdfDocument.pageLayoutMode), items: layoutModeItems, value: pdfDocument.pageLayoutMode, className: "pwv-page-layout-mode", renderButton: (i, text) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_7__.Icon, { icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons[`pageLayoutMode${i}`], className: "pwv-page-layout-mode-icon" })), onChange: (value) => {
                actions.api.setPageLayoutMode(value);
            } })),
        state.options.viewer.permissions.allowRotateView && screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_2__.ScreenSize.Large && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_5__.ToolbarButton, { name: "rotateView", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('toolbar.rotateView'), icon: _common_icons__WEBPACK_IMPORTED_MODULE_8__.icons.rotate, onClick: actions.api.rotate }))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/appbar/ZoomBar.tsx":
/*!*****************************************************!*\
  !*** ./src/pdf-web-viewer/views/appbar/ZoomBar.tsx ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZoomBar": () => (/* binding */ ZoomBar)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/icons */ "./src/common/icons.ts");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_Dropdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/Dropdown */ "./src/common/Dropdown.tsx");






const ZoomBar = ({}) => (state, actions) => {
    const { defaultZoomLevels } = state.options.viewer.general;
    const { zoom } = state.pdfDocument;
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_3__.ToolbarItemGroup, { className: "pwv-ZoomBar" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { name: "zoomIn", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.zoomIn'), className: "pwv-MdHidden pwv-SmHidden", icon: _common_icons__WEBPACK_IMPORTED_MODULE_2__.icons.zoomIn, disabled: zoom >= defaultZoomLevels[defaultZoomLevels.length - 1] * 100, onClick: () => actions.api.zoomIn() }),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { name: "zoomOut", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.zoomOut'), className: "pwv-MdHidden pwv-SmHidden", icon: _common_icons__WEBPACK_IMPORTED_MODULE_2__.icons.zoomOut, disabled: zoom <= defaultZoomLevels[0] * 100, onClick: () => actions.api.zoomOut() }),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Dropdown__WEBPACK_IMPORTED_MODULE_5__.Dropdown, { name: "zoom", tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('toolbar.zoom'), className: "pwv-Dropdown-zoom", items: defaultZoomLevels.map((zoom) => ({
                value: zoom * 100,
                text: Math.floor(zoom * 100) + '%',
            })), value: zoom, text: Math.floor(zoom) + '%', align: "right", onChange: (zoom) => actions.api.setZoom(zoom) })));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/ApplicationError.tsx":
/*!*************************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/ApplicationError.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApplicationError": () => (/* binding */ ApplicationError)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");



const ApplicationError = ({}) => (state, actions) => {
    let message = _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('applicationError.defaultMessage');
    switch (state.errorMessage) {
        case 'Invalid License':
            message = _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('applicationError.invalidLicense');
            break;
    }
    const btnText = _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('applicationError.reload');
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal pwv-modal--applicationError" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-dialog" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-header" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_1__.icons.error }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h2", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('applicationError.title'))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-body" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-message" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("p", null, message)),
                btnText && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-btn-row" },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-btn", onclick: () => {
                            document.location && document.location.reload();
                        } }, btnText)))))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/LoadApplication.tsx":
/*!************************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/LoadApplication.tsx ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoadApplication": () => (/* binding */ LoadApplication)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_Loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/Loader */ "./src/common/Loader.tsx");


const LoadApplication = ({}) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal pwv-modal--loadApplication" },
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-body-noborder" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Loader__WEBPACK_IMPORTED_MODULE_1__.Loader, null))));


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/LoadFile.tsx":
/*!*****************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/LoadFile.tsx ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoadFile": () => (/* binding */ LoadFile)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/Loader */ "./src/common/Loader.tsx");



const LoadFile = ({}) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal pwv-modal--loadFile" },
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-dialog" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-body" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-message" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h2", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('loadFile.title')),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Loader__WEBPACK_IMPORTED_MODULE_2__.Loader, null))))));


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/Modal.tsx":
/*!**************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/Modal.tsx ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Modal": () => (/* binding */ Modal)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _OpenFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OpenFile */ "./src/pdf-web-viewer/views/modal/OpenFile.tsx");
/* harmony import */ var _OpenFileError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OpenFileError */ "./src/pdf-web-viewer/views/modal/OpenFileError.tsx");
/* harmony import */ var _UnsavedChanges__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UnsavedChanges */ "./src/pdf-web-viewer/views/modal/UnsavedChanges.tsx");
/* harmony import */ var _PasswordForm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PasswordForm */ "./src/pdf-web-viewer/views/modal/PasswordForm.tsx");
/* harmony import */ var _LoadApplication__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LoadApplication */ "./src/pdf-web-viewer/views/modal/LoadApplication.tsx");
/* harmony import */ var _ApplicationError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ApplicationError */ "./src/pdf-web-viewer/views/modal/ApplicationError.tsx");
/* harmony import */ var _LoadFile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./LoadFile */ "./src/pdf-web-viewer/views/modal/LoadFile.tsx");
/* harmony import */ var _SaveFile__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SaveFile */ "./src/pdf-web-viewer/views/modal/SaveFile.tsx");









const Modal = ({}) => (state, actions) => {
    if (state.hasError) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_ApplicationError__WEBPACK_IMPORTED_MODULE_6__.ApplicationError, null);
    }
    else if (!state.scriptsLoaded && !state.appInitialized) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_LoadApplication__WEBPACK_IMPORTED_MODULE_5__.LoadApplication, null);
    }
    else if (state.showOpenFileErrorDialog) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_OpenFileError__WEBPACK_IMPORTED_MODULE_2__.OpenFileError, null);
    }
    else if (state.showPasswordForm) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_PasswordForm__WEBPACK_IMPORTED_MODULE_4__.PasswordForm, null);
    }
    else if (state.showUnsavedChangesDialog) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_UnsavedChanges__WEBPACK_IMPORTED_MODULE_3__.UnsavedChanges, null);
    }
    else if (state.showLoadingIndicator) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_LoadFile__WEBPACK_IMPORTED_MODULE_7__.LoadFile, null);
    }
    else if (state.showSaveIndicator) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_SaveFile__WEBPACK_IMPORTED_MODULE_8__.SaveFile, null);
    }
    else if (!state.hasDocument) {
        return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_OpenFile__WEBPACK_IMPORTED_MODULE_1__.OpenFile, null);
    }
    else {
        return null;
    }
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/OpenFile.tsx":
/*!*****************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/OpenFile.tsx ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OpenFile": () => (/* binding */ OpenFile)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../state/layout */ "./src/pdf-web-viewer/state/layout.ts");




const OpenFile = ({}) => (state, actions) => {
    const handleFileSelected = (e) => {
        if (e.currentTarget.files &&
            e.currentTarget.files.length &&
            e.currentTarget.files.length > 0) {
            const file = e.currentTarget.files[0];
            if (file.type === 'application/pdf') {
                actions.api.open({ pdfFile: { data: file, sourceTag: file.name } });
            }
        }
    };
    const { permissions, callbacks } = state.options.viewer;
    const { deviceType } = state.layout;
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal pwv-openfile  pwv-modal--openFile" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-dialog" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-header" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_1__.icons.pdfFile })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-body" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-message" }, deviceType === _state_layout__WEBPACK_IMPORTED_MODULE_3__.DeviceType.Desktop &&
                    permissions.allowFileDrop &&
                    permissions.allowOpenFile ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h2", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('openFile.dropFileHere'))) : permissions.allowOpenFile ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h2", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('openFile.openDocument'))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h2", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('openFile.openFileDisabled')))),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-btn-row" }, permissions.allowOpenFile ? (callbacks.onOpenFileButtonClicked ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-btn", onclick: callbacks.onOpenFileButtonClicked }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('openFile.selectFile'))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("label", { class: "pwv-btn" },
                    _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('openFile.selectFile'),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { type: "file", onchange: handleFileSelected, style: { display: 'none' } })))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null)))))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/OpenFileError.tsx":
/*!**********************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/OpenFileError.tsx ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OpenFileError": () => (/* binding */ OpenFileError)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");



const OpenFileError = ({}) => (state, actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal pwv-modal--openFileError" },
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-dialog" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-header" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_1__.icons.fileError })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-body" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-message" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("p", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('openFileError.description'))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-btn-row" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-btn", onclick: actions.loadDocumentConfirmRejected }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('openFileError.ok')))))));


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/PasswordForm.tsx":
/*!*********************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/PasswordForm.tsx ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PasswordForm": () => (/* binding */ PasswordForm)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");




const PasswordForm = ({}) => (state, actions) => {
    const formIsValid = !state.passwordForm.passwordRequiredError &&
        !state.passwordForm.invalidPasswordError &&
        state.passwordForm.password !== '';
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal pwv-modal--passwordForm" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-dialog" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-header" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_1__.icons.unlock })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-body" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("form", { onsubmit: (e) => {
                        e.preventDefault();
                        const data = new FormData(e.currentTarget);
                        const password = data.get('password');
                        if (password) {
                            if (!state.fileOpenArgs) {
                                actions.loadDocumentRejected('error');
                                return;
                            }
                            if (state.fileOpenArgs) {
                                actions.api.open(Object.assign(Object.assign({}, state.fileOpenArgs), { password }));
                            }
                        }
                    } },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-message" },
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("p", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('passwordForm.description'))),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-form-row" },
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-form-field pwv-form-has-error-x" },
                            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("input", { type: "password", class: "pwv-input", name: "password", onkeyup: (e) => {
                                    const inputValue = e.currentTarget.value;
                                    actions.passwordForm.updatePassword(inputValue);
                                    actions.passwordForm.validateForm();
                                }, oncreate: (element) => {
                                    element.focus();
                                } }),
                            state.passwordForm.invalidPasswordError && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-form-error" },
                                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_1__.icons.warning }),
                                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('passwordForm.invalidPasswordError')))),
                            state.passwordForm.passwordRequiredError && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-form-error" },
                                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_1__.icons.warning }),
                                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('passwordForm.passwordRequiredError')))))),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-btn-row" },
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_2__.classNames)('pwv-btn', {
                                'pwv-disabled': !formIsValid,
                            }), type: "submit", disabled: !formIsValid }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('passwordForm.ok')),
                        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-btn", type: "button", onclick: actions.loadDocumentCancel }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('passwordForm.cancel'))))))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/SaveFile.tsx":
/*!*****************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/SaveFile.tsx ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SaveFile": () => (/* binding */ SaveFile)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_Loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/Loader */ "./src/common/Loader.tsx");



const SaveFile = ({}) => (state, actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal pwv-modal--saveFile" },
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-dialog" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-body" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-message" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h2", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('saveFile.title')),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Loader__WEBPACK_IMPORTED_MODULE_2__.Loader, null))))));


/***/ }),

/***/ "./src/pdf-web-viewer/views/modal/UnsavedChanges.tsx":
/*!***********************************************************!*\
  !*** ./src/pdf-web-viewer/views/modal/UnsavedChanges.tsx ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnsavedChanges": () => (/* binding */ UnsavedChanges)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");



const UnsavedChanges = ({}) => ($state, $actions) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal pwv-modal--unsavedChanges" },
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-dialog" },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-header" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_1__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_1__.icons.warning })),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-body" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-modal-message" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("p", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('unsavedChanges.description'))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-btn-row" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-btn", onclick: () => {
                        $actions.api.downloadFile().then(() => {
                            if ($state.closeCallback) {
                                $state.closeCallback();
                            }
                            else {
                                $actions.unsavedChangesDialogFileSaved();
                            }
                            if ($state.fileOpenArgs) {
                                $actions.api.open($state.fileOpenArgs);
                            }
                        });
                    } }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('unsavedChanges.save')),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-btn", onclick: () => {
                        $actions.unsavedChangesDialogDontSave();
                        if ($state.fileOpenArgs) {
                            $actions.api.open($state.fileOpenArgs);
                        }
                    } }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('unsavedChanges.dontSave')),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "pwv-btn", onclick: $actions.unsavedChangesDialogCancel }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('unsavedChanges.cancel')))))));


/***/ }),

/***/ "./src/pdf-web-viewer/views/navigation/AnnotationList.tsx":
/*!****************************************************************!*\
  !*** ./src/pdf-web-viewer/views/navigation/AnnotationList.tsx ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationList": () => (/* binding */ AnnotationList)
/* harmony export */ });
/* harmony import */ var _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../pdf-viewer-api/enums */ "./src/pdf-viewer-api/enums.ts");
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _AnnotationListItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnnotationListItem */ "./src/pdf-web-viewer/views/navigation/AnnotationListItem.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");




const AnnotationList = (props) => (state, actions) => {
    const { pageNumber } = props;
    const annotationsObj = state.navigationPanel.annotations[pageNumber];
    const selectedAnnotation = state.navigationPanel.selectedAnnotation;
    const annotations = Object.keys(annotationsObj).map((k) => annotationsObj[k]);
    const showHiddenAnnotations = state.options.annotation.hideOnDelete && state.options.annotation.trackHistory;
    const sortedAnnotations = annotations
        .filter((a) => a.itemType !== _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_0__.PdfItemType.WIDGET && (showHiddenAnnotations || a.isHidden() === false))
        .sort((f, s) => s.pdfRect.pdfY - f.pdfRect.pdfY);
    if (sortedAnnotations.length < 1) {
        return null;
    }
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_1__.h)("div", null,
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_1__.h)("h4", null,
            _common_TranslationManager__WEBPACK_IMPORTED_MODULE_3__.translationManager.getText('sideNavigation.annotation.page'),
            " ",
            pageNumber),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_1__.h)("ul", null, sortedAnnotations.map((annotation) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_1__.h)(_AnnotationListItem__WEBPACK_IMPORTED_MODULE_2__.AnnotationListItem, { annotation: annotation, selected: selectedAnnotation !== undefined &&
                selectedAnnotation.page === annotation.pdfRect.page &&
                selectedAnnotation.annotationId === annotation.id }))))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/navigation/AnnotationListItem.tsx":
/*!********************************************************************!*\
  !*** ./src/pdf-web-viewer/views/navigation/AnnotationListItem.tsx ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationListItem": () => (/* binding */ AnnotationListItem)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../pdf-viewer-api/enums */ "./src/pdf-viewer-api/enums.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _common_Tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/Tools */ "./src/common/Tools.ts");






const AnnotationIcon = ({ annotaion }) => (state, actions) => {
    const { itemType, color } = annotaion;
    const bg = color ? color : undefined;
    switch (itemType) {
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.HIGHLIGHT:
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.SQUIGGLY:
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.UNDERLINE:
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.STRIKE_OUT:
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.highlighter, bg: bg });
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.STAMP:
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.stamp, bg: bg });
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.FREE_TEXT:
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.freeText, bg: bg });
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.POPUP:
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.TEXT:
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.stickyNote, bg: bg });
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.INK:
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.pencil, bg: bg });
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.SQUARE: {
            const fill = annotaion.fillColor;
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.rectangle, bg: fill });
        }
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.CIRCLE: {
            const fill = annotaion.fillColor;
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.circle, bg: fill });
        }
        default:
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.annotation, bg: bg });
    }
};
const HistoryItem = ({ item }) => (state, actions) => {
    switch (item.Type) {
        case '/Create':
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.addLayer }),
                    item.T && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-author" }, item.T),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("time", null, (0,_common_Tools__WEBPACK_IMPORTED_MODULE_5__.formatDate)(item.D)))));
        case '/Edit':
            const params = {};
            if (item.Parms) {
                for (let i = 0; i < item.Parms.length; i += 2) {
                    const key = item.Parms[i];
                    let value = item.Parms[i + 1];
                    value = removeParentheses(value);
                    params[key] = value ? value : '';
                }
            }
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.pen }),
                    item.T && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-author" }, item.T),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("time", null, (0,_common_Tools__WEBPACK_IMPORTED_MODULE_5__.formatDate)(item.D))),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ms-custom-history-content" },
                    params['/Subj'] && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h5", null, params['/Subj']),
                    params['/Contents'] && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("p", null, params['/Contents']))));
        case '/Lock':
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.lock }),
                    item.T && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-author" }, item.T),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("time", null, (0,_common_Tools__WEBPACK_IMPORTED_MODULE_5__.formatDate)(item.D)))));
        case '/Unlock':
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.unlock }),
                    item.T && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-author" }, item.T),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("time", null, (0,_common_Tools__WEBPACK_IMPORTED_MODULE_5__.formatDate)(item.D)))));
        case '/Delete':
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", null,
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons["delete"] }),
                    item.T && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-author" }, item.T),
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("time", null, (0,_common_Tools__WEBPACK_IMPORTED_MODULE_5__.formatDate)(item.D)))));
        default:
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", null, "...");
    }
};
const TextMarkupPreview = ({ annotaion }) => (state, actions) => {
    const { markedText, itemType, color } = annotaion;
    switch (itemType) {
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.HIGHLIGHT:
            return (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { style: { backgroundColor: color } }, markedText);
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.SQUIGGLY:
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { style: {
                    textDecoration: 'underline',
                    textDecorationStyle: 'wavy',
                    textDecorationColor: color,
                } }, markedText));
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.UNDERLINE:
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { style: {
                    textDecoration: 'underline',
                    textDecorationColor: color,
                } }, markedText));
        case _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.STRIKE_OUT:
            return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { style: { textDecoration: 'line-through', textDecorationColor: color } }, markedText));
        default:
            return null;
    }
};
let dblClickTimer;
const AnnotationListItem = ({ annotation, selected }) => (state, actions) => {
    var _a, _b, _c, _d, _e;
    const isTextMarkupAnnotation = annotation.itemType === _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.HIGHLIGHT ||
        annotation.itemType === _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.SQUIGGLY ||
        annotation.itemType === _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.UNDERLINE ||
        annotation.itemType === _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_2__.PdfItemType.STRIKE_OUT;
    const { annotationNavigation } = state.options.viewer.sidebar;
    const textMarkupPreview = typeof annotationNavigation === 'object' && ((_a = annotationNavigation.textMarkup) === null || _a === void 0 ? void 0 : _a.preview)
        ? annotationNavigation.textMarkup.preview
        : 'none';
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_4__.classNames)('pwv-annotation-navigation-item', {
            'pwv-selected': selected,
            'pwv-deleted': annotation.isHidden(),
        }), id: `pwv-annotation-navigation-item-${annotation.id}`, onclick: () => {
            if (dblClickTimer) {
                window.clearTimeout(dblClickTimer);
                dblClickTimer = undefined;
            }
            else {
                dblClickTimer = window.setTimeout(() => {
                    actions.api.goToAnnotation({ annotation, action: 'select' });
                    dblClickTimer = undefined;
                }, 250);
            }
        }, ondblclick: () => {
            actions.api.goToAnnotation({ annotation, action: 'edit' });
            dblClickTimer = undefined;
        } },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(AnnotationIcon, { annotaion: annotation }),
            annotation.author && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-author" }, annotation.author),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("time", null, (_b = annotation.modificationDate) === null || _b === void 0 ? void 0 : _b.toLocaleString())),
        isTextMarkupAnnotation && textMarkupPreview === 'short' && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-overflow-ellipsis" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(TextMarkupPreview, { annotaion: annotation }))),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
            !state.options.annotation.hideAnnotationSubject && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h5", null, annotation.subject),
            annotation.content && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("p", null, annotation.content),
            !!annotation.isLocked() && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_3__.Icon, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_3__.icons.lock, className: "pwv-locked-icon" })),
        selected && annotation.privateData && annotation.privateData.length > 0 && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ms-custom-history-list" },
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("h5", null, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_1__.translationManager.getText('sideNavigation.annotation.history')),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("ul", null, (_e = (_d = (_c = JSON.parse(annotation.privateData)['PDF Tools AG']) === null || _c === void 0 ? void 0 : _c.Private) === null || _d === void 0 ? void 0 : _d.History) === null || _e === void 0 ? void 0 : _e.map((history) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(HistoryItem, { item: history }))))))));
};
function removeParentheses(value) {
    if (value === null) {
        return value;
    }
    return value.slice(1, value.length - 1);
}


/***/ }),

/***/ "./src/pdf-web-viewer/views/navigation/AnnotationNavigation.tsx":
/*!**********************************************************************!*\
  !*** ./src/pdf-web-viewer/views/navigation/AnnotationNavigation.tsx ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationNavigation": () => (/* binding */ AnnotationNavigation)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _AnnotationList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnnotationList */ "./src/pdf-web-viewer/views/navigation/AnnotationList.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");



const AnnotationNavigation = ({}) => (state, actions) => {
    const { annotations, annotationsLoaded } = state.navigationPanel;
    const pageNumbers = Object.keys(annotations).filter((pageNumber) => Object.keys(annotations[pageNumber]).length > 0);
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-annotation-navigation" },
        pageNumbers.length > 0 ? (pageNumbers.map((pageNumber) => (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_AnnotationList__WEBPACK_IMPORTED_MODULE_1__.AnnotationList, { pageNumber: pageNumber }))) : annotationsLoaded ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-NavigationPanel__NoItems" }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('sideNavigation.noAnnotations'))) : (''),
        !annotationsLoaded && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ItemLoader" })));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/navigation/NavigationPanel.tsx":
/*!*****************************************************************!*\
  !*** ./src/pdf-web-viewer/views/navigation/NavigationPanel.tsx ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavigationPanel": () => (/* binding */ NavigationPanel)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _state_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../state/layout */ "./src/pdf-web-viewer/state/layout.ts");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _common_Toolbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/Toolbar */ "./src/common/Toolbar.tsx");
/* harmony import */ var _common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../common/ToolbarItemGroup */ "./src/common/ToolbarItemGroup.tsx");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _ThumbnailNavigation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ThumbnailNavigation */ "./src/pdf-web-viewer/views/navigation/ThumbnailNavigation.tsx");
/* harmony import */ var _OutlineNavigation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./OutlineNavigation */ "./src/pdf-web-viewer/views/navigation/OutlineNavigation.tsx");
/* harmony import */ var _AnnotationNavigation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./AnnotationNavigation */ "./src/pdf-web-viewer/views/navigation/AnnotationNavigation.tsx");











let scrollTimer = null;
const NavigationPanel = ({}) => (state, actions) => {
    const { thumbnailNavigation, outlineNavigation, annotationNavigation } = state.options.viewer.sidebar;
    const tabCount = (thumbnailNavigation ? 1 : 0) + (outlineNavigation ? 1 : 0) + (annotationNavigation ? 1 : 0);
    const allowRotatePages = state.options.viewer.permissions.allowRotatePages && state.licenseFeatures.pageRotation;
    const { selectedNavigation, showNavigation } = state.navigationPanel;
    const useMobileLayout = state.layout.screenSize === _state_layout__WEBPACK_IMPORTED_MODULE_1__.ScreenSize.Small;
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_3__.classNames)('pwv-NavigationPanel', { 'pwv-NavigationPanel--open': showNavigation }) },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-NavigationPanel__Box" },
            tabCount > 1 && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Toolbar__WEBPACK_IMPORTED_MODULE_5__.Toolbar, null,
                !useMobileLayout && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_6__.ToolbarItemGroup, null,
                    thumbnailNavigation && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_7__.ToolbarButton, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.sidePaneThumbnails, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('sideNavigation.thumbnails'), active: selectedNavigation === 'thumbnail', disabled: !showNavigation, onClick: () => actions.navigationPanel.selectNavigation('thumbnail') })),
                    outlineNavigation && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_7__.ToolbarButton, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.sidePaneOutline, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('sideNavigation.outline'), active: selectedNavigation === 'outline', disabled: !showNavigation, onClick: () => actions.navigationPanel.selectNavigation('outline') })),
                    annotationNavigation && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_7__.ToolbarButton, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.sidePaneAnnotation, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('sideNavigation.annotation'), active: selectedNavigation === 'annotation', disabled: !showNavigation, onClick: () => actions.navigationPanel.selectNavigation('annotation') })))),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarItemGroup__WEBPACK_IMPORTED_MODULE_6__.ToolbarItemGroup, { pushRight: true },
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_7__.ToolbarButton, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_4__.icons.close, disabled: !showNavigation, onClick: actions.navigationPanel.toggleNavigationPanel })))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-NavigationPanel__Content", oncreate: (elm) => {
                    elm.addEventListener('scroll', () => {
                        if (scrollTimer) {
                            window.clearTimeout(scrollTimer);
                        }
                        scrollTimer = window.setTimeout(() => {
                            const fromPage = Math.floor(elm.scrollTop / 225) - 4;
                            const toPage = fromPage + Math.floor(elm.clientHeight / 225) + 8;
                            actions.api.addPageRangeToThumbnailsQueue({
                                from: fromPage,
                                to: toPage,
                            });
                        }, 100);
                    });
                } },
                selectedNavigation === 'thumbnail' && thumbnailNavigation && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_ThumbnailNavigation__WEBPACK_IMPORTED_MODULE_8__.ThumbnailNavigation, { pages: state.navigationPanel.pages, selectedPage: state.pdfDocument.pageNumber, currentPage: state.pdfDocument.pageNumber, allowRotatePages: allowRotatePages, onPageSelected: actions.api.setPageNumber, onRotatePage: actions.api.rotatePage }))),
                outlineNavigation && selectedNavigation === 'outline' && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_OutlineNavigation__WEBPACK_IMPORTED_MODULE_9__.OutlineNavigation, null))),
                annotationNavigation && selectedNavigation === 'annotation' && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
                    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_AnnotationNavigation__WEBPACK_IMPORTED_MODULE_10__.AnnotationNavigation, null)))))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/navigation/OutlineList.tsx":
/*!*************************************************************!*\
  !*** ./src/pdf-web-viewer/views/navigation/OutlineList.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OutlineList": () => (/* binding */ OutlineList)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");



const OutlineList = ({ items, path, onToggleItem, onOutlineItemSelected, }) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("ul", null, items.map((item) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(OutlineListItem, { item: item, path: path, onToggleItem: onToggleItem, onOutlineItemSelected: onOutlineItemSelected })))));
const OutlineListItem = ({ item, path, onToggleItem, onOutlineItemSelected, }) => {
    const childPath = path.filter((c) => true);
    childPath.push(item.id.toString());
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", null,
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
            item.hasDescendants ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)({ 'pwv-outline-tree-btn-expand': !item.open }, { 'pwv-outline-tree-btn-collapse': item.open }), onclick: () => {
                    onToggleItem(childPath);
                } },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, { icon: item.open ? _common_Icon__WEBPACK_IMPORTED_MODULE_2__.icons.outlineOpen : _common_Icon__WEBPACK_IMPORTED_MODULE_2__.icons.outlineClosed }))) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "pwv-outline-tree-indent" })),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", { onclick: () => {
                    onOutlineItemSelected(item.destination);
                }, class: "pwv-outline-tree-lnk" }, item.title)),
        item.open && item.descendants && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(OutlineList, { items: item.descendants, path: childPath, onToggleItem: onToggleItem, onOutlineItemSelected: onOutlineItemSelected }))));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/navigation/OutlineNavigation.tsx":
/*!*******************************************************************!*\
  !*** ./src/pdf-web-viewer/views/navigation/OutlineNavigation.tsx ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OutlineNavigation": () => (/* binding */ OutlineNavigation)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _OutlineList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OutlineList */ "./src/pdf-web-viewer/views/navigation/OutlineList.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");



const OutlineNavigation = ({}) => (state, actions) => {
    const { outlines, outlineItemsLoaded } = state.navigationPanel;
    return ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-outline-navigation" },
        outlines.length > 0 ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_OutlineList__WEBPACK_IMPORTED_MODULE_1__.OutlineList, { items: outlines, path: [], onToggleItem: actions.navigationPanel.toggleOutlineItem, onOutlineItemSelected: actions.api.goTo })) : outlineItemsLoaded ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-NavigationPanel__NoItems" }, _common_TranslationManager__WEBPACK_IMPORTED_MODULE_2__.translationManager.getText('sideNavigation.noOutline'))) : (''),
        !outlineItemsLoaded && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ItemLoader" })));
};


/***/ }),

/***/ "./src/pdf-web-viewer/views/navigation/ThumbnailNavigation.tsx":
/*!*********************************************************************!*\
  !*** ./src/pdf-web-viewer/views/navigation/ThumbnailNavigation.tsx ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThumbnailNavigation": () => (/* binding */ ThumbnailNavigation)
/* harmony export */ });
/* harmony import */ var _lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/hyperapp */ "./src/lib/hyperapp/index.js");
/* harmony import */ var _common_classNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/classNames */ "./src/common/classNames.ts");
/* harmony import */ var _common_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/Icon */ "./src/common/Icon.tsx");
/* harmony import */ var _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../pdf-viewer-api/enums */ "./src/pdf-viewer-api/enums.ts");
/* harmony import */ var _common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/ToolbarButton */ "./src/common/ToolbarButton.tsx");
/* harmony import */ var _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../common/TranslationManager */ "./src/common/TranslationManager.ts");






const ThumbnailNavigation = ({ pages, currentPage, allowRotatePages, onPageSelected, onRotatePage }, children) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-thumbnail-navigation" },
    (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("ul", null, pages.map((page) => ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("li", { id: `pwv-thumbnail-navigation-page_${page.pageNumber}`, key: page.pageNumber, class: (0,_common_classNames__WEBPACK_IMPORTED_MODULE_1__.classNames)('pwv-thumbnail-navigation-page', {
            'pwv-selected': page.pageNumber === currentPage,
        }) },
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-thumbnail-navigation-img-container" }, page.thumbnail !== null ? ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("img", { src: page.thumbnail, onclick: () => {
                onPageSelected(page.pageNumber);
            } })) : ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-page-placeholder", onclick: () => {
                onPageSelected(page.pageNumber);
            } }, page.loading === true && (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-ItemLoader" })))),
        (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-page-nr" },
            allowRotatePages && page.pageNumber === currentPage && ((0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pwv-page-rotation pwv-ToolbarItemGroup" },
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_2__.icons.rotateLeft, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__.translationManager.getText('rotatePage.counterclockwise'), onClick: () => {
                        onRotatePage({
                            page: page.pageNumber,
                            direction: _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_3__.RotationDirection.COUNTERCLOCKWISE,
                        });
                    } }),
                (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)(_common_ToolbarButton__WEBPACK_IMPORTED_MODULE_4__.ToolbarButton, { icon: _common_Icon__WEBPACK_IMPORTED_MODULE_2__.icons.rotateRight, tooltip: _common_TranslationManager__WEBPACK_IMPORTED_MODULE_5__.translationManager.getText('rotatePage.clockwise'), onClick: () => {
                        onRotatePage({
                            page: page.pageNumber,
                            direction: _pdf_viewer_api_enums__WEBPACK_IMPORTED_MODULE_3__.RotationDirection.CLOCKWISE,
                        });
                    } }))),
            (0,_lib_hyperapp__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, page.pageNumber))))))));


/***/ }),

/***/ "./src/lib/hyperapp/index.js":
/*!***********************************!*\
  !*** ./src/lib/hyperapp/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "app": () => (/* binding */ app),
/* harmony export */   "h": () => (/* binding */ h)
/* harmony export */ });
function h(name, attributes) {
  var rest = []
  var children = []
  var length = arguments.length

  while (length-- > 2) rest.push(arguments[length])

  while (rest.length) {
    var node = rest.pop()
    if (node && node.pop) {
      for (length = node.length; length--; ) {
        rest.push(node[length])
      }
    } else if (node != null && node !== true && node !== false) {
      children.push(node)
    }
  }

  return typeof name === "function"
    ? name(attributes || {}, children)
    : {
        nodeName: name,
        attributes: attributes || {},
        children: children,
        key: attributes && attributes.key
      }
}

function app(state, actions, view, container) {
  var map = [].map
  var rootElement = (container && container.children[0]) || null
  var oldNode = rootElement && recycleElement(rootElement)
  var lifecycle = []
  var skipRender
  var isRecycling = true
  var globalState = clone(state)
  var wiredActions = wireStateToActions([], globalState, clone(actions))

  scheduleRender()

  return wiredActions

  function recycleElement(element) {
    return {
      nodeName: element.nodeName.toLowerCase(),
      attributes: {},
      children: map.call(element.childNodes, function(element) {
        return element.nodeType === 3 // Node.TEXT_NODE
          ? element.nodeValue
          : recycleElement(element)
      })
    }
  }

  function resolveNode(node) {
    return typeof node === "function"
      ? resolveNode(node(globalState, wiredActions))
      : node != null
        ? node
        : ""
  }

  function render() {
    skipRender = !skipRender

    var node = resolveNode(view)

    if (container && !skipRender) {
      rootElement = patch(container, rootElement, oldNode, (oldNode = node))
    }

    isRecycling = false

    while (lifecycle.length) lifecycle.pop()()
  }

  function scheduleRender() {
    if (!skipRender) {
      skipRender = true
      setTimeout(render)
    }
  }

  function clone(target, source) {
    var out = {}

    for (var i in target) out[i] = target[i]
    for (var i in source) out[i] = source[i]

    return out
  }

  function setPartialState(path, value, source) {
    var target = {}
    if (path.length) {
      target[path[0]] =
        path.length > 1
          ? setPartialState(path.slice(1), value, source[path[0]])
          : value
      return clone(source, target)
    }
    return value
  }

  function getPartialState(path, source) {
    var i = 0
    while (i < path.length) {
      source = source[path[i++]]
    }
    return source
  }

  function wireStateToActions(path, state, actions) {
    for (var key in actions) {
      typeof actions[key] === "function"
        ? (function(key, action) {
            actions[key] = function(data) {
              var result = action(data)

              if (typeof result === "function") {
                result = result(getPartialState(path, globalState), actions)
              }

              if (
                result &&
                result !== (state = getPartialState(path, globalState)) &&
                !result.then // !isPromise
              ) {
                scheduleRender(
                  (globalState = setPartialState(
                    path,
                    clone(state, result),
                    globalState
                  ))
                )
              }

              return result
            }
          })(key, actions[key])
        : wireStateToActions(
            path.concat(key),
            (state[key] = clone(state[key])),
            (actions[key] = clone(actions[key]))
          )
    }

    return actions
  }

  function getKey(node) {
    return node ? node.key : null
  }

  function eventListener(event) {
    return event.currentTarget.events[event.type](event)
  }

  function updateAttribute(element, name, value, oldValue, isSvg) {
    if (name === "key") {
    } else if (name === "style") {
      if (typeof value === "string") {
        element.style.cssText = value
      } else {
        if (typeof oldValue === "string") oldValue = element.style.cssText = ""
        for (var i in clone(oldValue, value)) {
          var style = value == null || value[i] == null ? "" : value[i]
          if (i[0] === "-") {
            element.style.setProperty(i, style)
          } else {
            element.style[i] = style
          }
        }
      }
    } else {
      if (name[0] === "o" && name[1] === "n") {
        name = name.slice(2)

        if (element.events) {
          if (!oldValue) oldValue = element.events[name]
        } else {
          element.events = {}
        }

        element.events[name] = value

        if (value) {
          if (!oldValue) {
            element.addEventListener(name, eventListener)
          }
        } else {
          element.removeEventListener(name, eventListener)
        }
      } else if (
        name in element &&
        name !== "list" &&
        name !== "type" &&
        name !== "draggable" &&
        name !== "spellcheck" &&
        name !== "translate" &&
        !isSvg
      ) {
        element[name] = value == null ? "" : value
      } else if (value != null && value !== false) {
        element.setAttribute(name, value)
      }

      if (value == null || value === false) {
        element.removeAttribute(name)
      }
    }
  }

  function createElement(node, isSvg) {
    var element =
      typeof node === "string" || typeof node === "number"
        ? document.createTextNode(node)
        : (isSvg = isSvg || node.nodeName === "svg")
          ? document.createElementNS(
              "http://www.w3.org/2000/svg",
              node.nodeName
            )
          : document.createElement(node.nodeName)

    var attributes = node.attributes
    if (attributes) {
      if (attributes.oncreate) {
        lifecycle.push(function() {
          attributes.oncreate(element)
        })
      }

      for (var i = 0; i < node.children.length; i++) {
        element.appendChild(
          createElement(
            (node.children[i] = resolveNode(node.children[i])),
            isSvg
          )
        )
      }

      for (var name in attributes) {
        updateAttribute(element, name, attributes[name], null, isSvg)
      }
    }

    return element
  }

  function updateElement(element, oldAttributes, attributes, isSvg) {
    for (var name in clone(oldAttributes, attributes)) {
      if (
        attributes[name] !==
        (name === "value" || name === "checked"
          ? element[name]
          : oldAttributes[name])
      ) {
        updateAttribute(
          element,
          name,
          attributes[name],
          oldAttributes[name],
          isSvg
        )
      }
    }

    var cb = isRecycling ? attributes.oncreate : attributes.onupdate
    if (cb) {
      lifecycle.push(function() {
        cb(element, oldAttributes)
      })
    }
  }

  function removeChildren(element, node) {
    var attributes = node.attributes
    if (attributes) {
      for (var i = 0; i < node.children.length; i++) {
        removeChildren(element.childNodes[i], node.children[i])
      }

      if (attributes.ondestroy) {
        attributes.ondestroy(element)
      }
    }
    return element
  }

  function removeElement(parent, element, node) {
    function done() {
      parent.removeChild(removeChildren(element, node))
    }

    var cb = node.attributes && node.attributes.onremove
    if (cb) {
      cb(element, done)
    } else {
      done()
    }
  }

  function patch(parent, element, oldNode, node, isSvg) {
    if (node === oldNode) {
    } else if (oldNode == null || oldNode.nodeName !== node.nodeName) {
      var newElement = createElement(node, isSvg)
      parent.insertBefore(newElement, element)

      if (oldNode != null) {
        removeElement(parent, element, oldNode)
      }

      element = newElement
    } else if (oldNode.nodeName == null) {
      element.nodeValue = node
    } else {
      updateElement(
        element,
        oldNode.attributes,
        node.attributes,
        (isSvg = isSvg || node.nodeName === "svg")
      )

      var oldKeyed = {}
      var newKeyed = {}
      var oldElements = []
      var oldChildren = oldNode.children
      var children = node.children

      for (var i = 0; i < oldChildren.length; i++) {
        oldElements[i] = element.childNodes[i]

        var oldKey = getKey(oldChildren[i])
        if (oldKey != null) {
          oldKeyed[oldKey] = [oldElements[i], oldChildren[i]]
        }
      }

      var i = 0
      var k = 0

      while (k < children.length) {
        var oldKey = getKey(oldChildren[i])
        var newKey = getKey((children[k] = resolveNode(children[k])))

        if (newKeyed[oldKey]) {
          i++
          continue
        }

        if (newKey != null && newKey === getKey(oldChildren[i + 1])) {
          if (oldKey == null) {
            removeElement(element, oldElements[i], oldChildren[i])
          }
          i++
          continue
        }

        if (newKey == null || isRecycling) {
          if (oldKey == null) {
            patch(element, oldElements[i], oldChildren[i], children[k], isSvg)
            k++
          }
          i++
        } else {
          var keyedNode = oldKeyed[newKey] || []

          if (oldKey === newKey) {
            patch(element, keyedNode[0], keyedNode[1], children[k], isSvg)
            i++
          } else if (keyedNode[0]) {
            patch(
              element,
              element.insertBefore(keyedNode[0], oldElements[i]),
              keyedNode[1],
              children[k],
              isSvg
            )
          } else {
            patch(element, oldElements[i], null, children[k], isSvg)
          }

          newKeyed[newKey] = children[k]
          k++
        }
      }

      while (i < oldChildren.length) {
        if (getKey(oldChildren[i]) == null) {
          removeElement(element, oldElements[i], oldChildren[i])
        }
        i++
      }

      for (var i in oldKeyed) {
        if (!newKeyed[i]) {
          removeElement(element, oldKeyed[i][0], oldKeyed[i][1])
        }
      }
    }
    return element
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotationBorderStyle": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.AnnotationBorderStyle),
/* harmony export */   "AnnotationColorOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.AnnotationColorOptions),
/* harmony export */   "AnnotationFontOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.AnnotationFontOptions),
/* harmony export */   "AnnotationOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.AnnotationOptions),
/* harmony export */   "CanvasLayer": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.CanvasLayer),
/* harmony export */   "CanvasModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.CanvasModule),
/* harmony export */   "CanvasModuleType": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.CanvasModuleType),
/* harmony export */   "ColorPaletteMap": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.ColorPaletteMap),
/* harmony export */   "DocumentChange": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.DocumentChange),
/* harmony export */   "EraserModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.EraserModule),
/* harmony export */   "FileType": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.FileType),
/* harmony export */   "FormFieldModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.FormFieldModule),
/* harmony export */   "FormsOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.FormsOptions),
/* harmony export */   "FreetextAnnotationModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.FreetextAnnotationModule),
/* harmony export */   "GeneralOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.GeneralOptions),
/* harmony export */   "HighlightAnnotationModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.HighlightAnnotationModule),
/* harmony export */   "ImageAnnotationModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.ImageAnnotationModule),
/* harmony export */   "InkAnnotationModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.InkAnnotationModule),
/* harmony export */   "OptionsToVerify": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.OptionsToVerify),
/* harmony export */   "PdfActionType": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfActionType),
/* harmony export */   "PdfDestinationType": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfDestinationType),
/* harmony export */   "PdfFitMode": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfFitMode),
/* harmony export */   "PdfItemCategory": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemCategory),
/* harmony export */   "PdfItemType": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfItemType),
/* harmony export */   "PdfPageLayoutMode": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfPageLayoutMode),
/* harmony export */   "PdfViewerApi": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.PdfViewerApi),
/* harmony export */   "PdfViewerCanvas": () => (/* reexport safe */ _pdf_viewer_canvas_PdfViewerCanvas__WEBPACK_IMPORTED_MODULE_2__.PdfViewerCanvas),
/* harmony export */   "PdfWebViewer": () => (/* reexport safe */ _pdf_web_viewer_PdfWebViewer__WEBPACK_IMPORTED_MODULE_0__.PdfWebViewer),
/* harmony export */   "PopupModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.PopupModule),
/* harmony export */   "PrintServiceModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.PrintServiceModule),
/* harmony export */   "RotationDirection": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.RotationDirection),
/* harmony export */   "SearchResultType": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.SearchResultType),
/* harmony export */   "ShapeAnnotationModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.ShapeAnnotationModule),
/* harmony export */   "SidebarOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.SidebarOptions),
/* harmony export */   "StampAnnotationColor": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.StampAnnotationColor),
/* harmony export */   "StampAnnotationModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.StampAnnotationModule),
/* harmony export */   "StampType": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.StampType),
/* harmony export */   "TextAnnotationModule": () => (/* reexport safe */ _modules__WEBPACK_IMPORTED_MODULE_4__.TextAnnotationModule),
/* harmony export */   "ViewerOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.ViewerOptions),
/* harmony export */   "WebViewerOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.WebViewerOptions),
/* harmony export */   "WidgetType": () => (/* reexport safe */ _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__.WidgetType),
/* harmony export */   "defaultAnnotationColorOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultAnnotationColorOptions),
/* harmony export */   "defaultAnnotationFontOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultAnnotationFontOptions),
/* harmony export */   "defaultAnnotationOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultAnnotationOptions),
/* harmony export */   "defaultAnnotationStamps": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultAnnotationStamps),
/* harmony export */   "defaultFormsOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultFormsOptions),
/* harmony export */   "defaultGeneralOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultGeneralOptions),
/* harmony export */   "defaultKeyboardShortcuts": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultKeyboardShortcuts),
/* harmony export */   "defaultPermissions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultPermissions),
/* harmony export */   "defaultSidebarOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultSidebarOptions),
/* harmony export */   "defaultViewerModules": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultViewerModules),
/* harmony export */   "defaultViewerOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultViewerOptions),
/* harmony export */   "defaultWebViewerOptions": () => (/* reexport safe */ _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__.defaultWebViewerOptions)
/* harmony export */ });
/* harmony import */ var _pdf_web_viewer_PdfWebViewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pdf-web-viewer/PdfWebViewer */ "./src/pdf-web-viewer/PdfWebViewer.ts");
/* harmony import */ var _pdf_web_viewer_WebViewerOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pdf-web-viewer/WebViewerOptions */ "./src/pdf-web-viewer/WebViewerOptions.ts");
/* harmony import */ var _pdf_viewer_canvas_PdfViewerCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pdf-viewer-canvas/PdfViewerCanvas */ "./src/pdf-viewer-canvas/PdfViewerCanvas.ts");
/* harmony import */ var _pdf_viewer_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pdf-viewer-api */ "./src/pdf-viewer-api/index.ts");
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules */ "./src/modules/index.ts");






})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf-web-viewer.development.js.map